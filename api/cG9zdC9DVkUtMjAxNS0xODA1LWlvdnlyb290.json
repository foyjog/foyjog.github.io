{"title":"CVE-2015-1805(iovyroot)","date":"2018-08-27T08:15:52.000Z","slug":"CVE-2015-1805-iovyroot","updated":"2018-08-27T09:43:10.000Z","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这个root是大佬发给我看的,帖子来源于<a href=\"https://bbs.pediy.com/thread-210503.htm\" target=\"_blank\" rel=\"noopener\">https://bbs.pediy.com/thread-210503.htm</a> 看雪论坛,给了一个exp文件可以实现提权.但是这个确实花了一番功夫折腾,起初看的有点儿蒙蔽的意思,但是慢慢看就还是能够看明白的.</p>\n<p>这里还是只写一些我遇到的问题,说实话博客这东西确实得写一写,不然过一阵子你就忘了之前你看的那些东西,然后没有博客的话你还无从记起.所以记录一下还是很有必要的.</p>\n<h3 id=\"关于pipe-read中的chars\"><a href=\"#关于pipe-read中的chars\" class=\"headerlink\" title=\"关于pipe_read中的chars\"></a>关于pipe_read中的chars</h3><p>这个一开始懵逼在这儿了,愣是没明白chars为什么就是0x1000,后来我看了看代码,才发现chars其实是buf-&gt;len.而这个buf是pipe_buffer,pipe_buffer的结构体如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *\tstruct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class=\"line\"><span class=\"comment\"> *\t@page: the page containing the data for the pipe buffer</span></span><br><span class=\"line\"><span class=\"comment\"> *\t@offset: offset of data inside the @page</span></span><br><span class=\"line\"><span class=\"comment\"> *\t@len: length of data inside the @page</span></span><br><span class=\"line\"><span class=\"comment\"> *\t@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t@flags: pipe buffer flags. See above.</span></span><br><span class=\"line\"><span class=\"comment\"> *\t@private: private data owned by the ops.</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_buffer</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> offset, len;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pipe_buf_operations</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">private</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注释写的比较明白,length of data inside the @page,一般来说一个page_size在32位的机器上是4096,即0x1000.只要我们之前通过pipe_write()写入的字节够数,就会写满一个page,也就是0x1000.</p>\n<h3 id=\"关于通过sendmmsg堆喷\"><a href=\"#关于通过sendmmsg堆喷\" class=\"headerlink\" title=\"关于通过sendmmsg堆喷\"></a>关于通过sendmmsg堆喷</h3><p>这里面通过sendmmsg堆喷为什么管用的解释如下:(科恩分享的安卓内核UAF漏洞利用探秘)</p>\n<blockquote>\n<p>iovec 是数据内核中传递数据的结构。这个漏洞本身是 overrun，牵涉到我们在内核当中如何申请可控的overrun 数组。在安卓当中，很多 API 是被禁用的。最终我们找到 sendmmsg 的调用，你可以得到内容完全可控的数组。 它的坏处是放完以后就被销毁掉了。这个对象本身的生命周期不够长。看似这不是很好的对象，实际上可以回想起之前的一点，在 slub 中一个对象被释放之后，仅仅是在对象的头部写入了指针，这个指针指向下一个可以使用的对象。2015-1805 的代码路径当中，如果 iov 是 0，根本就不会被处理。如果说喷射的够快，漏洞利用过程够快，被释放掉的 iov 本身还是空的对象，或者又被另一个 iov 填上，根本不会对漏洞造成任何影响。我们只需要控制填进去的第一个 iov 的长度是 0，它就会被忽略掉。即便被释放，这个结果还是有效的 iov。</p>\n</blockquote>\n<p>所以这里面采用了sendmmsg堆喷,通过查看sendmmsg源码可以发现,一直可以调用到如下语句:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   iov_size = msg_sys-&gt;msg_iovlen * <span class=\"keyword\">sizeof</span>(struct iovec);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (msg_sys-&gt;msg_iovlen &gt; UIO_FASTIOV) &#123;</span><br><span class=\"line\">\tiov = sock_kmalloc(sock-&gt;sk, iov_size, GFP_KERNEL);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!iov)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过sock_kmalloc()在内核中分配一个iov_size为msg_iovlen ✖️ sizeof(struct iovec)的内存块,通过控制msg_iovlen = 0x200,即可喷射一个0x200*8=0x1000的块.<br>同时在<a href=\"http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html\" target=\"_blank\" rel=\"noopener\">http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html</a> 中看到</p>\n<blockquote>\n<p> 在rw_copy_check_uvector()函数里，首先会检查传入参数nr_segs（也就是iovcnt），是不是合法，如果nr_segs小于8，就使用栈上的iovstack；如果大于8，就kmalloc出一块新的内存作为iovstack。然后用copy_from_user()把用户态的iovec数组拷到内核态。这个iovstack会在后面调用read_pipe()的时候作为iov参数传入。</p>\n</blockquote>\n<p>可以通过利用pipe_read()传入0x200个iovec在内存中对齐一个页,所以这让堆喷变得十分的恰到好处.</p>\n<h3 id=\"关于race-condition和三次pipe-iov-copy-to-user调用\"><a href=\"#关于race-condition和三次pipe-iov-copy-to-user调用\" class=\"headerlink\" title=\"关于race_condition和三次pipe_iov_copy_to_user调用\"></a>关于race_condition和三次pipe_iov_copy_to_user调用</h3><p>race_condition让该root具有一个成功率的问题,通过调试readv()的字节数,可以让成功率增加.<br>至于为什么一定要三次copy呢?这里Retme的博客里面讲得非常清楚了.</p>\n<blockquote>\n<p>不能在loop_time = 2的时候触发overrun,否则overrun会使用copy_to_user而不是__copy_to_user,那么还是无法写内核地址解决办法是让total_len 稍稍大于 buf-&gt;len(0x1000)这样loop_time = 2的时候能保证把一个合法的buf-&gt;len读完。并且会因为buf-&gt;len被读完，tolen_len却还有剩余，而进入第三个loop然后在loop_time = 3的时候走atomic=1的路线，进行越界使用iov</p>\n</blockquote>\n<p>!iov_fault_in_pages_write(iov, chars)只是检查内存空间是否有写权限,并不判断是否为内核空间,因为其调用的是__put_user(0, uaddr),而copy_to_user()中的access_ok是会检查要操作的用户空间的地址范围是否在当前进程的用户地址空间限制中。这可以参考博客: <a href=\"https://blog.csdn.net/ysgjiangsu/article/details/50380728\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ysgjiangsu/article/details/50380728</a><br>而三次pipe_iov_copy_to_user的调用大致情况如下:<br><img src=\"/img/race_condition.png\" alt=\"raceconditon\"></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://www.kejilie.com/leiphone/article/Q7RrAj.html\" target=\"_blank\" rel=\"noopener\">http://www.kejilie.com/leiphone/article/Q7RrAj.html</a><br><a href=\"http://luodw.cc/2016/08/01/pipeof/\" target=\"_blank\" rel=\"noopener\">http://luodw.cc/2016/08/01/pipeof/</a><br><a href=\"https://bbs.pediy.com/thread-210503.htm\" target=\"_blank\" rel=\"noopener\">https://bbs.pediy.com/thread-210503.htm</a><br><a href=\"http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html\" target=\"_blank\" rel=\"noopener\">http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html</a><br><a href=\"http://www.cnblogs.com/jiayy/p/4831844.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/jiayy/p/4831844.html</a><br><a href=\"https://blog.csdn.net/ysgjiangsu/article/details/50380728\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ysgjiangsu/article/details/50380728</a></p>\n","prev":{"title":"CVE-2017-8890(Phoenix Talon)","slug":"CVE-2017-8890-Phoenix-Talon"},"next":{"title":"CVE-2015-3636(pingpong root)","slug":"CVE-2015-3636-pingpong-root"},"link":"https://foyjog.github.io/post/CVE-2015-1805-iovyroot/"}