{"title":"Linux Kernel Exploitation on Linux-csaw2014","date":"2018-07-04T02:26:49.000Z","slug":"Linux-Kernel-Exploitation-on-Linux-csaw2014","updated":"2018-07-04T03:33:08.000Z","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>题目也很长,但是功能也就那一些,这个内核驱动的目的是一个内核的hook,达到rootkit的目的,当然,题目没有做实际的rootkit,只是给了一个形式.<br>关于linux的rootkit可以参考freebuf上的rootkit系列:<a href=\"http://www.freebuf.com/sectool/105713.html\" target=\"_blank\" rel=\"noopener\">http://www.freebuf.com/sectool/105713.html</a></p>\n<p>认真查看代码就能够了解,其实这个漏洞是一个比较简单的UAF的漏洞,kmalloc-kfree-kmalloc就能达到提权的目的.</p>\n<h3 id=\"init函数\"><a href=\"#init函数\" class=\"headerlink\" title=\"init函数\"></a>init函数</h3><p>首先查看init函数.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">init <span class=\"title\">i_solemnly_swear_that_i_am_up_to_no_good</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Find system call table */</span></span><br><span class=\"line\">    sys_call_table = find_sys_call_table();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Install channel for communication with the rootkit */</span></span><br><span class=\"line\">    orig_sys_shmctl = *(<span class=\"keyword\">void</span> **)(sys_call_table + __NR_shmctl);</span><br><span class=\"line\">    write_ulong(sys_call_table + __NR_shmctl, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;hook_sys_shmctl);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Hook /proc for hiding processes */</span></span><br><span class=\"line\">    orig_proc_iterate = hook_vfs_iterate(<span class=\"string\">\"/proc\"</span>, &amp;hook_proc_iterate);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Hook / for hiding files */</span></span><br><span class=\"line\">    orig_root_iterate = hook_vfs_iterate(<span class=\"string\">\"/\"</span>, &amp;hook_root_iterate);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>题目友好的给出了详细的注释,其实目的就是通过hook sys_call_table来达到控制shmctl系统调用,和控制迭代/proc目录和/目录的目的.<br>观察init中hook_proc_iterate和hook_root_iterate的代码:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hook_proc_iterate</span> <span class=\"params\">( struct file *file, struct dir_context *ctx )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    proc_filldir = ctx-&gt;actor;</span><br><span class=\"line\">    *((<span class=\"keyword\">filldir_t</span> *)&amp;ctx-&gt;actor) = hook_proc_filldir;</span><br><span class=\"line\">    ret = orig_proc_iterate(file, ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hook_root_iterate</span> <span class=\"params\">( struct file *file, struct dir_context *ctx )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    root_filldir = ctx-&gt;actor;</span><br><span class=\"line\">    *((<span class=\"keyword\">filldir_t</span> *)&amp;ctx-&gt;actor) = hook_root_filldir;</span><br><span class=\"line\">    ret = orig_root_iterate(file, ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里使用hook_proc_filldir和hook_root_filldir勾掉原本的proc_filldir函数.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hook_proc_filldir</span><span class=\"params\">( <span class=\"keyword\">void</span> *__buf, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">int</span> namelen, <span class=\"keyword\">loff_t</span> offset, u64 ino, <span class=\"keyword\">unsigned</span> d_type )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hidden_pid</span> *<span class=\"title\">hp</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *endp;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> pid;</span><br><span class=\"line\"></span><br><span class=\"line\">    DEBUG(<span class=\"string\">\"%s: enter, name=%s\\n\"</span>, __func__, name);</span><br><span class=\"line\"></span><br><span class=\"line\">    pid = simple_strtol(name, &amp;endp, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    list_for_each_entry ( hp, &amp;hidden_pids, <span class=\"built_in\">list</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DEBUG(<span class=\"string\">\"Checking name against: %ld-%ld\\n\"</span>, hp-&gt;pid_start, hp-&gt;pid_end);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (pid &gt;= hp-&gt;pid_start) &amp;&amp; (pid &lt;= hp-&gt;pid_end) )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> proc_filldir(__buf, name, namelen, offset, ino, d_type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hook_root_filldir</span><span class=\"params\">( <span class=\"keyword\">void</span> *__buf, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">int</span> namelen, <span class=\"keyword\">loff_t</span> offset, u64 ino, <span class=\"keyword\">unsigned</span> d_type )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hidden_file</span> *<span class=\"title\">hf</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    DEBUG(<span class=\"string\">\"%s: enter, name=%s\\n\"</span>, __func__, name);</span><br><span class=\"line\"></span><br><span class=\"line\">    list_for_each_entry ( hf, &amp;hidden_files, <span class=\"built_in\">list</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DEBUG(<span class=\"string\">\"Checking name against: '%s' with callback %p\\n\"</span>, hf-&gt;name, hf-&gt;cb);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"built_in\">strstr</span>(name, hf-&gt;name) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            DEBUG(<span class=\"string\">\"Match!\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( hf-&gt;cb )</span><br><span class=\"line\">                hf-&gt;cb(hf);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DEBUG(<span class=\"string\">\"%s: end\\n\"</span>, __func__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root_filldir(__buf, name, namelen, offset, ino, d_type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以,当我们执行readdir()函数的时候,readdir函数在内部使用fillonedir回调函数,所以我们的hook_proc_filldir和hook_root_filldir会被执行.</p>\n<h3 id=\"UAF漏洞处\"><a href=\"#UAF漏洞处\" class=\"headerlink\" title=\"UAF漏洞处\"></a>UAF漏洞处</h3><p>在hook_sys_shmctl中,可以通过cmd进行进程的隐藏,进程的恢复,文件的隐藏,文件的恢复等功能.<br>我们看一下unhide_file函数.再对比一下unhide_pid,可以发现一个问题,我们将file,free之后,并没有将其从list中删除,我们仍然可以通过它的name在list中获取它.我们观察hook_root_filldir函数,因为我们没有在 list中删除我们刚free掉的文件,通过name我们仍然可以调用到它的hf-&gt;cb函数,这本来是一个debug函数.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unhide_file</span> <span class=\"params\">( <span class=\"keyword\">char</span> *name )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hidden_file</span> *<span class=\"title\">hf</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    list_for_each_entry ( hf, &amp;hidden_files, <span class=\"built_in\">list</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ! <span class=\"built_in\">strcmp</span>(name, hf-&gt;name) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            suckerusu_kfree(hf-&gt;name);</span><br><span class=\"line\">            suckerusu_kfree(hf);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">////////////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unhide_pid</span> <span class=\"params\">( <span class=\"keyword\">long</span> pid_start, <span class=\"keyword\">long</span> pid_end )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hidden_pid</span> *<span class=\"title\">hp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    list_for_each_entry ( hp, &amp;hidden_pids, <span class=\"built_in\">list</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (pid_start == hp-&gt;pid_start) &amp;&amp; (pid_end == hp-&gt;pid_end) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            list_del(&amp;hp-&gt;<span class=\"built_in\">list</span>);</span><br><span class=\"line\">            suckerusu_kfree(hp);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好了,前途一片光明,UAF就可以了,我们发现hidden_pid和hidden_file是一个同样大小的.那么就很好办了.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hidden_pid</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> pid_start;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> pid_end;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hidden_file</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*cb)(struct hidden_file *);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>流程大致如下:</p>\n<ol>\n<li>hide_file函数调用 - &gt;内存分配</li>\n<li>unhide_file函数调用 - &gt;内存返回</li>\n<li>hide_pid函数调用 - &gt;内存分配 - &gt; hf-&gt; cb覆盖区域(将其设置为upup函数地址)</li>\n<li>调用readdir即可.</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://blackperl-security.gitlab.io/blog/2018/06/22/2018-06-22-csaw2014-kernelex/\" target=\"_blank\" rel=\"noopener\">https://blackperl-security.gitlab.io/blog/2018/06/22/2018-06-22-csaw2014-kernelex/</a><br><a href=\"http://www.freebuf.com/articles/system/108392.html\" target=\"_blank\" rel=\"noopener\">http://www.freebuf.com/articles/system/108392.html</a></p>\n","prev":{"title":"Linux Kernel Exploitation on Linux-csaw2015","slug":"Linux-Kernel-Exploitation-on-Linux-csaw2015"},"next":{"title":"Linux Kernel Exploitation on Android-csaw2013","slug":"Linux-Kernel-Exploitation-on-Android-csaw2013"},"link":"https://foyjog.github.io/post/Linux-Kernel-Exploitation-on-Linux-csaw2014/"}