{"title":"CVE-2015-3636(pingpong root)","date":"2018-08-19T13:42:25.000Z","slug":"CVE-2015-3636-pingpong-root","updated":"2018-08-19T14:24:34.000Z","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>辞职了,两个月真的是非常的快,感觉啥也没做就已经离开公司了,虽然日常经常做一些重复性,感觉没有很多技术含量的事情,但其实不知不觉能力得到了一定的提升的.<br>所以,时间多出来了,就跑跑一些cve了,工作两个月,跑了那么久的fuzz,都没有好好的跑过一个通用型高的root方案,真是惭愧,刚好看雪安全论坛出了一个关于cve-2015-3636的帖子,写的甚是详细(感谢大佬),所以就拿来跑一波,感受一下当年的神级洞的魅力.</p>\n<h3 id=\"关于利用\"><a href=\"#关于利用\" class=\"headerlink\" title=\"关于利用\"></a>关于利用</h3><p>根据该文章:<a href=\"https://blog.csdn.net/koozxcv/article/details/50976884\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/koozxcv/article/details/50976884</a> 的讲解,还是能够比较容易的明白该漏洞存在的问题的.这是一个可以说是非常完美的uaf的漏洞,因为uaf的对象是一个sock结构体,这个sock结构体中包含了大量的函数指针,所以这对我们利用来说就非常的舒服了.而整个漏洞的利用过程就可以参考<a href=\"https://bbs.pediy.com/thread-230298.htm\" target=\"_blank\" rel=\"noopener\">https://bbs.pediy.com/thread-230298.htm</a> 这篇文章了,非常详细具体,大佬威武.所以跟着这两篇文章我还是把整个流程也走了一遍.两篇文章写的非常的详细,所以在这里记录一下我自己遇到的一些问题.</p>\n<h3 id=\"关于补丁的作用\"><a href=\"#关于补丁的作用\" class=\"headerlink\" title=\"关于补丁的作用\"></a>关于补丁的作用</h3><p>补丁就一行.目的是将node-&gt;pprev = NULL;<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> __<span class=\"function\">inline__ <span class=\"keyword\">void</span> <span class=\"title\">sk_nulls_node_init</span><span class=\"params\">(struct hlist_nulls_node *node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tnode-&gt;pprev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们知道,该uaf是因为两次connect函数导致了sk_free(sk)函数的执行,所以将node-&gt;pprev = NULL之后,<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (sk_hashed(sk)) &#123;</span><br><span class=\"line\">\t\twrite_lock_bh(&amp;ping_table.lock);</span><br><span class=\"line\">\t\thlist_nulls_del(&amp;sk-&gt;sk_nulls_node);</span><br><span class=\"line\">\t\tsk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span><br><span class=\"line\">\t\tsock_put(sk);</span><br><span class=\"line\">\t\tisk-&gt;inet_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tisk-&gt;inet_sport = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tsock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\twrite_unlock_bh(&amp;ping_table.lock);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">hlist_unhashed</span><span class=\"params\">(<span class=\"keyword\">const</span> struct hlist_node *h)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !h-&gt;pprev;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">sk_unhashed</span><span class=\"params\">(<span class=\"keyword\">const</span> struct sock *sk)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hlist_unhashed(&amp;sk-&gt;sk_node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">sk_hashed</span><span class=\"params\">(<span class=\"keyword\">const</span> struct sock *sk)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !sk_unhashed(sk);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>sk_hashed(sk)就不会判断为真,那么第二次的connect就不会执行sock_put(sk)函数,也就不会触发free函数了.</p>\n<h3 id=\"绕过pxn和泄漏sp指针\"><a href=\"#绕过pxn和泄漏sp指针\" class=\"headerlink\" title=\"绕过pxn和泄漏sp指针\"></a>绕过pxn和泄漏sp指针</h3><p>pxn的绕过感觉是比较有技术含量的一个点了,但是其实文章中都讲的比较清楚,所以参考<a href=\"https://github.com/jianqiangzhao/mosec2016/blob/master/Android%20Root%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%EF%BC%9A%E7%BB%95%E8%BF%87PXN.ppt\" target=\"_blank\" rel=\"noopener\">https://github.com/jianqiangzhao/mosec2016/blob/master/Android%20Root%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%EF%BC%9A%E7%BB%95%E8%BF%87PXN.ppt</a> 也就能比较清楚的了解该pxn绕过方法了,泄漏sp指针采用了一个gadget,说实话找到内核中有这么个gadget真的是666了.这其中采用了pipe管道通信的方式来读写内核的任意地址是第一次见(毕竟第一次调试cve= =),要好好记下来.</p>\n<h3 id=\"关于Physmap的利用方式\"><a href=\"#关于Physmap的利用方式\" class=\"headerlink\" title=\"关于Physmap的利用方式\"></a>关于Physmap的利用方式</h3><p>虽然这个利用方式现在是不奏效了,但是当时能够想到这个方法大佬真是巨牛逼了.这里我一直有个疑问,slab分配的sock结构体的地址是在内核地址当中的,当我调试的时候发现返回的地址都在用户空间中.(mmap肯定返回一个用户地址的= =)<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   *(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> *)((<span class=\"keyword\">char</span> *)payload + <span class=\"number\">0x28</span>)  = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)payload;</span><br><span class=\"line\">*(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> *)((<span class=\"keyword\">char</span> *)payload)         = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)<span class=\"number\">0xFFFFFFC00035D788</span>;</span><br><span class=\"line\">*(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> *)((<span class=\"keyword\">char</span> *)payload + <span class=\"number\">0x68</span>)  = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)<span class=\"number\">0xFFFFFFC00035D7C0</span>;</span><br></pre></td></tr></table></figure></p>\n<p>通过查看0xffffffc02e860000的内核空间和0x0000007082ea9000的用户空间发现他们是一样的.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef&gt; x/<span class=\"number\">50</span>g <span class=\"number\">0x0000007082ea9000</span></span><br><span class=\"line\"><span class=\"number\">0x7082ea9000</span>:\t<span class=\"number\">0xffffffc00035d788</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0x7082ea9010</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0x7082ea9020</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x0000007082ea9000</span></span><br><span class=\"line\"><span class=\"number\">0x7082ea9030</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0x7082ea9040</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0x7082ea9050</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0x7082ea9060</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0xffffffc00035d7c0</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef&gt; x/<span class=\"number\">50</span>g <span class=\"number\">0xffffffc02e860000</span></span><br><span class=\"line\"><span class=\"number\">0xffffffc02e860000</span>:\t<span class=\"number\">0xffffffc00035d788</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0xffffffc02e860010</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0xffffffc02e860020</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x0000007082ea9000</span></span><br><span class=\"line\"><span class=\"number\">0xffffffc02e860030</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0xffffffc02e860040</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0xffffffc02e860050</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0x4141414141414141</span></span><br><span class=\"line\"><span class=\"number\">0xffffffc02e860060</span>:\t<span class=\"number\">0x4141414141414141</span>\t<span class=\"number\">0xffffffc00035d7c0</span></span><br></pre></td></tr></table></figure>\n<p>在<a href=\"https://paper.seebug.org/451/\" target=\"_blank\" rel=\"noopener\">https://paper.seebug.org/451/</a> 文章中,解释了有一段名为physmap的内核内存，其中内核保留一个映射到与用户区内存具有相同物理内存的“alias”（虚拟地址）。因此，在用户区创建一个填充0x41的页面后，内核中确实存在一个可以找到与该页面完全相同的网页地址。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>调试的命令通过增加-verbose -show-kernel命令可以从输出中看到如下模拟语句,<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./qemu/linux-x86_64/qemu-system-aarch64 -cpu cortex-a57 -machine <span class=\"built_in\">type</span>=ranchu -m 1024 -append <span class=\"string\">'console=ttyAMA0,38400 keep_bootcon earlyprintk=ttyAMA0'</span> -serial mon:stdio -kernel .//Image -initrd .//ramdisk.img -drive index=0,id=sdcard,file=.//system.img -device virtio-blk-device,drive=sdcard -drive index=1,id=userdata,file=.//.//userdata.img -device virtio-blk-device,drive=userdata -drive index=2,id=cache,file=.//cache.img -device virtio-blk-device,drive=cache -drive index=3,id=system,file=.//system.img -device virtio-blk-device,drive=system -netdev user,id=mynet -device virtio-net-device,netdev=mynet -show-cursor -nographic -L lib/pc-bios</span><br></pre></td></tr></table></figure></p>\n<p>然后增加-s -S命令即可顺利调试.</p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p><a href=\"https://blog.csdn.net/koozxcv/article/details/50976884\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/koozxcv/article/details/50976884</a><br><a href=\"https://paper.seebug.org/451/\" target=\"_blank\" rel=\"noopener\">https://paper.seebug.org/451/</a><br><a href=\"https://bbs.pediy.com/thread-230298.htm\" target=\"_blank\" rel=\"noopener\">https://bbs.pediy.com/thread-230298.htm</a></p>\n","prev":{"title":"CVE-2015-1805(iovyroot)","slug":"CVE-2015-1805-iovyroot"},"next":{"title":"double free之Fastbin Attack","slug":"double-free之Fastbin-Attack"},"link":"https://foyjog.github.io/post/CVE-2015-3636-pingpong-root/"}