<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="foyjog"><title>Linux Kernel Exploitation on Android-csaw2011 · foyjog</title><meta name="description" content="前言说实话这个题目还是没有出来,但是我认为该题应该是vmlinux的一些问题,我试了比较久,一直不能让restart_block击中题目特别设置的0x9e3779b9,感觉应该是我编译的vmlinux没有开启cannay,一个函数的栈的大小和原题应该有出入之类导致的,(估计是我比较菜啦),但是这道题"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">foyjog</a></h3><div class="description"><p>email:foyjog@163.com</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Linux Kernel Exploitation on Android-csaw2011</a></h3></div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说实话这个题目还是没有出来,但是我认为该题应该是vmlinux的一些问题,我试了比较久,一直不能让restart_block击中题目特别设置的0x9e3779b9,感觉应该是我编译的vmlinux没有开启cannay,一个函数的栈的大小和原题应该有出入之类导致的,(估计是我比较菜啦),但是这道题目的主要内容还是学到了的,这里给出我的分析.</p>
<h1 id="关于内核栈"><a href="#关于内核栈" class="headerlink" title="关于内核栈"></a>关于内核栈</h1><p>在Linux上，系统上的每个线程都在内核内存中分配了相应的内核堆栈。x86上的Linux内核堆栈大小为4096或8192字节，因为有些程序需要从用户态进入内核态,当发生转换的时候,栈也会随着从用户栈转移为内核栈,而内核栈的结构如下图所示:<br><img src="/img/kstack.png" alt="我是图片"><br>因为内核栈比较小,所以非常容易溢出,如下图所示:<br><img src="/img/kstack-smash.png" alt="我是图片"><br>tread_info的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>  *<span class="title">exec_domain</span>;</span></span><br><span class="line">    __u32                flags;</span><br><span class="line">    __u32                status;</span><br><span class="line">    __u32                cpu;</span><br><span class="line">    <span class="keyword">int</span>                  preempt_count;</span><br><span class="line">    <span class="keyword">mm_segment_t</span>         addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user         *sysenter_return;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        previous_esp;</span><br><span class="line">    __u8                 supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span>                  uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>作用是啥,因为thread_info很大,里面保存了restart_block指针,如果我们能溢出restart_block指针的值的话就可以通过如下调用来直接转入我们的函数执行:<br>restart_block的结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> (*fn)(struct restart_block *);</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/* For futex_wait and futex_wait_requeue_pi */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; futex;</span><br><span class="line">        <span class="comment">/* For nanosleep */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; nanosleep;</span><br><span class="line">        <span class="comment">/* For poll */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; poll;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>restart_syscall的定义如下,发现其实调用了restart_block的fn指针作为函数来执行.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(restart_syscall)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart</span> = &amp;<span class="title">current_thread_info</span>()-&gt;<span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="keyword">return</span> restart-&gt;fn(restart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们只需要调用syscall(SYS_restart_syscall);就能执行我们溢出的指针值了.</p>
<h1 id="关于gdb调试内核的一些操作"><a href="#关于gdb调试内核的一些操作" class="headerlink" title="关于gdb调试内核的一些操作"></a>关于gdb调试内核的一些操作</h1><h3 id="通过info-stack来查看堆栈"><a href="#通过info-stack来查看堆栈" class="headerlink" title="通过info stack来查看堆栈"></a>通过info stack来查看堆栈</h3><p><img src="/img/info_stack.png" alt="我是图片"></p>
<h3 id="通过如下操作查看当前内核栈中的thread-info结构体"><a href="#通过如下操作查看当前内核栈中的thread-info结构体" class="headerlink" title="通过如下操作查看当前内核栈中的thread_info结构体."></a>通过如下操作查看当前内核栈中的thread_info结构体.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  *((struct thread_info*)(((<span class="keyword">uint32_t</span>)$sp &amp; <span class="number">0xffffe000</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/img/thread_info.png" alt="我是图片"></p>
<h3 id="通过如下操作查看restart-block的结构体"><a href="#通过如下操作查看restart-block的结构体" class="headerlink" title="通过如下操作查看restart_block的结构体"></a>通过如下操作查看restart_block的结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  ((struct thread_info*)(((<span class="keyword">uint32_t</span>)$sp &amp; <span class="number">0xffffe000</span>)))-&gt;restart_block</span><br></pre></td></tr></table></figure>
<p><img src="/img/restart_block.png" alt="我是图片"></p>
<h1 id="关于mmap申请一块内存"><a href="#关于mmap申请一块内存" class="headerlink" title="关于mmap申请一块内存"></a>关于mmap申请一块内存</h1><p>mmap的原型如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：<br><img src="/img/mmap.png" alt="我是图片"><br>linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：<br><img src="/img/vm_area_struct.png" alt="我是图片"><br>在题解中,使用了如下的代码进行内存的分配:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">setup_payload(<span class="keyword">unsigned</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* asm(mov $addr, %eax; jmp *%eax); is 7 bytes wide */</span></span><br><span class="line">        <span class="keyword">unsigned</span> size = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> round_addr = addr &amp; PAGE_MASK;</span><br><span class="line">        <span class="keyword">unsigned</span> diff       = addr - round_addr;</span><br><span class="line">        <span class="keyword">unsigned</span> len        = (size + diff + (PAGE_SIZE - <span class="number">1</span>)) &amp; PAGE_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buf = mmap((<span class="keyword">void</span> *)round_addr, len, PROT_READ|PROT_WRITE|PROT_EXEC,</span><br><span class="line">                        MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf == MAP_FAILED)</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">        generate_shellcode(buf + diff);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] Payload set\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为使用mmap需要注意的一个关键点是，mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a><br><a href="http://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/" target="_blank" rel="noopener">http://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-07-02</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://foyjog.github.io/2018/07/02/Linux-Kernel-Exploitation-on-Android-csaw2011/,foyjog,Linux Kernel Exploitation on Android-csaw2011,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/06/27/Linux-Kernel-Exploitation-on-Android-Stack-Buffer-overflow/" title="Linux Kernel Exploitation on Android-Stack Buffer overflow">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>